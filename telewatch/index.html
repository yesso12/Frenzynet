<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frenzy Telewatch | Synced Watch Rooms</title>
  <style>
    :root {
      --bg: #f4f6fa;
      --bg-gradient: linear-gradient(180deg, #f8f9fc, #f3f6fa);
      --bg-graphic-image: url('/assets/themes/clean-default.svg');
      --bg-graphic-size: cover;
      --bg-graphic-position: center;
      --bg-graphic-opacity: 0.52;
      --panel: #ffffff;
      --panel-2: #fbfcfe;
      --line: #dbe2ea;
      --line-soft: #e9eef4;
      --text: #18212c;
      --muted: #6a7787;
      --accent: #ff5f1f;
      --accent-strong: #e04d11;
      --good: #168252;
      --warn: #9e5d00;
      --danger: #b42318;
      --shadow: 0 10px 28px rgba(16, 24, 40, 0.08);
      --pill-bg: #f8fafc;
      --pill-line: #dbe2ea;
      --pill-text: #314155;
      --input-bg: #ffffff;
      --input-line: #d1dae5;
      --input-focus: #ff925f;
      --input-focus-glow: rgba(255, 95, 31, 0.15);
      --tab-active-bg: #fff3ec;
      --tab-active-text: #a43f12;
      --tab-active-line: #ff925f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--text);
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: var(--bg-gradient);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    .bg-scene {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }
    .bg-graphic {
      position: absolute;
      inset: 0;
      background-image: var(--bg-graphic-image);
      background-position: var(--bg-graphic-position);
      background-size: var(--bg-graphic-size);
      background-repeat: no-repeat;
      opacity: var(--bg-graphic-opacity);
      transform: scale(1.02);
      filter: saturate(1.08) contrast(1.02);
    }
    .bg-grid {
      position: absolute;
      inset: 0;
      opacity: 0.16;
      background-image:
        linear-gradient(rgba(255,255,255,0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.08) 1px, transparent 1px);
      background-size: 34px 34px;
      mask-image: radial-gradient(circle at 50% 30%, black 30%, transparent 85%);
    }
    .bg-noise {
      position: absolute;
      inset: -20%;
      opacity: 0.08;
      background-image:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,0.8) 0.7px, transparent 1px),
        radial-gradient(circle at 80% 40%, rgba(255,255,255,0.65) 0.7px, transparent 1px),
        radial-gradient(circle at 50% 70%, rgba(255,255,255,0.55) 0.7px, transparent 1px);
      background-size: 4px 4px, 5px 5px, 6px 6px;
      animation: driftNoise 22s linear infinite;
    }
    .bg-orb {
      position: absolute;
      width: 42vw;
      height: 42vw;
      min-width: 260px;
      min-height: 260px;
      border-radius: 50%;
      filter: blur(42px);
      opacity: 0.34;
      animation: driftOrb 18s ease-in-out infinite alternate;
    }
    .bg-orb.a {
      background: radial-gradient(circle, rgba(255, 112, 71, 0.8), rgba(255, 112, 71, 0));
      top: -14vw;
      left: -10vw;
    }
    .bg-orb.b {
      background: radial-gradient(circle, rgba(94, 173, 255, 0.72), rgba(94, 173, 255, 0));
      bottom: -16vw;
      right: -9vw;
      animation-delay: -6s;
    }
    .bg-orb.c {
      background: radial-gradient(circle, rgba(189, 113, 255, 0.62), rgba(189, 113, 255, 0));
      top: 30%;
      left: 35%;
      width: 30vw;
      height: 30vw;
      animation-delay: -10s;
    }
    @keyframes driftOrb {
      0% { transform: translate3d(0, 0, 0) scale(1); }
      100% { transform: translate3d(18px, -18px, 0) scale(1.08); }
    }
    @keyframes driftNoise {
      0% { transform: translate3d(0, 0, 0); }
      100% { transform: translate3d(-3%, 2%, 0); }
    }
    .wrap {
      width: min(1240px, calc(100% - 28px));
      margin: 18px auto 30px;
      position: relative;
      z-index: 2;
    }
    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 14px 16px;
    }
    .hero {
      display: grid;
      gap: 4px;
    }
    .hero h1 {
      margin: 0;
      font-size: 25px;
      letter-spacing: 0.01em;
    }
    .hero p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      padding: 7px 11px;
      border-radius: 999px;
      background: var(--pill-bg);
      border: 1px solid var(--pill-line);
      color: var(--pill-text);
      font-weight: 700;
      font-size: 12px;
    }
    .theme-select {
      max-width: 230px;
      min-width: 170px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--pill-line);
      background: var(--pill-bg);
      color: var(--pill-text);
      font-weight: 700;
    }
    .wizard {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .wizard-step {
      font-size: 11px;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 999px;
      padding: 4px 9px;
      color: #607184;
      font-weight: 700;
    }
    .wizard-step.active {
      border-color: var(--tab-active-line);
      background: var(--tab-active-bg);
      color: var(--tab-active-text);
    }
    .workspace {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
    }
    .card {
      border: 1px solid var(--line);
      border-radius: 15px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    h2, h3 { margin: 0; }
    h2 { font-size: 18px; }
    h3 {
      margin-top: 2px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #516072;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .muted { color: var(--muted); }
    .stack { display: grid; gap: 10px; }
    .panel-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      border-bottom: 1px solid var(--line);
      padding-bottom: 8px;
    }
    .tab-btn {
      border: 1px solid #d1dae5;
      background: #fff;
      color: #33475f;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .tab-btn.active {
      border-color: var(--tab-active-line);
      background: var(--tab-active-bg);
      color: var(--tab-active-text);
    }
    .tab-pane { display: none; }
    .tab-pane.active { display: grid; gap: 10px; }
    .block {
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      background: var(--panel-2);
      padding: 11px;
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 120px; }
    label {
      font-size: 11px;
      color: #5f6e7f;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      margin-bottom: 5px;
      display: block;
    }
    input, button, textarea, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--input-line);
      background: var(--input-bg);
      color: var(--text);
      padding: 10px 11px;
      font: inherit;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--input-focus);
      box-shadow: 0 0 0 3px var(--input-focus-glow);
    }
    textarea { min-height: 70px; resize: vertical; }
    button {
      width: auto;
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      border: 0;
      color: #fff;
      font-weight: 800;
      cursor: pointer;
      padding: 10px 13px;
      transition: transform 0.16s ease, filter 0.16s ease;
    }
    button:hover { transform: translateY(-1px); filter: brightness(1.04); }
    button.secondary {
      background: var(--input-bg);
      border: 1px solid var(--input-line);
      color: #2f3f52;
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    button.danger-btn {
      background: linear-gradient(180deg, #e5484d, #c23138);
      color: #fff;
    }
    video {
      width: 100%;
      max-height: 410px;
      border-radius: 12px;
      border: 1px solid #d2dbe6;
      background: #0f1720;
    }
    .status-online { color: var(--good); }
    .status-warn { color: var(--warn); }
    .stage {
      display: grid;
      gap: 10px;
    }
    .duo {
      display: grid;
      grid-template-columns: 1fr 330px;
      gap: 10px;
      align-items: start;
    }
    .events {
      max-height: 240px;
      overflow: auto;
      background: #f8fafc;
      border: 1px solid #dde5ef;
      border-radius: 9px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .events div { padding: 3px 0; border-bottom: 1px dashed #d6dfe9; }
    .events div:last-child { border-bottom: 0; }
    .chat-feed {
      max-height: 200px;
      overflow: auto;
      background: #f8fafc;
      border: 1px solid #dde5ef;
      border-radius: 9px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .chat-feed div { padding: 6px 0; border-bottom: 1px dashed #d6dfe9; }
    .chat-feed div:last-child { border-bottom: 0; }
    .msg-line { display: grid; gap: 1px; }
    .msg-head { font-size: 11px; color: #6f7d8f; }
    .msg-body { font-size: 13px; color: #1d2a39; word-break: break-word; }
    .participants-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    }
    .participant-card {
      border: 1px solid var(--line-soft);
      background: var(--panel-2);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 3px;
    }
    .participant-name { font-weight: 700; font-size: 13px; }
    .participant-meta { font-size: 11px; color: var(--muted); }
    .reaction-bar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }
    .reaction-btn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 16px;
      line-height: 1;
      border: 1px solid var(--input-line);
      background: var(--input-bg);
      cursor: pointer;
    }
    .reaction-overlay {
      position: absolute;
      right: 14px;
      bottom: 20px;
      display: grid;
      gap: 6px;
      pointer-events: none;
      z-index: 4;
    }
    .reaction-pop {
      font-size: 24px;
      animation: floatUp 1.7s ease forwards;
      text-shadow: 0 4px 12px rgba(0,0,0,.25);
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(0.9); opacity: 0; }
      15% { transform: translateY(-4px) scale(1); opacity: 1; }
      100% { transform: translateY(-46px) scale(1.05); opacity: 0; }
    }
    .open-party-list {
      display: grid;
      gap: 8px;
    }
    .open-party-item {
      border: 1px solid var(--line-soft);
      background: var(--panel-2);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 4px;
    }
    .open-party-title { font-weight: 700; }
    .open-party-meta { font-size: 12px; color: var(--muted); }
    .hidden-media { display: none !important; }
    .admin-tools.hidden { display: none; }
    .admin-login.hidden { display: none; }
    .host-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr 1fr;
    }
    .host-grid .full { grid-column: 1 / -1; }
    .footer {
      margin-top: 12px;
      color: #718196;
      font-size: 13px;
      text-align: center;
    }
    a { color: #70d8ff; }
    .admin-delete {
      border: 1px solid #d8e1ec;
      background: #fbfcfe;
      border-radius: 10px;
      padding: 8px;
    }
    .admin-delete h3 { margin-bottom: 8px; }
    .count-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d4dee9;
      background: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #33475f;
    }
    .status-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .status-chip {
      font-size: 11px;
      border: 1px solid #d4dee9;
      background: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      color: #44586f;
      font-weight: 700;
    }
    .status-chip.ok {
      border-color: #8fd7b8;
      background: #edf9f3;
      color: #0e6b42;
    }
    .adv-wrap.hidden { display: none; }
    @media (max-width: 1080px) {
      .workspace { grid-template-columns: 1fr; }
      .duo { grid-template-columns: 1fr; }
      .row > * { min-width: 100px; }
      .host-grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .wrap { width: min(100%, calc(100% - 12px)); margin: 10px auto 18px; }
      .card { padding: 10px; }
      button { width: 100%; }
      .row > * { flex: 1 1 100%; min-width: 100%; }
      input, button, textarea { font-size: 16px; }
      .badge { font-size: 12px; }
      video { max-height: 230px; }
    }
  </style>
</head>
<body>
  <div class="bg-scene" aria-hidden="true">
    <div class="bg-graphic"></div>
    <div class="bg-grid"></div>
    <div class="bg-noise"></div>
    <div class="bg-orb a"></div>
    <div class="bg-orb b"></div>
    <div class="bg-orb c"></div>
  </div>
  <div class="wrap">
    <div class="top">
      <div class="hero">
        <h1>Frenzy Telewatch</h1>
        <p>Host or join synced watch rooms in one clean dashboard.</p>
        <div class="wizard">
          <span id="stepSession" class="wizard-step active">1. Session</span>
          <span id="stepRoom" class="wizard-step">2. Room</span>
          <span id="stepShare" class="wizard-step">3. Share</span>
        </div>
      </div>
      <div class="row">
        <span id="roomBadge" class="badge">Room: none</span>
        <span id="roleBadge" class="badge">Role: viewer</span>
        <span id="syncBadge" class="badge">Sync: idle</span>
        <select id="themeSelect" class="theme-select" aria-label="Theme"></select>
      </div>
    </div>

    <div class="workspace">
      <section class="card stack">
        <h2>Control Panel</h2>
        <div class="panel-tabs">
          <button class="tab-btn active" data-tab-btn="session">Session</button>
          <button class="tab-btn" data-tab-btn="host">Host Setup</button>
          <button class="tab-btn" data-tab-btn="chat">Messages</button>
          <button class="tab-btn" data-tab-btn="admin">Admin</button>
        </div>

        <div class="tab-pane active" data-tab-pane="session">
          <div class="block stack">
            <div>
              <label for="displayName">Display Name</label>
              <input id="displayName" placeholder="e.g. DFrenzy" />
            </div>
            <div>
              <label for="roomInput">Room Code</label>
              <input id="roomInput" placeholder="e.g. DADDYR" />
            </div>
            <div>
              <label for="inviteInput">Paste Invite Link (optional)</label>
              <input id="inviteInput" placeholder="https://frenzynets.com/telewatch/?room=CODE" />
            </div>
            <div class="row">
              <button id="createBtn">Create Room</button>
              <button id="joinBtn" class="secondary">Join Room</button>
            </div>
            <div class="row">
              <button id="quickHostBtn">Quick Host</button>
              <button id="recentJoinBtn" class="secondary">Join Recent</button>
            </div>
            <div>
              <label for="recentRoomsSelect">Recent Rooms</label>
              <select id="recentRoomsSelect"></select>
            </div>
            <div class="muted" id="joinHint">Share your room code in Discord voice chat. Everyone runs their own stream account.</div>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="host">
          <div class="block stack">
            <h3>Host Setup</h3>
            <div class="host-grid">
              <div class="full">
                <label for="titleInput">Title</label>
                <input id="titleInput" placeholder="Episode / movie title" />
              </div>
              <div class="full">
                <label for="mediaInput">Media URL (Optional Direct File)</label>
                <input id="mediaInput" placeholder="https://.../video.mp4" />
              </div>
              <button id="advancedToggleBtn" class="secondary full">Show Advanced</button>
              <div id="advancedWrap" class="adv-wrap hidden full host-grid">
                <div>
                  <label for="shareSurfaceSelect">Share Source</label>
                  <select id="shareSurfaceSelect">
                    <option value="auto">Auto (picker default)</option>
                    <option value="browser">Browser Tab</option>
                    <option value="window">Window/App</option>
                    <option value="monitor">Monitor/Screen</option>
                  </select>
                </div>
                <div>
                  <label for="shareAudioSelect">Share Audio</label>
                  <select id="shareAudioSelect">
                    <option value="auto">Auto</option>
                    <option value="tab">Prefer Tab Audio</option>
                    <option value="system">Prefer System Audio</option>
                    <option value="off">No Audio</option>
                  </select>
                </div>
              </div>
              <button id="setMediaBtn" class="secondary">Set Media</button>
              <button id="copyLinkBtn" class="secondary">Copy Invite</button>
              <button id="startShareBtn" class="secondary">Share Monitor / Tab</button>
              <button id="stopShareBtn" class="secondary" disabled>Stop Share</button>
              <button id="resetRoomBtn" class="secondary">Reset Room</button>
              <button id="deleteRoomBtn" class="secondary full">Delete Room</button>
            </div>
            <div class="block stack full">
              <h3>Voice Chat</h3>
              <div id="voiceStatus" class="muted">Voice: off</div>
              <div id="shareSourceInfo" class="muted">Selected share source: none</div>
              <div id="shareAudioInfo" class="muted">Selected share audio: none</div>
              <div class="row">
                <button id="joinVoiceBtn" class="secondary">Join Voice</button>
                <button id="leaveVoiceBtn" class="secondary" disabled>Leave Voice</button>
              </div>
              <div class="row">
                <select id="muteTargetSelect"></select>
                <button id="muteTargetBtn" class="secondary">Mute</button>
                <button id="unmuteTargetBtn" class="secondary">Unmute</button>
              </div>
            </div>
            <div class="block stack full">
              <h3>Request Queue (Host)</h3>
              <select id="requestQueueSelect"></select>
              <div class="row">
                <input id="requestResolveNote" placeholder="Optional note to requester" />
                <button id="approveRequestBtn" class="secondary">Approve</button>
                <button id="denyRequestBtn" class="secondary">Deny</button>
              </div>
            </div>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="chat">
          <div class="block stack">
            <h3>Room Messages</h3>
            <textarea id="chatInput" placeholder="Send timestamp notes, e.g. pause at 12:34"></textarea>
            <button id="chatBtn" class="secondary">Send Message</button>
            <h3>Make Request</h3>
            <div class="row">
              <select id="requestTypeSelect">
                <option value="general">General Request</option>
                <option value="media">Media Request</option>
                <option value="skip_intro">Skip Intro Vote</option>
                <option value="next_episode">Next Episode Vote</option>
                <option value="cohost">Co-host Request</option>
              </select>
              <button id="sendRequestBtn" class="secondary">Send Request</button>
            </div>
            <input id="requestTextInput" placeholder="Request text, e.g. play episode 2 or skip intro" />
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="admin">
          <div class="block stack admin-login" id="adminLoginPanel">
            <h3>Admin Sign In</h3>
            <div class="muted">Sign in first to unlock admin actions.</div>
            <div>
              <label for="adminUserInput">Admin Username</label>
              <input id="adminUserInput" type="email" placeholder="Trimbledustn@gmail.com" />
            </div>
            <div>
              <label for="adminPassInput">Admin Password</label>
              <input id="adminPassInput" type="password" placeholder="Admin password" />
            </div>
            <button id="adminLoginBtn" class="secondary">Sign In Admin</button>
          </div>

          <div class="block stack admin-tools hidden" id="adminToolsPanel">
            <h3>Admin Tools</h3>
            <div class="muted" id="adminWhoami">Admin: not signed in</div>
            <div>
              <label for="adminKeyInput">Admin Code</label>
              <input id="adminKeyInput" type="password" placeholder="Required for protected options" />
            </div>
            <div>
              <label for="newAdminUserInput">Add Admin Username</label>
              <input id="newAdminUserInput" type="email" placeholder="newadmin@email.com" />
            </div>
            <div>
              <label for="newAdminPassInput">Add Admin Password</label>
              <input id="newAdminPassInput" type="password" placeholder="At least 8 characters" />
            </div>
            <div class="row">
              <button id="addAdminBtn" class="secondary">Add / Update Admin</button>
              <button id="refreshAdminsBtn" class="secondary">Refresh Admins</button>
            </div>
            <div>
              <label for="adminListSelect">Admin Accounts</label>
              <select id="adminListSelect"></select>
            </div>
            <div class="row">
              <button id="removeAdminBtn" class="danger-btn">Remove Selected Admin</button>
              <button id="adminLogoutBtn" class="secondary">Sign Out</button>
            </div>
          </div>
        </div>
      </section>

      <section class="card stack">
        <div class="row">
          <h2 id="nowTitle">Now Playing</h2>
          <div class="status-strip">
            <span class="count-pill" id="connState">Not connected</span>
            <span class="status-chip" id="liveChip">Not Live</span>
            <span class="status-chip" id="shareChip">Not Sharing</span>
            <span class="status-chip" id="fullChip">Room Open</span>
          </div>
        </div>
        <div class="block stack">
          <h3>Open Parties</h3>
          <div class="muted">Showing only active parties.</div>
          <div id="openPartiesList" class="open-party-list"></div>
        </div>
        <div class="stage">
          <div style="position:relative">
            <video id="player" controls playsinline></video>
            <div id="reactionOverlay" class="reaction-overlay"></div>
          </div>
          <video id="screenView" controls autoplay playsinline muted></video>
          <div class="reaction-bar">
            <button class="reaction-btn" data-react="üî•">üî•</button>
            <button class="reaction-btn" data-react="üòÇ">üòÇ</button>
            <button class="reaction-btn" data-react="üëè">üëè</button>
            <button class="reaction-btn" data-react="‚ù§Ô∏è">‚ù§Ô∏è</button>
            <button class="reaction-btn" data-react="üòÆ">üòÆ</button>
          </div>
          <div class="row">
            <button id="playBtn" class="secondary">Play</button>
            <button id="pauseBtn" class="secondary">Pause</button>
            <button id="resyncBtn" class="secondary">Force Re-sync</button>
          </div>
        </div>

        <div class="duo">
          <div class="block stack">
            <h3>Participants</h3>
            <div id="participantsGrid" class="participants-grid"></div>
            <h3>Room Messages</h3>
            <div class="muted">Live room chat appears here. Newest messages show first.</div>
            <div id="chatFeed" class="chat-feed"></div>
            <h3>Events</h3>
            <div class="muted">Playback and system events for this room.</div>
            <div id="events" class="events"></div>
          </div>
          <div class="block admin-delete">
            <h3>Admin Console</h3>
            <div class="muted">Open the dedicated admin dashboard for room deletes and account management.</div>
            <div id="adminRoomsBlock" class="hidden" style="margin-top:8px">
              <label for="adminRoomsSelect">Admin Room Codes</label>
              <select id="adminRoomsSelect"></select>
              <div class="row" style="margin-top:8px">
                <button id="copyAdminRoomBtn" class="secondary">Copy Code</button>
              </div>
            </div>
            <div style="height:8px"></div>
            <a href="/telewatch/admin/" id="openAdminConsole">Open Admin Console</a>
          </div>
        </div>
      </section>
    </div>

    <div class="footer">
      This sync layer coordinates playback timing only. It does not rebroadcast protected streams.
      <a href="/">Back to FrenzyNets</a>
    </div>
  </div>

  <script>
    const API_PREFIXES = ['https://api.frenzynets.com/api/telewatch'];
    const POLL_MS = 1300;
    const RTC_CFG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const els = {
      displayName: document.getElementById('displayName'),
      roomInput: document.getElementById('roomInput'),
      inviteInput: document.getElementById('inviteInput'),
      quickHostBtn: document.getElementById('quickHostBtn'),
      recentJoinBtn: document.getElementById('recentJoinBtn'),
      recentRoomsSelect: document.getElementById('recentRoomsSelect'),
      requestQueueSelect: document.getElementById('requestQueueSelect'),
      requestResolveNote: document.getElementById('requestResolveNote'),
      approveRequestBtn: document.getElementById('approveRequestBtn'),
      denyRequestBtn: document.getElementById('denyRequestBtn'),
      adminKeyInput: document.getElementById('adminKeyInput'),
      adminUserInput: document.getElementById('adminUserInput'),
      adminPassInput: document.getElementById('adminPassInput'),
      adminLoginBtn: document.getElementById('adminLoginBtn'),
      adminWhoami: document.getElementById('adminWhoami'),
      adminLoginPanel: document.getElementById('adminLoginPanel'),
      adminToolsPanel: document.getElementById('adminToolsPanel'),
      newAdminUserInput: document.getElementById('newAdminUserInput'),
      newAdminPassInput: document.getElementById('newAdminPassInput'),
      addAdminBtn: document.getElementById('addAdminBtn'),
      refreshAdminsBtn: document.getElementById('refreshAdminsBtn'),
      removeAdminBtn: document.getElementById('removeAdminBtn'),
      adminLogoutBtn: document.getElementById('adminLogoutBtn'),
      adminListSelect: document.getElementById('adminListSelect'),
      titleInput: document.getElementById('titleInput'),
      mediaInput: document.getElementById('mediaInput'),
      advancedToggleBtn: document.getElementById('advancedToggleBtn'),
      advancedWrap: document.getElementById('advancedWrap'),
      joinVoiceBtn: document.getElementById('joinVoiceBtn'),
      leaveVoiceBtn: document.getElementById('leaveVoiceBtn'),
      voiceStatus: document.getElementById('voiceStatus'),
      shareSourceInfo: document.getElementById('shareSourceInfo'),
      shareAudioInfo: document.getElementById('shareAudioInfo'),
      muteTargetSelect: document.getElementById('muteTargetSelect'),
      muteTargetBtn: document.getElementById('muteTargetBtn'),
      unmuteTargetBtn: document.getElementById('unmuteTargetBtn'),
      shareSurfaceSelect: document.getElementById('shareSurfaceSelect'),
      shareAudioSelect: document.getElementById('shareAudioSelect'),
      createBtn: document.getElementById('createBtn'),
      joinBtn: document.getElementById('joinBtn'),
      setMediaBtn: document.getElementById('setMediaBtn'),
      copyLinkBtn: document.getElementById('copyLinkBtn'),
      startShareBtn: document.getElementById('startShareBtn'),
      stopShareBtn: document.getElementById('stopShareBtn'),
      resetRoomBtn: document.getElementById('resetRoomBtn'),
      deleteRoomBtn: document.getElementById('deleteRoomBtn'),
      chatInput: document.getElementById('chatInput'),
      requestTypeSelect: document.getElementById('requestTypeSelect'),
      requestTextInput: document.getElementById('requestTextInput'),
      sendRequestBtn: document.getElementById('sendRequestBtn'),
      chatBtn: document.getElementById('chatBtn'),
      playBtn: document.getElementById('playBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      resyncBtn: document.getElementById('resyncBtn'),
      roomBadge: document.getElementById('roomBadge'),
      roleBadge: document.getElementById('roleBadge'),
      syncBadge: document.getElementById('syncBadge'),
      themeSelect: document.getElementById('themeSelect'),
      connState: document.getElementById('connState'),
      liveChip: document.getElementById('liveChip'),
      shareChip: document.getElementById('shareChip'),
      fullChip: document.getElementById('fullChip'),
      openPartiesList: document.getElementById('openPartiesList'),
      adminRoomsBlock: document.getElementById('adminRoomsBlock'),
      adminRoomsSelect: document.getElementById('adminRoomsSelect'),
      copyAdminRoomBtn: document.getElementById('copyAdminRoomBtn'),
      nowTitle: document.getElementById('nowTitle'),
      reactionOverlay: document.getElementById('reactionOverlay'),
      reactionButtons: Array.from(document.querySelectorAll('.reaction-btn')),
      participantsGrid: document.getElementById('participantsGrid'),
      events: document.getElementById('events'),
      chatFeed: document.getElementById('chatFeed'),
      player: document.getElementById('player'),
      screenView: document.getElementById('screenView'),
      stepSession: document.getElementById('stepSession'),
      stepRoom: document.getElementById('stepRoom'),
      stepShare: document.getElementById('stepShare'),
      tabButtons: Array.from(document.querySelectorAll('[data-tab-btn]')),
      tabPanes: Array.from(document.querySelectorAll('[data-tab-pane]'))
    };

    const state = {
      roomCode: '',
      participantToken: '',
      participantId: '',
      participants: [],
      adminToken: '',
      adminUsername: '',
      isHost: false,
      sinceEventId: 0,
      pollTimer: null,
      suppressOutbound: false,
      lastSeekSentAt: 0,
      lastRoom: null,
      hostMuted: {},
      adminRooms: [],
      requests: [],
      roomThemeKey: 'clean',
      localThemeKey: 'clean'
    };
    const SESSION_KEY = 'telewatch_session';
    const ADMIN_SESSION_KEY = 'telewatch_admin_session';
    const RECENT_ROOMS_KEY = 'telewatch_recent_rooms';
    const THEME_KEY = 'telewatch_theme';

    const THEMES = {
      clean: {
        label: 'Clean Default',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/clean-default.svg')",
          '--bg-graphic-opacity': '0.58',
          '--bg-gradient': 'linear-gradient(180deg, #f8f9fc, #f3f6fa)',
          '--panel': '#ffffff',
          '--panel-2': '#fbfcfe',
          '--line': '#dbe2ea',
          '--line-soft': '#e9eef4',
          '--text': '#18212c',
          '--muted': '#6a7787',
          '--accent': '#ff5f1f',
          '--accent-strong': '#e04d11',
          '--pill-bg': '#f8fafc',
          '--pill-line': '#dbe2ea',
          '--pill-text': '#314155',
          '--input-bg': '#ffffff',
          '--input-line': '#d1dae5',
          '--input-focus': '#ff925f',
          '--input-focus-glow': 'rgba(255, 95, 31, 0.15)',
          '--tab-active-bg': '#fff3ec',
          '--tab-active-text': '#a43f12',
          '--tab-active-line': '#ff925f'
        }
      },
      anime_sakura: {
        label: 'Anime Sakura',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-sakura.svg')",
          '--bg-graphic-opacity': '0.74',
          '--bg-gradient': 'linear-gradient(160deg, #fff6fb, #ffe2f2 45%, #ffd7ea)',
          '--panel': '#fff7fb',
          '--panel-2': '#fff1f8',
          '--line': '#f3c5df',
          '--line-soft': '#f8d8e9',
          '--text': '#431f35',
          '--muted': '#8f5f77',
          '--accent': '#ff4f9a',
          '--accent-strong': '#d9317c',
          '--pill-bg': '#ffeef8',
          '--pill-line': '#f4bddc',
          '--pill-text': '#6e2f51',
          '--input-bg': '#fffafd',
          '--input-line': '#efbad8',
          '--input-focus': '#ff4f9a',
          '--input-focus-glow': 'rgba(255, 79, 154, 0.25)',
          '--tab-active-bg': '#ffe7f3',
          '--tab-active-text': '#8f2459',
          '--tab-active-line': '#ff4f9a'
        }
      },
      anime_night: {
        label: 'Anime Night',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-night.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'radial-gradient(circle at 15% 10%, #2f2153, #141028 45%, #0b0a16)',
          '--panel': '#1b1730',
          '--panel-2': '#231b3d',
          '--line': '#3d3562',
          '--line-soft': '#302a4f',
          '--text': '#f2edff',
          '--muted': '#b7abd9',
          '--accent': '#ff66c9',
          '--accent-strong': '#c74797',
          '--pill-bg': '#272044',
          '--pill-line': '#3f3565',
          '--pill-text': '#f4e8ff',
          '--input-bg': '#19152d',
          '--input-line': '#433864',
          '--input-focus': '#ff66c9',
          '--input-focus-glow': 'rgba(255, 102, 201, 0.3)',
          '--tab-active-bg': '#362a58',
          '--tab-active-text': '#ffd1f0',
          '--tab-active-line': '#ff66c9'
        }
      },
      cyberpunk: {
        label: 'Cyberpunk Neon',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/cyberpunk-neon.svg')",
          '--bg-graphic-opacity': '0.54',
          '--bg-gradient': 'linear-gradient(140deg, #07090f, #120a26 45%, #061a1e)',
          '--panel': '#121624',
          '--panel-2': '#161b2c',
          '--line': '#2f3d59',
          '--line-soft': '#253048',
          '--text': '#eaf4ff',
          '--muted': '#93a9bf',
          '--accent': '#08f7fe',
          '--accent-strong': '#09b5ba',
          '--pill-bg': '#101c2d',
          '--pill-line': '#204861',
          '--pill-text': '#abf9ff',
          '--input-bg': '#0f1523',
          '--input-line': '#2e4569',
          '--input-focus': '#08f7fe',
          '--input-focus-glow': 'rgba(8, 247, 254, 0.25)',
          '--tab-active-bg': '#13263a',
          '--tab-active-text': '#8efeff',
          '--tab-active-line': '#08f7fe'
        }
      },
      ocean: {
        label: 'Ocean Breeze',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/ocean-breeze.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(160deg, #e5f7ff, #d6f0ff 45%, #c0e8fa)',
          '--panel': '#f7fcff',
          '--panel-2': '#eef8fc',
          '--line': '#b9dcea',
          '--line-soft': '#cfe9f2',
          '--text': '#173444',
          '--muted': '#567789',
          '--accent': '#0098d8',
          '--accent-strong': '#0076ab',
          '--pill-bg': '#ebf8ff',
          '--pill-line': '#b2d9ea',
          '--pill-text': '#205068',
          '--input-bg': '#fbfdff',
          '--input-line': '#a9d0e0',
          '--input-focus': '#0098d8',
          '--input-focus-glow': 'rgba(0, 152, 216, 0.2)',
          '--tab-active-bg': '#deeff8',
          '--tab-active-text': '#005985',
          '--tab-active-line': '#0098d8'
        }
      },
      forest: {
        label: 'Forest Camp',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/forest-camp.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(145deg, #e7f3df, #d3e8c2 50%, #c2ddad)',
          '--panel': '#f4f9ef',
          '--panel-2': '#edf5e5',
          '--line': '#c6d9b0',
          '--line-soft': '#d7e6c6',
          '--text': '#2b4122',
          '--muted': '#627956',
          '--accent': '#4f8a2f',
          '--accent-strong': '#3b6d20',
          '--pill-bg': '#edf6e4',
          '--pill-line': '#c0d7a8',
          '--pill-text': '#365227',
          '--input-bg': '#f7fbf2',
          '--input-line': '#b8d09d',
          '--input-focus': '#4f8a2f',
          '--input-focus-glow': 'rgba(79, 138, 47, 0.2)',
          '--tab-active-bg': '#e2efd6',
          '--tab-active-text': '#2d4f1b',
          '--tab-active-line': '#4f8a2f'
        }
      },
      sunset: {
        label: 'Sunset Glow',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/sunset-glow.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(150deg, #fff1da, #ffd6bf 45%, #ffc0b9)',
          '--panel': '#fff8ef',
          '--panel-2': '#fff3e8',
          '--line': '#f2ccae',
          '--line-soft': '#f8dfcc',
          '--text': '#4a2e21',
          '--muted': '#8f6350',
          '--accent': '#ff6a3d',
          '--accent-strong': '#d94b20',
          '--pill-bg': '#fff0e3',
          '--pill-line': '#efc8aa',
          '--pill-text': '#6a3f2d',
          '--input-bg': '#fffaf4',
          '--input-line': '#ebc3a5',
          '--input-focus': '#ff6a3d',
          '--input-focus-glow': 'rgba(255, 106, 61, 0.2)',
          '--tab-active-bg': '#ffe5d6',
          '--tab-active-text': '#9a3a1f',
          '--tab-active-line': '#ff6a3d'
        }
      },
      nordic_dark: {
        label: 'Nordic Dark',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/nordic-dark.svg')",
          '--bg-graphic-opacity': '0.52',
          '--bg-gradient': 'linear-gradient(155deg, #111827, #0f172a 50%, #1e293b)',
          '--panel': '#172033',
          '--panel-2': '#1d2940',
          '--line': '#334158',
          '--line-soft': '#28364d',
          '--text': '#e7edf7',
          '--muted': '#98a7bd',
          '--accent': '#5aa9ff',
          '--accent-strong': '#3a85d8',
          '--pill-bg': '#1d2a40',
          '--pill-line': '#38506f',
          '--pill-text': '#deebff',
          '--input-bg': '#1a263a',
          '--input-line': '#3d5270',
          '--input-focus': '#5aa9ff',
          '--input-focus-glow': 'rgba(90, 169, 255, 0.2)',
          '--tab-active-bg': '#243855',
          '--tab-active-text': '#cde2ff',
          '--tab-active-line': '#5aa9ff'
        }
      },
      galaxy: {
        label: 'Galaxy Purple',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/galaxy-purple.svg')",
          '--bg-graphic-opacity': '0.54',
          '--bg-gradient': 'radial-gradient(circle at 20% 10%, #39285e, #1a1434 45%, #0e0a1f)',
          '--panel': '#1d1638',
          '--panel-2': '#261d46',
          '--line': '#443a6a',
          '--line-soft': '#342c56',
          '--text': '#f0e9ff',
          '--muted': '#b8a9dd',
          '--accent': '#b574ff',
          '--accent-strong': '#8a47d1',
          '--pill-bg': '#271f47',
          '--pill-line': '#4d4080',
          '--pill-text': '#f0ddff',
          '--input-bg': '#1d1738',
          '--input-line': '#4a3f7d',
          '--input-focus': '#b574ff',
          '--input-focus-glow': 'rgba(181, 116, 255, 0.25)',
          '--tab-active-bg': '#3a2d63',
          '--tab-active-text': '#efd6ff',
          '--tab-active-line': '#b574ff'
        }
      },
      retro_arcade: {
        label: 'Retro Arcade',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/retro-arcade.svg')",
          '--bg-graphic-opacity': '0.58',
          '--bg-gradient': 'linear-gradient(150deg, #121212, #1d1230 45%, #072a2a)',
          '--panel': '#1a1a22',
          '--panel-2': '#22222c',
          '--line': '#3b3d4d',
          '--line-soft': '#2d3140',
          '--text': '#f7f7f7',
          '--muted': '#b9bac8',
          '--accent': '#f4ff52',
          '--accent-strong': '#c4ca34',
          '--pill-bg': '#20212a',
          '--pill-line': '#464960',
          '--pill-text': '#f8f9b5',
          '--input-bg': '#181920',
          '--input-line': '#484b60',
          '--input-focus': '#f4ff52',
          '--input-focus-glow': 'rgba(244, 255, 82, 0.22)',
          '--tab-active-bg': '#2f3140',
          '--tab-active-text': '#f8f9b5',
          '--tab-active-line': '#f4ff52'
        }
      }
    };

    const rtc = {
      localScreenStream: null,
      localVoiceStream: null,
      peers: new Map(),
      pendingCandidates: new Map(),
      offeredTo: new Set(),
      audioEls: new Map(),
      voiceOfferedTo: new Set()
    };
    let openPartyTimer = null;

    function qp(name) {
      const u = new URL(window.location.href);
      return u.searchParams.get(name) || '';
    }

    function setStatus(ok, text) {
      els.connState.className = 'count-pill ' + (ok ? 'status-online' : 'status-warn');
      els.connState.textContent = text;
    }

    function setSyncLabel(text) {
      els.syncBadge.textContent = 'Sync: ' + text;
    }

    function applyTheme(themeKey, persistLocal) {
      const key = Object.prototype.hasOwnProperty.call(THEMES, themeKey) ? themeKey : 'clean';
      const cfg = THEMES[key];
      for (const [cssVar, val] of Object.entries(cfg.vars)) {
        document.documentElement.style.setProperty(cssVar, val);
      }
      if (els.themeSelect) els.themeSelect.value = key;
      if (persistLocal) {
        state.localThemeKey = key;
        try { localStorage.setItem(THEME_KEY, key); } catch (_) {}
      }
      return key;
    }

    function setThemeControlState() {
      if (!els.themeSelect) return;
      const inRoom = !!state.roomCode;
      if (inRoom && !state.isHost) {
        els.themeSelect.disabled = true;
        els.themeSelect.title = 'Host controls room theme';
      } else {
        els.themeSelect.disabled = false;
        els.themeSelect.title = inRoom ? 'Host room theme control' : 'Personal theme preference';
      }
    }

    async function setRoomTheme(themeKey) {
      const clean = Object.prototype.hasOwnProperty.call(THEMES, themeKey) ? themeKey : 'clean';
      if (!state.roomCode || !state.participantToken || !state.isHost) {
        applyTheme(clean, true);
        return;
      }
      await sendControl('set_theme', { themeKey: clean });
      state.roomThemeKey = clean;
      applyTheme(clean, false);
      setStatus(true, 'Room theme updated: ' + (THEMES[clean]?.label || clean));
    }

    function initThemeSelector() {
      if (!els.themeSelect) return;
      els.themeSelect.innerHTML = '';
      for (const [key, cfg] of Object.entries(THEMES)) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = cfg.label;
        els.themeSelect.appendChild(opt);
      }
      const saved = (() => {
        try { return localStorage.getItem(THEME_KEY) || ''; } catch (_) { return ''; }
      })();
      state.localThemeKey = Object.prototype.hasOwnProperty.call(THEMES, saved) ? saved : 'clean';
      applyTheme(state.localThemeKey, true);
      setThemeControlState();
      els.themeSelect.addEventListener('change', async () => {
        const wanted = String(els.themeSelect.value || 'clean');
        if (state.roomCode) {
          if (!state.isHost) {
            applyTheme(state.roomThemeKey || 'clean', false);
            setStatus(false, 'Only host can change room theme.');
            return;
          }
          try {
            await setRoomTheme(wanted);
          } catch (err) {
            applyTheme(state.roomThemeKey || 'clean', false);
            setStatus(false, String(err && err.message ? err.message : err));
          }
          return;
        }
        applyTheme(wanted, true);
      });
    }

    function setWizardStep(step) {
      const idx = Math.max(1, Math.min(3, Number(step) || 1));
      const steps = [els.stepSession, els.stepRoom, els.stepShare];
      for (let i = 0; i < steps.length; i += 1) {
        if (!steps[i]) continue;
        steps[i].classList.toggle('active', i < idx);
      }
    }

    function parseInviteRoom(raw) {
      const txt = String(raw || '').trim();
      if (!txt) return '';
      const direct = normalizeRoomCode(txt);
      if (direct && direct.length >= 3 && !txt.includes('http')) return direct;
      try {
        const u = new URL(txt);
        return normalizeRoomCode(u.searchParams.get('room') || '');
      } catch (_) {
        return '';
      }
    }

    function readRecentRooms() {
      try {
        const raw = localStorage.getItem(RECENT_ROOMS_KEY) || '[]';
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        return arr.map((x) => normalizeRoomCode(x)).filter(Boolean).slice(0, 10);
      } catch (_) {
        return [];
      }
    }

    function renderRecentRooms() {
      if (!els.recentRoomsSelect) return;
      const rooms = readRecentRooms();
      els.recentRoomsSelect.innerHTML = '';
      const first = document.createElement('option');
      first.value = '';
      first.textContent = rooms.length ? 'Select a recent room' : 'No recent rooms yet';
      els.recentRoomsSelect.appendChild(first);
      for (const code of rooms) {
        const opt = document.createElement('option');
        opt.value = code;
        opt.textContent = code;
        els.recentRoomsSelect.appendChild(opt);
      }
    }

    function saveRecentRoom(code) {
      const cleaned = normalizeRoomCode(code);
      if (!cleaned) return;
      const rooms = readRecentRooms().filter((x) => x !== cleaned);
      rooms.unshift(cleaned);
      try { localStorage.setItem(RECENT_ROOMS_KEY, JSON.stringify(rooms.slice(0, 10))); } catch (_) {}
      renderRecentRooms();
    }

    function updateStatusChips(activeCount) {
      if (els.liveChip) {
        const live = Number(activeCount || 0) > 0;
        els.liveChip.textContent = live ? 'Live' : 'Not Live';
        els.liveChip.classList.toggle('ok', live);
      }
      if (els.shareChip) {
        const sharing = !!rtc.localScreenStream;
        els.shareChip.textContent = sharing ? 'Sharing On' : 'Not Sharing';
        els.shareChip.classList.toggle('ok', sharing);
      }
      if (els.fullChip) {
        const full = Number(activeCount || 0) >= 25;
        els.fullChip.textContent = full ? 'Room Full' : 'Room Open';
        els.fullChip.classList.toggle('ok', !full);
      }
    }

    function renderParticipants() {
      if (!els.participantsGrid) return;
      const rows = Array.isArray(state.participants) ? state.participants : [];
      els.participantsGrid.innerHTML = '';
      if (!rows.length) {
        const d = document.createElement('div');
        d.className = 'muted';
        d.textContent = 'No participants yet';
        els.participantsGrid.appendChild(d);
        return;
      }
      for (const p of rows) {
        const card = document.createElement('div');
        card.className = 'participant-card';
        const mutedByHost = !!state.hostMuted[String(p.participantId || '').toLowerCase()];
        card.innerHTML = `
          <div class="participant-name">${String(p.displayName || 'Guest')}</div>
          <div class="participant-meta">${p.isHost ? 'Host' : 'Viewer'}${p.isSelf ? ' ¬∑ You' : ''}</div>
          <div class="participant-meta">${mutedByHost ? 'Muted by host' : 'Unmuted'}</div>
        `;
        els.participantsGrid.appendChild(card);
      }
    }

    function updateMediaVisibility() {
      const inRoom = !!state.roomCode;
      const hasPlayerMedia = !!(els.player && els.player.src);
      const hasScreenMedia = !!(els.screenView && els.screenView.srcObject);
      if (els.player) {
        els.player.classList.toggle('hidden-media', !inRoom || (!hasPlayerMedia && !state.isHost));
      }
      if (els.screenView) {
        els.screenView.classList.toggle('hidden-media', !inRoom || !hasScreenMedia);
      }
    }

    function renderOpenParties(rooms) {
      if (!els.openPartiesList) return;
      const active = (Array.isArray(rooms) ? rooms : []).filter((r) => Number(r.activeCount || 0) > 0);
      els.openPartiesList.innerHTML = '';
      if (!active.length) {
        const d = document.createElement('div');
        d.className = 'muted';
        d.textContent = 'No active parties right now.';
        els.openPartiesList.appendChild(d);
        return;
      }
      for (const r of active.slice(0, 20)) {
        const card = document.createElement('div');
        card.className = 'open-party-item';
        card.innerHTML = `
          <div class="open-party-title">${String(r.title || r.roomCode || 'Watch Party')}</div>
          <div class="open-party-meta">Code: ${String(r.roomCode || '')} ¬∑ Viewers: ${Number(r.activeCount || 0)}</div>
        `;
        const btn = document.createElement('button');
        btn.className = 'secondary';
        btn.textContent = 'Join Party';
        btn.addEventListener('click', async () => {
          els.roomInput.value = normalizeRoomCode(r.roomCode || '');
          try { await joinRoom(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
        });
        card.appendChild(btn);
        els.openPartiesList.appendChild(card);
      }
    }

    async function refreshOpenParties() {
      try {
        const data = await apiRequest('GET', '/api/public-rooms');
        renderOpenParties(Array.isArray(data.rooms) ? data.rooms : []);
      } catch (_) {
        if (els.openPartiesList && !els.openPartiesList.children.length) {
          const d = document.createElement('div');
          d.className = 'muted';
          d.textContent = 'Unable to load open parties right now.';
          els.openPartiesList.appendChild(d);
        }
      }
    }

    function addReaction(emoji, actor) {
      if (!els.reactionOverlay) return;
      const d = document.createElement('div');
      d.className = 'reaction-pop';
      d.textContent = String(emoji || 'üëè');
      d.title = actor || '';
      els.reactionOverlay.appendChild(d);
      setTimeout(() => {
        try { d.remove(); } catch (_) {}
      }, 1800);
    }

    async function sendReaction(emoji) {
      const clean = String(emoji || '').trim().slice(0, 4);
      if (!clean) return;
      await sendControl('reaction', { emoji: clean });
      addReaction(clean, 'you');
    }

    function upsertRequestFromEvent(ev) {
      if (!ev || ev.type !== 'request_item') return;
      const req = {
        id: Number(ev.id) || 0,
        actor: String(ev.actor || 'user'),
        type: String(ev.payload?.requestType || 'general'),
        text: String(ev.payload?.requestText || ''),
        status: 'pending',
        note: '',
      };
      if (!req.id) return;
      state.requests = state.requests.filter((r) => r.id !== req.id);
      state.requests.unshift(req);
    }

    function resolveRequestFromEvent(ev) {
      if (!ev || ev.type !== 'resolve_request') return;
      const id = Number(ev.payload?.requestId || 0);
      if (!id) return;
      const status = String(ev.payload?.status || 'denied');
      const note = String(ev.payload?.note || '');
      state.requests = state.requests.map((r) => {
        if (r.id !== id) return r;
        return Object.assign({}, r, { status, note });
      });
    }

    function renderRequestQueue() {
      if (!els.requestQueueSelect) return;
      const pending = (state.requests || []).filter((r) => r.status === 'pending');
      els.requestQueueSelect.innerHTML = '';
      if (!pending.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No pending requests';
        els.requestQueueSelect.appendChild(o);
        return;
      }
      for (const r of pending) {
        const o = document.createElement('option');
        o.value = String(r.id);
        o.textContent = `#${r.id} ${r.actor} ¬∑ ${r.type} ¬∑ ${r.text}`;
        els.requestQueueSelect.appendChild(o);
      }
    }

    async function sendRequestItem() {
      const type = String((els.requestTypeSelect && els.requestTypeSelect.value) || 'general');
      const text = String((els.requestTextInput && els.requestTextInput.value) || '').trim();
      if (!text) {
        setStatus(false, 'Request text required.');
        return;
      }
      await sendControl('request_item', { requestType: type, requestText: text });
      els.requestTextInput.value = '';
      setStatus(true, 'Request sent.');
    }

    async function resolveSelectedRequest(status) {
      if (!state.isHost) return;
      const requestId = Number((els.requestQueueSelect && els.requestQueueSelect.value) || 0);
      const note = String((els.requestResolveNote && els.requestResolveNote.value) || '').trim();
      if (!requestId) {
        setStatus(false, 'Select a request first.');
        return;
      }
      await sendControl('resolve_request', { requestId, status, note });
      if (els.requestResolveNote) els.requestResolveNote.value = '';
      setStatus(true, `Request #${requestId} ${status}.`);
    }

    function voiceOn() {
      return !!(rtc.localVoiceStream && rtc.localVoiceStream.getAudioTracks().length);
    }

    function updateVoiceUi() {
      if (els.voiceStatus) {
        const muted = !!state.hostMuted[state.participantId || ''];
        els.voiceStatus.textContent = voiceOn()
          ? (muted ? 'Voice: on (muted by host)' : 'Voice: on')
          : 'Voice: off';
      }
      if (els.joinVoiceBtn) els.joinVoiceBtn.disabled = voiceOn();
      if (els.leaveVoiceBtn) els.leaveVoiceBtn.disabled = !voiceOn();
      const hostCanModerate = !!state.isHost;
      if (els.muteTargetBtn) els.muteTargetBtn.disabled = !hostCanModerate;
      if (els.unmuteTargetBtn) els.unmuteTargetBtn.disabled = !hostCanModerate;
    }

    function refreshMuteTargets() {
      if (!els.muteTargetSelect) return;
      els.muteTargetSelect.innerHTML = '';
      const mine = String(state.participantId || '');
      const targets = (state.participants || []).filter((p) => p && !p.isSelf).map((p) => ({
        id: String(p.participantId || ''),
        name: String(p.displayName || p.participantId || 'user')
      })).filter((p) => p.id && p.id !== mine);
      if (!targets.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No participants';
        els.muteTargetSelect.appendChild(o);
        return;
      }
      for (const t of targets) {
        const o = document.createElement('option');
        o.value = t.id;
        o.textContent = t.name;
        els.muteTargetSelect.appendChild(o);
      }
    }

    function shouldInitiateVoiceOffer(targetParticipantId) {
      const me = String(state.participantId || '');
      const peer = String(targetParticipantId || '');
      if (!me || !peer) return false;
      return me < peer;
    }

    function addLocalVoiceTrackToPeer(pc) {
      if (!rtc.localVoiceStream) return;
      const track = rtc.localVoiceStream.getAudioTracks()[0];
      if (!track) return;
      const existing = pc.getSenders().find((s) => s.track && s.track.kind === 'audio');
      if (existing) {
        existing.replaceTrack(track).catch(() => {});
      } else {
        pc.addTrack(track, rtc.localVoiceStream);
      }
    }

    async function createVoiceOfferFor(participantId) {
      if (!voiceOn() || !participantId) return;
      if (!shouldInitiateVoiceOffer(participantId)) return;
      const pc = ensurePeer(participantId);
      addLocalVoiceTrackToPeer(pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.voiceOfferedTo.add(participantId);
    }

    async function syncVoiceOffers() {
      if (!voiceOn()) return;
      const peers = (state.participants || [])
        .filter((p) => p && !p.isSelf)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(peers);
      for (const pid of Array.from(rtc.voiceOfferedTo)) {
        if (!keep.has(pid)) rtc.voiceOfferedTo.delete(pid);
      }
      for (const pid of peers) {
        if (!rtc.voiceOfferedTo.has(pid)) {
          try { await createVoiceOfferFor(pid); } catch (_) {}
        }
      }
    }

    async function startVoiceChat() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Voice chat unavailable in this browser.');
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      rtc.localVoiceStream = stream;
      const mutedByHost = !!state.hostMuted[state.participantId || ''];
      for (const t of stream.getAudioTracks()) t.enabled = !mutedByHost;
      updateVoiceUi();
      await syncVoiceOffers();
      addEventLine('Voice joined');
    }

    async function stopVoiceChat() {
      if (rtc.localVoiceStream) {
        for (const t of rtc.localVoiceStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localVoiceStream = null;
      for (const row of rtc.peers.values()) {
        const pc = row.pc;
        for (const sender of pc.getSenders()) {
          if (sender.track && sender.track.kind === 'audio') {
            sender.replaceTrack(null).catch(() => {});
          }
        }
      }
      rtc.voiceOfferedTo.clear();
      updateVoiceUi();
      addEventLine('Voice left');
    }

    async function hostSetMuteTarget(muted) {
      if (!state.isHost) return;
      const toParticipantId = String((els.muteTargetSelect && els.muteTargetSelect.value) || '').trim().toLowerCase();
      if (!toParticipantId) return;
      await sendControl('mute_user', { toParticipantId, muted: !!muted });
      setStatus(true, (muted ? 'Muted ' : 'Unmuted ') + toParticipantId);
    }

    async function refreshAdminRooms() {
      if (!(state.adminToken && state.adminUsername)) return;
      const data = await apiRequest('POST', '/api/watch/admin/rooms', { adminToken: state.adminToken });
      const rooms = Array.isArray(data.rooms) ? data.rooms : [];
      state.adminRooms = rooms;
      if (!els.adminRoomsSelect || !els.adminRoomsBlock) return;
      els.adminRoomsBlock.classList.remove('hidden');
      els.adminRoomsSelect.innerHTML = '';
      for (const r of rooms) {
        const o = document.createElement('option');
        o.value = r.roomCode;
        o.textContent = `${r.roomCode} (${r.activeCount}) ${r.title ? '- ' + r.title : ''}`;
        els.adminRoomsSelect.appendChild(o);
      }
      if (!rooms.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No rooms found';
        els.adminRoomsSelect.appendChild(o);
      }
    }

    function screenShareHelpMessage(err) {
      const name = String(err && err.name ? err.name : '');
      const msg = String(err && err.message ? err.message : '');
      if (!window.isSecureContext) {
        return 'Screen share requires HTTPS. Open this page from https://frenzynets.com/telewatch/.';
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        return 'This browser does not support screen capture. Use latest Chrome/Edge/Firefox.';
      }
      if (name === 'NotAllowedError' || name === 'PermissionDeniedError') {
        return 'Screen-share permission denied. Click Share Monitor / Tab again and allow monitor/tab/window access.';
      }
      if (name === 'NotFoundError') {
        return 'No display source found. Connect a monitor or choose a visible window/tab.';
      }
      if (name === 'NotReadableError' || msg.toLowerCase().includes('system')) {
        return 'OS blocked capture. Check system privacy settings and allow screen recording for your browser.';
      }
      return msg || 'Unable to start screen share. Reopen the page and try again.';
    }

    function normalizeRoomCode(raw) {
      return String(raw || '').trim().toUpperCase().replace(/[^A-Z0-9_-]/g, '').slice(0, 24);
    }

    function addEventLine(text) {
      const d = document.createElement('div');
      d.textContent = text;
      els.events.prepend(d);
      while (els.events.children.length > 120) {
        els.events.removeChild(els.events.lastChild);
      }
    }

    function addChatLine(sender, message) {
      const d = document.createElement('div');
      d.className = 'msg-line';
      const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      d.innerHTML = `<div class="msg-head">${sender} ¬∑ ${ts}</div><div class="msg-body"></div>`;
      d.querySelector('.msg-body').textContent = String(message || '');
      els.chatFeed.prepend(d);
      while (els.chatFeed.children.length > 200) {
        els.chatFeed.removeChild(els.chatFeed.lastChild);
      }
    }

    function switchTab(name) {
      const target = String(name || 'session').toLowerCase();
      for (const btn of els.tabButtons) {
        btn.classList.toggle('active', btn.getAttribute('data-tab-btn') === target);
      }
      for (const pane of els.tabPanes) {
        pane.classList.toggle('active', pane.getAttribute('data-tab-pane') === target);
      }
    }

    async function apiRequest(method, path, body, queryParams) {
      let lastError = null;
      for (const prefix of API_PREFIXES) {
        try {
          const url = new URL(prefix + path, window.location.origin);
          if (queryParams) {
            Object.entries(queryParams).forEach(([k, v]) => {
              if (v !== undefined && v !== null && v !== '') {
                url.searchParams.set(k, String(v));
              }
            });
          }
          const res = await fetch(url.toString(), {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: body ? JSON.stringify(body) : undefined,
            cache: 'no-store'
          });
          const text = await res.text();
          let data = {};
          try { data = text ? JSON.parse(text) : {}; } catch (_) {}
          if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
          return data;
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('request_failed');
    }

    async function sendControl(action, extra) {
      if (!state.roomCode || !state.participantToken) return;
      const body = Object.assign({
        roomCode: state.roomCode,
        participantToken: state.participantToken,
        action
      }, extra || {});
      await apiRequest('POST', '/api/watch/control', body);
    }

    function saveSession() {
      try {
        if (!state.roomCode || !state.participantToken) return;
        localStorage.setItem(
          SESSION_KEY,
          JSON.stringify({
            roomCode: state.roomCode,
            participantToken: state.participantToken,
            participantId: state.participantId || '',
            isHost: !!state.isHost
          })
        );
      } catch (_) {}
    }

    function clearSession() {
      try { localStorage.removeItem(SESSION_KEY); } catch (_) {}
    }

    function upsertIceQueue(participantId, candidate) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      list.push(candidate);
      rtc.pendingCandidates.set(participantId, list);
    }

    async function flushIceQueue(participantId, pc) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      rtc.pendingCandidates.delete(participantId);
      for (const c of list) {
        try { await pc.addIceCandidate(c); } catch (_) {}
      }
    }

    function closePeer(participantId) {
      const row = rtc.peers.get(participantId);
      if (!row) return;
      try { row.pc.close(); } catch (_) {}
      rtc.peers.delete(participantId);
      rtc.pendingCandidates.delete(participantId);
      rtc.offeredTo.delete(participantId);
      rtc.voiceOfferedTo.delete(participantId);
      const audioEl = rtc.audioEls.get(participantId);
      if (audioEl) {
        try { audioEl.srcObject = null; audioEl.remove(); } catch (_) {}
        rtc.audioEls.delete(participantId);
      }
    }

    function ensurePeer(participantId) {
      const existing = rtc.peers.get(participantId);
      if (existing) return existing.pc;
      const pc = new RTCPeerConnection(RTC_CFG);
      pc.onicecandidate = (ev) => {
        if (!ev.candidate) return;
        sendControl('signal', {
          toParticipantId: participantId,
          signalType: 'ice',
          candidate: String(ev.candidate.candidate || '')
        }).catch(() => {});
      };
      pc.onconnectionstatechange = () => {
        if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) closePeer(participantId);
      };
      pc.ontrack = (ev) => {
        const track = ev.track;
        if (track && track.kind === 'audio') {
          let audioEl = rtc.audioEls.get(participantId);
          if (!audioEl) {
            audioEl = document.createElement('audio');
            audioEl.autoplay = true;
            audioEl.playsInline = true;
            audioEl.style.display = 'none';
            document.body.appendChild(audioEl);
            rtc.audioEls.set(participantId, audioEl);
          }
          if (ev.streams && ev.streams[0]) {
            audioEl.srcObject = ev.streams[0];
            audioEl.play().catch(() => {});
          }
          return;
        }
        if (!state.isHost && ev.streams && ev.streams[0]) {
          els.screenView.srcObject = ev.streams[0];
          els.screenView.muted = false;
          els.screenView.play().catch(() => {});
          setSyncLabel('screen live');
        }
      };
      rtc.peers.set(participantId, { pc });
      return pc;
    }

    function getHostParticipantId() {
      const row = (state.participants || []).find((p) => p && p.isHost);
      return row ? String(row.participantId || '') : '';
    }

    function syncHostTrackSenders(participantId, pc) {
      if (!state.isHost || !rtc.localScreenStream) return;
      const tracks = rtc.localScreenStream.getTracks().filter((t) => t.kind === 'video' || t.kind === 'audio');
      for (const track of tracks) {
        const existing = pc.getSenders().find((s) => s.track && s.track.kind === track.kind);
        if (existing) existing.replaceTrack(track).catch(() => {});
        else pc.addTrack(track, rtc.localScreenStream);
      }
    }

    async function createOfferFor(participantId) {
      if (!state.isHost || !rtc.localScreenStream || !participantId) return;
      const pc = ensurePeer(participantId);
      syncHostTrackSenders(participantId, pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.offeredTo.add(participantId);
    }

    async function broadcastOffersToViewers() {
      if (!state.isHost || !rtc.localScreenStream) return;
      const viewerIds = (state.participants || [])
        .filter((p) => p && !p.isSelf && !p.isHost)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(viewerIds);
      for (const pid of Array.from(rtc.peers.keys())) {
        if (!keep.has(pid)) closePeer(pid);
      }
      for (const pid of viewerIds) {
        if (!rtc.offeredTo.has(pid)) {
          try { await createOfferFor(pid); } catch (_) {}
        }
      }
    }

    async function startScreenShare() {
      if (!state.isHost) return;
      if (!window.isSecureContext) {
        throw new Error('Open Telewatch over HTTPS to share your screen.');
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        throw new Error('Browser screen-share API unavailable. Use latest Chrome/Edge/Firefox.');
      }
      const surface = String((els.shareSurfaceSelect && els.shareSurfaceSelect.value) || 'auto');
      const audioMode = String((els.shareAudioSelect && els.shareAudioSelect.value) || 'auto');
      const videoCfg = {};
      if (surface === 'browser') {
        videoCfg.displaySurface = 'browser';
        videoCfg.selfBrowserSurface = 'exclude';
      } else if (surface === 'window') {
        videoCfg.displaySurface = 'window';
      } else if (surface === 'monitor') {
        videoCfg.displaySurface = 'monitor';
      }
      const constraints = {
        video: Object.keys(videoCfg).length ? videoCfg : true,
        audio: audioMode !== 'off'
      };
      if (audioMode === 'tab') {
        constraints.preferCurrentTab = true;
      } else if (audioMode === 'system') {
        constraints.systemAudio = 'include';
      }
      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
      rtc.localScreenStream = stream;
      const vidTrack = stream.getVideoTracks()[0];
      const audTrack = stream.getAudioTracks()[0];
      if (els.shareSourceInfo) {
        els.shareSourceInfo.textContent = 'Selected share source: ' + (vidTrack && vidTrack.label ? vidTrack.label : 'unknown');
      }
      if (els.shareAudioInfo) {
        els.shareAudioInfo.textContent = 'Selected share audio: ' + (audTrack && audTrack.label ? audTrack.label : 'none');
      }
      els.screenView.srcObject = stream;
      els.screenView.muted = true;
      try { await els.screenView.play(); } catch (_) {}
      els.startShareBtn.disabled = true;
      els.stopShareBtn.disabled = false;
      setWizardStep(3);
      setSyncLabel('sharing monitor/tab');
      updateStatusChips((state.participants || []).length);
      const track = stream.getVideoTracks()[0];
      if (track) {
        track.addEventListener('ended', () => {
          stopScreenShare().catch(() => {});
        });
      }
      const hasAudio = stream.getAudioTracks().length > 0;
      if (hasAudio) {
        addEventLine('Screen share audio detected and will be sent to viewers.');
      } else {
        addEventLine('No share audio detected. In picker enable tab/system audio.');
      }
      await broadcastOffersToViewers();
      updateMediaVisibility();
    }

    async function stopScreenShare() {
      if (rtc.localScreenStream) {
        for (const t of rtc.localScreenStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localScreenStream = null;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      if (state.isHost) {
        els.screenView.srcObject = null;
      }
      for (const pid of Array.from(rtc.peers.keys())) closePeer(pid);
      setSyncLabel('share stopped');
      updateStatusChips((state.participants || []).length);
      if (els.shareSourceInfo) els.shareSourceInfo.textContent = 'Selected share source: none';
      if (els.shareAudioInfo) els.shareAudioInfo.textContent = 'Selected share audio: none';
      updateMediaVisibility();
    }

    async function processSignal(payload) {
      const toId = String(payload.toParticipantId || '');
      if (!toId || toId !== state.participantId) return;
      const fromId = String(payload.fromParticipantId || '');
      const kind = String(payload.signalType || '').toLowerCase();
      if (!fromId || !kind) return;
      const pc = ensurePeer(fromId);
      if (state.isHost) syncHostTrackSenders(fromId, pc);
      if (kind === 'offer') {
        await pc.setRemoteDescription({ type: 'offer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
        if (voiceOn()) addLocalVoiceTrackToPeer(pc);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await sendControl('signal', {
          toParticipantId: fromId,
          signalType: 'answer',
          sdp: String(answer.sdp || '')
        });
      } else if (kind === 'answer') {
        await pc.setRemoteDescription({ type: 'answer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
      } else if (kind === 'ice') {
        const candidate = String(payload.candidate || '');
        if (!candidate) return;
        const iceObj = { candidate, sdpMid: '0', sdpMLineIndex: 0 };
        if (pc.remoteDescription) {
          try { await pc.addIceCandidate(iceObj); } catch (_) {}
        } else {
          upsertIceQueue(fromId, iceObj);
        }
      }
    }

    async function createRoom() {
      const inviteCode = parseInviteRoom(els.inviteInput && els.inviteInput.value);
      const chosenCode = normalizeRoomCode(inviteCode || els.roomInput.value);
      const selectedTheme = Object.prototype.hasOwnProperty.call(THEMES, String((els.themeSelect && els.themeSelect.value) || ''))
        ? String(els.themeSelect.value)
        : (state.localThemeKey || 'clean');
      const payload = {
        roomCode: chosenCode || undefined,
        displayName: els.displayName.value.trim() || 'Host',
        title: els.titleInput.value.trim(),
        mediaUrl: els.mediaInput.value.trim(),
        themeKey: selectedTheme
      };
      const data = await apiRequest('POST', '/api/watch/create', payload);
      state.roomCode = data.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = true;
      state.sinceEventId = 0;
      state.roomThemeKey = selectedTheme || 'clean';
      applyTheme(state.roomThemeKey, false);
      els.roomInput.value = state.roomCode;
      saveRecentRoom(state.roomCode);
      onSessionStart();
      addEventLine('Room created: ' + state.roomCode);
    }

    async function joinRoom() {
      const inviteCode = parseInviteRoom(els.inviteInput && els.inviteInput.value);
      const payload = {
        roomCode: normalizeRoomCode(inviteCode || els.roomInput.value),
        displayName: els.displayName.value.trim() || ''
      };
      const data = await apiRequest('POST', '/api/watch/join', payload);
      state.roomCode = payload.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = !!data.isHost;
      state.sinceEventId = 0;
      onSessionStart();
      saveRecentRoom(state.roomCode);
      applyRoomState(data.room || null, true);
      addEventLine('Joined room: ' + state.roomCode);
    }

    async function quickHost() {
      if (!els.titleInput.value.trim()) {
        const titleGuess = document.title.replace(/\s*\|\s*Frenzy.*$/i, '').trim();
        els.titleInput.value = titleGuess || 'Watch Party';
      }
      if (!state.roomCode || !state.participantToken) {
        await createRoom();
      }
      await copyInviteLink();
      switchTab('host');
      setStatus(true, 'Quick Host ready. Invite copied.');
    }

    async function deleteRoomByCode(codeOverride) {
      const code = normalizeRoomCode(codeOverride || els.adminDeleteCodeInput.value || els.roomInput.value || state.roomCode);
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!code) {
        setStatus(false, 'Enter a room code first.');
        return;
      }
      const ok = window.confirm(`Delete room code ${code}?`);
      if (!ok) return;
      const data = await apiRequest('POST', '/api/watch/delete', {
        roomCode: code,
        adminCode,
        adminToken: state.adminToken,
      });
      setStatus(false, `Room ${data.roomCode || code} deleted.`);
      addEventLine(`Room ${data.roomCode || code} deleted.`);
    }

    function renderAdminIdentity() {
      const signedIn = !!(state.adminToken && state.adminUsername);
      els.adminWhoami.textContent = signedIn ? ('Admin: ' + state.adminUsername) : 'Admin: not signed in';
      els.adminLoginPanel.classList.toggle('hidden', signedIn);
      els.adminToolsPanel.classList.toggle('hidden', !signedIn);
      if (els.adminRoomsBlock) els.adminRoomsBlock.classList.toggle('hidden', !signedIn);
    }

    function saveAdminSession() {
      try {
        if (!state.adminToken || !state.adminUsername) {
          localStorage.removeItem(ADMIN_SESSION_KEY);
          return;
        }
        localStorage.setItem(ADMIN_SESSION_KEY, JSON.stringify({
          adminToken: state.adminToken,
          adminUsername: state.adminUsername
        }));
      } catch (_) {}
    }

    function clearAdminSession() {
      state.adminToken = '';
      state.adminUsername = '';
      try { localStorage.removeItem(ADMIN_SESSION_KEY); } catch (_) {}
      renderAdminIdentity();
    }

    async function adminLogin() {
      const username = String(els.adminUserInput.value || '').trim().toLowerCase();
      const password = String(els.adminPassInput.value || '').trim();
      if (!username || !password) {
        throw new Error('Enter admin username and password.');
      }
      const data = await apiRequest('POST', '/api/watch/admin/login', { username, password });
      state.adminToken = String(data.adminToken || '');
      state.adminUsername = String(data.username || username);
      saveAdminSession();
      renderAdminIdentity();
      await refreshAdminRooms().catch(() => {});
      await refreshAdminList();
      setStatus(true, 'Admin signed in.');
    }

    async function addAdminUser() {
      const newUsername = String(els.newAdminUserInput.value || '').trim().toLowerCase();
      const newPassword = String(els.newAdminPassInput.value || '').trim();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!adminCode) throw new Error('Admin code required.');
      if (!newUsername || !newPassword) throw new Error('Enter new admin username and password.');
      await apiRequest('POST', '/api/watch/admin/add', {
        adminToken: state.adminToken,
        adminCode,
        newUsername,
        newPassword
      });
      els.newAdminPassInput.value = '';
      await refreshAdminList();
      setStatus(true, 'Admin user added: ' + newUsername);
      addEventLine('Admin added: ' + newUsername);
    }

    async function refreshAdminList() {
      if (!state.adminToken) return;
      const data = await apiRequest('POST', '/api/watch/admin/list', { adminToken: state.adminToken });
      const admins = Array.isArray(data.admins) ? data.admins : [];
      els.adminListSelect.innerHTML = '';
      for (const row of admins) {
        const opt = document.createElement('option');
        opt.value = row.username;
        opt.textContent = row.isOwner ? `${row.username} (owner)` : row.username;
        els.adminListSelect.appendChild(opt);
      }
      if (!admins.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No admins found';
        els.adminListSelect.appendChild(opt);
      }
    }

    async function removeSelectedAdmin() {
      const username = String((els.adminListSelect && els.adminListSelect.value) || '').trim().toLowerCase();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!username) throw new Error('Select an admin to remove.');
      if (!adminCode) throw new Error('Admin code required.');
      const ok = window.confirm(`Remove admin ${username}?`);
      if (!ok) return;
      await apiRequest('POST', '/api/watch/admin/remove', { adminToken: state.adminToken, adminCode, username });
      await refreshAdminList();
      setStatus(true, `Admin removed: ${username}`);
      addEventLine(`Admin removed: ${username}`);
    }

    async function adminLogout() {
      const token = String(state.adminToken || '').trim();
      if (!token) return;
      try {
        await apiRequest('POST', '/api/watch/admin/logout', { adminToken: token });
      } catch (_) {}
      clearAdminSession();
      setStatus(false, 'Admin signed out.');
      if (els.adminRoomsSelect) els.adminRoomsSelect.innerHTML = '';
    }

    function updateBadges() {
      els.roomBadge.textContent = 'Room: ' + (state.roomCode || 'none');
      els.roleBadge.textContent = 'Role: ' + (state.isHost ? 'host' : 'viewer');
    }

    function onSessionStart() {
      updateBadges();
      setThemeControlState();
      els.createBtn.disabled = true;
      els.joinBtn.disabled = true;
      els.setMediaBtn.disabled = !state.isHost;
      els.playBtn.disabled = !state.isHost;
      els.pauseBtn.disabled = !state.isHost;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      els.resetRoomBtn.disabled = !state.isHost;
      els.deleteRoomBtn.disabled = !state.isHost;
      els.chatBtn.disabled = false;
      setWizardStep(2);
      switchTab(state.isHost ? 'host' : 'chat');
      if (state.pollTimer) clearInterval(state.pollTimer);
      state.pollTimer = setInterval(pollState, POLL_MS);
      saveSession();
      updateMediaVisibility();
      pollState();
    }

    function applyRoomState(room, force) {
      if (!room) return;
      state.lastRoom = room;
      const roomTheme = Object.prototype.hasOwnProperty.call(THEMES, String(room.themeKey || '')) ? String(room.themeKey) : 'clean';
      state.roomThemeKey = roomTheme;
      applyTheme(roomTheme, false);
      setThemeControlState();
      els.nowTitle.textContent = room.title ? ('Now Playing: ' + room.title) : 'Now Playing';
      if (!state.isHost) {
        els.titleInput.value = room.title || '';
        els.mediaInput.value = room.mediaUrl || '';
      }

      const p = els.player;
      const mediaUrl = (room.mediaUrl || '').trim();
      if (mediaUrl && p.src !== mediaUrl) {
        state.suppressOutbound = true;
        p.src = mediaUrl;
        p.load();
        state.suppressOutbound = false;
      }

      const drift = Math.abs((Number(p.currentTime) || 0) - (Number(room.playbackSec) || 0));
      if (force || drift > 1.5) {
        try {
          state.suppressOutbound = true;
          p.currentTime = Number(room.playbackSec) || 0;
          state.suppressOutbound = false;
          setSyncLabel('aligned');
        } catch (_) {
          state.suppressOutbound = false;
        }
      }

      if (!state.isHost) {
        if (room.isPlaying && p.paused) {
          state.suppressOutbound = true;
          p.play().catch(() => {});
          state.suppressOutbound = false;
        }
        if (!room.isPlaying && !p.paused) {
          state.suppressOutbound = true;
          p.pause();
          state.suppressOutbound = false;
        }
      }
    }

    async function setupMedia() {
      if (!state.isHost) return;
      await sendControl('set_media', {
        mediaUrl: els.mediaInput.value.trim(),
        title: els.titleInput.value.trim()
      });
      setSyncLabel('media updated');
    }

    async function sendChat() {
      const message = els.chatInput.value.trim();
      if (!message) return;
      await sendControl('chat', { message });
      els.chatInput.value = '';
    }

    async function copyInviteLink() {
      if (!state.roomCode) return;
      const url = window.location.origin + '/telewatch/?room=' + encodeURIComponent(state.roomCode);
      try {
        await navigator.clipboard.writeText(url);
        setSyncLabel('invite copied');
      } catch (_) {
        setSyncLabel(url);
      }
    }

    async function resetRoom() {
      if (!state.isHost) return;
      await sendControl('reset_room', { title: els.titleInput.value.trim() });
      els.mediaInput.value = '';
      els.player.pause();
      try { els.player.currentTime = 0; } catch (_) {}
      setSyncLabel('room reset');
      addEventLine('Room reset by host');
    }

    async function pollState() {
      if (!state.roomCode || !state.participantToken) return;
      try {
        const data = await apiRequest('GET', '/api/watch/state', null, {
          roomCode: state.roomCode,
          participantToken: state.participantToken,
          sinceEventId: state.sinceEventId
        });
        state.participantId = data.selfParticipantId || state.participantId;
        state.participants = Array.isArray(data.participants) ? data.participants : [];
        refreshMuteTargets();
        updateVoiceUi();
        renderParticipants();
        setStatus(true, 'Connected ¬∑ active viewers: ' + (data.activeCount || 0));
        updateStatusChips(data.activeCount || 0);
        applyRoomState(data.room || null, false);
        updateMediaVisibility();
        if (state.isHost && rtc.localScreenStream) {
          await broadcastOffersToViewers();
        }
        if (voiceOn()) {
          await syncVoiceOffers();
        }
        for (const ev of (data.events || [])) {
          state.sinceEventId = Math.max(state.sinceEventId, Number(ev.id) || 0);
          const actor = ev.actor || 'user';
          if (ev.type === 'signal') {
            await processSignal(ev.payload || {});
            continue;
          }
          if (ev.type === 'reaction') {
            addReaction(String(ev.payload?.emoji || 'üëè'), actor);
            continue;
          }
          if (ev.type === 'request_item') {
            upsertRequestFromEvent(ev);
            renderRequestQueue();
            addEventLine(actor + ' ¬∑ request submitted');
            continue;
          }
          if (ev.type === 'resolve_request') {
            resolveRequestFromEvent(ev);
            renderRequestQueue();
            addEventLine(actor + ' ¬∑ request ' + String(ev.payload?.status || 'resolved'));
            continue;
          }
          if (ev.type === 'mute_user') {
            const targetId = String(ev.payload?.toParticipantId || '').toLowerCase();
            const muted = !!ev.payload?.muted;
            if (targetId) state.hostMuted[targetId] = muted;
            if (targetId && targetId === String(state.participantId || '').toLowerCase() && rtc.localVoiceStream) {
              for (const t of rtc.localVoiceStream.getAudioTracks()) t.enabled = !muted;
              updateVoiceUi();
            }
            renderParticipants();
            continue;
          }
          if (ev.type === 'chat') {
            addChatLine(actor, String(ev.payload?.message || ''));
            continue;
          }
          addEventLine(actor + ' ¬∑ ' + ev.type.replace('_', ' '));
        }
      } catch (err) {
        setStatus(false, 'Reconnect pending: ' + (err?.message || 'network_error'));
        setSyncLabel('retrying');
        updateStatusChips(0);
        updateMediaVisibility();
      }
    }

    els.createBtn.addEventListener('click', async () => {
      try {
        await createRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_capacity_reached')) {
          setStatus(false, 'Room limit reached (35 max). Delete an existing room first.');
          return;
        }
        if (msg.includes('room_code_taken') || msg.includes('409')) {
          setStatus(false, 'Room code already taken. Use a new code or click Join Room.');
          addEventLine('Room code already exists. Try Join Room for that code.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.joinBtn.addEventListener('click', async () => {
      try {
        await joinRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_full')) {
          setStatus(false, 'Room is full (25 people max).');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.quickHostBtn) {
      els.quickHostBtn.addEventListener('click', async () => {
        try {
          await quickHost();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.recentJoinBtn) {
      els.recentJoinBtn.addEventListener('click', async () => {
        const selected = normalizeRoomCode((els.recentRoomsSelect && els.recentRoomsSelect.value) || '');
        if (!selected) {
          setStatus(false, 'Select a recent room first.');
          return;
        }
        els.roomInput.value = selected;
        try {
          await joinRoom();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.advancedToggleBtn) {
      els.advancedToggleBtn.addEventListener('click', () => {
        const hidden = els.advancedWrap.classList.toggle('hidden');
        els.advancedToggleBtn.textContent = hidden ? 'Show Advanced' : 'Hide Advanced';
      });
    }
    if (els.resetRoomBtn) {
      els.resetRoomBtn.addEventListener('click', async () => {
        try {
          await resetRoom();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.joinVoiceBtn) {
      els.joinVoiceBtn.addEventListener('click', async () => {
        try { await startVoiceChat(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.leaveVoiceBtn) {
      els.leaveVoiceBtn.addEventListener('click', async () => {
        try { await stopVoiceChat(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.muteTargetBtn) {
      els.muteTargetBtn.addEventListener('click', async () => {
        try { await hostSetMuteTarget(true); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.unmuteTargetBtn) {
      els.unmuteTargetBtn.addEventListener('click', async () => {
        try { await hostSetMuteTarget(false); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.copyAdminRoomBtn) {
      els.copyAdminRoomBtn.addEventListener('click', async () => {
        const code = String((els.adminRoomsSelect && els.adminRoomsSelect.value) || '').trim();
        if (!code) return;
        try {
          await navigator.clipboard.writeText(code);
          setStatus(true, 'Copied room code: ' + code);
        } catch (_) {
          setStatus(true, 'Room code: ' + code);
        }
      });
    }
    if (els.sendRequestBtn) {
      els.sendRequestBtn.addEventListener('click', async () => {
        try { await sendRequestItem(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.approveRequestBtn) {
      els.approveRequestBtn.addEventListener('click', async () => {
        try { await resolveSelectedRequest('approved'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.denyRequestBtn) {
      els.denyRequestBtn.addEventListener('click', async () => {
        try { await resolveSelectedRequest('denied'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    for (const rbtn of (els.reactionButtons || [])) {
      rbtn.addEventListener('click', async () => {
        try { await sendReaction(rbtn.getAttribute('data-react') || 'üëè'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.adminLoginBtn) els.adminLoginBtn.addEventListener('click', async () => {
      try {
        await adminLogin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_login_invalid')) {
          setStatus(false, 'Admin login failed. Check username/password.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.refreshAdminsBtn) els.refreshAdminsBtn.addEventListener('click', async () => {
      try {
        await refreshAdminList();
        setStatus(true, 'Admin list refreshed.');
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.addAdminBtn) els.addAdminBtn.addEventListener('click', async () => {
      try {
        await addAdminUser();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        if (msg.includes('admin_auth_required') || msg.includes('admin_auth_invalid')) {
          setStatus(false, 'Sign in as admin before adding admins.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.removeAdminBtn) els.removeAdminBtn.addEventListener('click', async () => {
      try {
        await removeSelectedAdmin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('owner_required')) {
          setStatus(false, 'Only the owner can remove admins.');
          return;
        }
        if (msg.includes('cannot_remove_owner')) {
          setStatus(false, 'Owner account cannot be removed.');
          return;
        }
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.adminLogoutBtn) els.adminLogoutBtn.addEventListener('click', async () => {
      await adminLogout();
    });
    for (const btn of els.tabButtons) {
      btn.addEventListener('click', () => switchTab(btn.getAttribute('data-tab-btn') || 'session'));
    }
    els.setMediaBtn.addEventListener('click', async () => {
      try { await setupMedia(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.chatBtn.addEventListener('click', async () => {
      try { await sendChat(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.copyLinkBtn.addEventListener('click', copyInviteLink);
    els.startShareBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await startScreenShare();
      } catch (err) {
        setStatus(false, screenShareHelpMessage(err));
      }
    });
    els.stopShareBtn.addEventListener('click', async () => {
      try { await stopScreenShare(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.deleteRoomBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      const ok = window.confirm(`Delete room ${state.roomCode}? This removes the active watch session.`);
      if (!ok) return;
      try {
        await sendControl('delete_room', {});
        if (state.pollTimer) clearInterval(state.pollTimer);
        await stopScreenShare();
        state.roomCode = '';
        state.participantToken = '';
        state.participantId = '';
        state.participants = [];
        state.isHost = false;
        state.sinceEventId = 0;
        state.roomThemeKey = '';
        els.roomInput.value = '';
        els.createBtn.disabled = false;
        els.joinBtn.disabled = false;
        els.setMediaBtn.disabled = true;
        els.playBtn.disabled = true;
        els.pauseBtn.disabled = true;
        els.startShareBtn.disabled = true;
        els.stopShareBtn.disabled = true;
        els.resetRoomBtn.disabled = true;
        els.deleteRoomBtn.disabled = true;
        els.chatBtn.disabled = true;
        updateBadges();
        applyTheme(state.localThemeKey || 'clean', false);
        setThemeControlState();
        clearSession();
        setSyncLabel('room deleted');
        setStatus(false, 'Room deleted.');
        addEventLine('Room deleted by host.');
        updateMediaVisibility();
      } catch (err) {
        setStatus(false, String(err && err.message ? err.message : err));
      }
    });
    els.playBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 });
        await els.player.play().catch(() => {});
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.pauseBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        els.player.pause();
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.resyncBtn.addEventListener('click', () => applyRoomState(state.lastRoom, true));

    els.player.addEventListener('play', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('pause', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('seeked', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      const now = Date.now();
      if (now - state.lastSeekSentAt < 450) return;
      state.lastSeekSentAt = now;
      try { await sendControl('seek', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });

    (function init() {
      initThemeSelector();
      switchTab('session');
      setWizardStep(1);
      updateStatusChips(0);
      updateMediaVisibility();
      renderParticipants();
      renderRequestQueue();
      refreshOpenParties();
      if (openPartyTimer) clearInterval(openPartyTimer);
      openPartyTimer = setInterval(refreshOpenParties, 15000);
      const roomFromQuery = normalizeRoomCode(qp('room') || '');
      if (roomFromQuery) els.roomInput.value = roomFromQuery;
      els.roomInput.addEventListener('input', () => {
        els.roomInput.value = normalizeRoomCode(els.roomInput.value);
      });
      if (els.inviteInput) {
        els.inviteInput.addEventListener('change', () => {
          const code = parseInviteRoom(els.inviteInput.value);
          if (code) els.roomInput.value = code;
        });
      }
      renderRecentRooms();
      try {
        const savedAdminKey = localStorage.getItem('telewatch_admin_key') || '';
        if (savedAdminKey) els.adminKeyInput.value = savedAdminKey;
      } catch (_) {}
      els.adminKeyInput.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_admin_key', els.adminKeyInput.value); } catch (_) {}
      });
      if (!els.adminUserInput.value.trim()) {
        els.adminUserInput.value = 'Trimbledustn@gmail.com';
      }
      if (els.shareSurfaceSelect && !els.shareSurfaceSelect.value) {
        els.shareSurfaceSelect.value = 'browser';
      }
      if (els.shareAudioSelect && !els.shareAudioSelect.value) {
        els.shareAudioSelect.value = 'tab';
      }
      try {
        const rawAdmin = localStorage.getItem(ADMIN_SESSION_KEY) || '';
        if (rawAdmin) {
          const a = JSON.parse(rawAdmin);
          state.adminToken = String(a.adminToken || '').trim();
          state.adminUsername = String(a.adminUsername || '').trim().toLowerCase();
          if (state.adminUsername) els.adminUserInput.value = state.adminUsername;
        }
      } catch (_) {}
      renderAdminIdentity();
      updateVoiceUi();
      if (state.adminToken) {
        refreshAdminList().catch(() => {
          clearAdminSession();
        });
        refreshAdminRooms().catch(() => {});
      }
      try {
        const savedName = localStorage.getItem('telewatch_name') || '';
        if (savedName) els.displayName.value = savedName;
      } catch (_) {}
      els.displayName.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_name', els.displayName.value.trim()); } catch (_) {}
      });
      try {
        const raw = localStorage.getItem(SESSION_KEY) || '';
        if (raw) {
          const s = JSON.parse(raw);
          const room = normalizeRoomCode(s.roomCode || '');
          const token = String(s.participantToken || '').trim();
          if (room && token) {
            state.roomCode = room;
            state.participantToken = token;
            state.participantId = String(s.participantId || '').trim();
            state.isHost = !!s.isHost;
            state.sinceEventId = 0;
            els.roomInput.value = room;
            onSessionStart();
            if (state.isHost) {
              setStatus(false, 'Session restored. Re-click Share Monitor / Tab after refresh.');
            } else {
              setStatus(false, 'Session restored. Reconnecting stream...');
            }
            return;
          }
        }
      } catch (_) {}
      updateBadges();
      if (roomFromQuery) setStatus(false, 'Enter name and click Join Room');
    })();
  </script>
</body>
</html>
