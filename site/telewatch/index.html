<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Frenzy Telewatch | Synced Watch Rooms</title>
  <style>
    :root {
      --bg: #f4f6fa;
      --bg-gradient: linear-gradient(180deg, #f8f9fc, #f3f6fa);
      --bg-graphic-image: url('/assets/themes/clean-default.svg');
      --bg-graphic-size: cover;
      --bg-graphic-position: center;
      --bg-graphic-opacity: 0.52;
      --panel: #ffffff;
      --panel-2: #fbfcfe;
      --line: #dbe2ea;
      --line-soft: #e9eef4;
      --text: #18212c;
      --muted: #6a7787;
      --accent: #ff5f1f;
      --accent-strong: #e04d11;
      --good: #168252;
      --warn: #9e5d00;
      --danger: #b42318;
      --shadow: 0 10px 28px rgba(16, 24, 40, 0.08);
      --pill-bg: #f8fafc;
      --pill-line: #dbe2ea;
      --pill-text: #314155;
      --input-bg: #ffffff;
      --input-line: #d1dae5;
      --input-focus: #ff925f;
      --input-focus-glow: rgba(255, 95, 31, 0.15);
      --tab-active-bg: #fff3ec;
      --tab-active-text: #a43f12;
      --tab-active-line: #ff925f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--text);
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: var(--bg-gradient);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    .bg-scene {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }
    .bg-graphic {
      position: absolute;
      inset: 0;
      background-image: var(--bg-graphic-image);
      background-position: var(--bg-graphic-position);
      background-size: var(--bg-graphic-size);
      background-repeat: no-repeat;
      opacity: var(--bg-graphic-opacity);
      transform: scale(1.02);
      filter: saturate(1.08) contrast(1.02);
    }
    .bg-grid {
      position: absolute;
      inset: 0;
      opacity: 0.16;
      background-image:
        linear-gradient(rgba(255,255,255,0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.08) 1px, transparent 1px);
      background-size: 34px 34px;
      mask-image: radial-gradient(circle at 50% 30%, black 30%, transparent 85%);
    }
    .bg-noise {
      position: absolute;
      inset: -20%;
      opacity: 0.08;
      background-image:
        radial-gradient(circle at 20% 20%, rgba(255,255,255,0.8) 0.7px, transparent 1px),
        radial-gradient(circle at 80% 40%, rgba(255,255,255,0.65) 0.7px, transparent 1px),
        radial-gradient(circle at 50% 70%, rgba(255,255,255,0.55) 0.7px, transparent 1px);
      background-size: 4px 4px, 5px 5px, 6px 6px;
      animation: driftNoise 22s linear infinite;
    }
    .bg-orb {
      position: absolute;
      width: 42vw;
      height: 42vw;
      min-width: 260px;
      min-height: 260px;
      border-radius: 50%;
      filter: blur(42px);
      opacity: 0.34;
      animation: driftOrb 18s ease-in-out infinite alternate;
    }
    .bg-orb.a {
      background: radial-gradient(circle, rgba(255, 112, 71, 0.8), rgba(255, 112, 71, 0));
      top: -14vw;
      left: -10vw;
    }
    .bg-orb.b {
      background: radial-gradient(circle, rgba(94, 173, 255, 0.72), rgba(94, 173, 255, 0));
      bottom: -16vw;
      right: -9vw;
      animation-delay: -6s;
    }
    .bg-orb.c {
      background: radial-gradient(circle, rgba(189, 113, 255, 0.62), rgba(189, 113, 255, 0));
      top: 30%;
      left: 35%;
      width: 30vw;
      height: 30vw;
      animation-delay: -10s;
    }
    @keyframes driftOrb {
      0% { transform: translate3d(0, 0, 0) scale(1); }
      100% { transform: translate3d(18px, -18px, 0) scale(1.08); }
    }
    @keyframes driftNoise {
      0% { transform: translate3d(0, 0, 0); }
      100% { transform: translate3d(-3%, 2%, 0); }
    }
    .wrap {
      width: min(1240px, calc(100% - 28px));
      margin: 18px auto 30px;
      position: relative;
      z-index: 2;
    }
    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 14px 16px;
    }
    .hero {
      display: grid;
      gap: 4px;
    }
    .hero h1 {
      margin: 0;
      font-size: 25px;
      letter-spacing: 0.01em;
    }
    .hero p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      padding: 7px 11px;
      border-radius: 999px;
      background: var(--pill-bg);
      border: 1px solid var(--pill-line);
      color: var(--pill-text);
      font-weight: 700;
      font-size: 12px;
    }
    .theme-select {
      max-width: 230px;
      min-width: 170px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--pill-line);
      background: var(--pill-bg);
      color: var(--pill-text);
      font-weight: 700;
    }
    .wizard {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .wizard-step {
      font-size: 11px;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 999px;
      padding: 4px 9px;
      color: #607184;
      font-weight: 700;
    }
    .wizard-step.active {
      border-color: var(--tab-active-line);
      background: var(--tab-active-bg);
      color: var(--tab-active-text);
    }
    .workspace {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 280px 360px 1fr;
      gap: 14px;
    }
    .sidebar {
      border: 1px solid var(--line);
      border-radius: 15px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 12px;
      display: grid;
      gap: 10px;
      align-content: start;
      max-height: calc(100vh - 120px);
      overflow: auto;
    }
    .side-block {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: var(--panel-2);
      padding: 8px;
      display: grid;
      gap: 6px;
    }
    .side-list {
      display: grid;
      gap: 5px;
      max-height: 180px;
      overflow: auto;
    }
    .side-item {
      border: 1px solid var(--line-soft);
      border-radius: 8px;
      padding: 6px;
      font-size: 12px;
      background: var(--input-bg);
      color: var(--text);
    }
    .side-controls {
      display: grid;
      gap: 6px;
    }
    .ui-easy [data-advanced-ui="true"] {
      display: none !important;
    }
    .compact-mode .card,
    .compact-mode .sidebar { padding: 10px; }
    .compact-mode .block { padding: 8px; }
    .compact-mode input,
    .compact-mode button,
    .compact-mode textarea,
    .compact-mode select { padding: 8px 9px; }
    .focus-mode [data-scene-card="open"],
    .focus-mode .admin-delete,
    .focus-mode #eventsBlock,
    .focus-mode .tab-btn[data-tab-btn="admin"] { display: none !important; }
    .empty-state {
      border: 1px dashed var(--line);
      border-radius: 10px;
      padding: 8px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }
    .card {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--panel);
      box-shadow: 0 6px 18px rgba(16, 24, 40, 0.06);
      padding: 12px;
    }
    h2, h3 { margin: 0; }
    h2 { font-size: 18px; }
    h3 {
      margin-top: 2px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #516072;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .muted { color: var(--muted); }
    .stack { display: grid; gap: 10px; }
    .panel-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      border-bottom: 1px solid var(--line);
      padding-bottom: 8px;
    }
    .tab-btn {
      border: 1px solid #d1dae5;
      background: #fff;
      color: #33475f;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .tab-btn.active {
      border-color: var(--tab-active-line);
      background: var(--tab-active-bg);
      color: var(--tab-active-text);
    }
    .tab-pane { display: none; }
    .tab-pane.active { display: grid; gap: 10px; }
    .block {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: color-mix(in srgb, var(--panel-2) 90%, #ffffff 10%);
      padding: 9px;
    }
    .collapse-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }
    .collapse-head .collapse-title {
      margin: 0;
      font-size: 13px;
      color: #516072;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .collapse-btn {
      width: auto;
      min-width: 34px;
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1;
    }
    .collapse-body { display: grid; gap: 8px; }
    .is-collapsed .collapse-body { display: none !important; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 120px; }
    label {
      font-size: 11px;
      color: #5f6e7f;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      margin-bottom: 5px;
      display: block;
    }
    input, button, textarea, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--input-line);
      background: var(--input-bg);
      color: var(--text);
      padding: 10px 11px;
      font: inherit;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--input-focus);
      box-shadow: 0 0 0 3px var(--input-focus-glow);
    }
    textarea { min-height: 70px; resize: vertical; }
    button {
      width: auto;
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      border: 0;
      color: #fff;
      font-weight: 800;
      cursor: pointer;
      padding: 10px 13px;
      transition: transform 0.16s ease, filter 0.16s ease;
    }
    button:hover { transform: translateY(-1px); filter: brightness(1.04); }
    button.secondary {
      background: var(--input-bg);
      border: 1px solid var(--input-line);
      color: #2f3f52;
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    button.danger-btn {
      background: linear-gradient(180deg, #e5484d, #c23138);
      color: #fff;
    }
    video {
      width: 100%;
      max-height: 410px;
      border-radius: 12px;
      border: 1px solid #d2dbe6;
      background: #0f1720;
    }
    .status-online { color: var(--good); }
    .status-warn { color: var(--warn); }
    .stage {
      display: grid;
      gap: 10px;
    }
    .family-lounge {
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      background: color-mix(in srgb, var(--panel-2) 92%, #ffffff 8%);
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .duo {
      display: grid;
      grid-template-columns: 1fr 330px;
      gap: 10px;
      align-items: start;
    }
    .community-layout {
      grid-template-columns: 1fr;
    }
    .community-chat-panel {
      grid-column: 1 / -1;
      min-height: 560px;
      grid-template-rows: auto auto auto minmax(320px, 1fr) auto;
      width: 100%;
    }
    .community-layout .admin-delete {
      max-width: 100%;
    }
    .scene-board {
      display: grid;
      gap: 10px;
    }
    .scene-card {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: var(--panel-2);
      padding: 9px;
      display: grid;
      gap: 8px;
    }
    .scene-card[draggable="true"] { cursor: grab; }
    .scene-card.dragging { opacity: 0.55; }
    .scene-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .06em;
      font-weight: 700;
    }
    .drag-handle {
      border: 1px solid var(--input-line);
      background: var(--input-bg);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      color: var(--muted);
    }
    .events {
      max-height: 240px;
      overflow: auto;
      background: #f8fafc;
      border: 1px solid #dde5ef;
      border-radius: 9px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .events div { padding: 3px 0; border-bottom: 1px dashed #d6dfe9; }
    .events div:last-child { border-bottom: 0; }
    .message-center {
      border: 1px solid #2f3c52;
      border-radius: 14px;
      background: linear-gradient(180deg, #1f2633, #1a202b);
      padding: 10px;
      display: grid;
      gap: 8px;
    }
    .message-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    .message-top h3 {
      margin: 0;
      text-transform: none;
      letter-spacing: 0.01em;
      font-size: 18px;
      color: #eef4ff;
    }
    .message-top .muted { margin: 0; color: #a7bad8; }
    .chat-count {
      font-size: 11px;
      font-weight: 700;
      color: #d2ddf1;
      border: 1px solid #3f5476;
      background: #27364c;
      border-radius: 999px;
      padding: 3px 9px;
    }
    .pinned-box {
      border: 1px solid #53688f;
      background: #27344a;
      color: #eaf1ff;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
    }
    .chat-feed {
      max-height: none;
      min-height: 340px;
      height: clamp(420px, 54vh, 680px);
      overflow: auto;
      overflow-x: hidden;
      border: 1px solid #37485f;
      border-radius: 12px;
      padding: 10px;
      font-size: 13px;
      line-height: 1.45;
      background: #121923;
      display: grid;
      gap: 8px;
      align-content: start;
      scrollbar-width: auto;
      scrollbar-color: #5f7faa #1a2432;
    }
    .chat-feed::-webkit-scrollbar {
      width: 12px;
    }
    .chat-feed::-webkit-scrollbar-track {
      background: #1a2432;
      border-radius: 10px;
    }
    .chat-feed::-webkit-scrollbar-thumb {
      background: #5f7faa;
      border-radius: 10px;
      border: 2px solid #1a2432;
    }
    .msg-line {
      display: grid;
      grid-template-columns: 34px minmax(0, 1fr);
      gap: 8px;
      align-items: start;
    }
    .msg-line.mine {
      grid-template-columns: minmax(0, 1fr) 34px;
    }
    .chat-feed .msg-line {
      border: 0;
      background: transparent;
      padding: 0;
      box-shadow: none;
    }
    .msg-line[data-pinned="true"] {
      filter: saturate(1.05);
    }
    .msg-avatar {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border: 1px solid #4d6388;
      background: #24324a;
      color: #dbe8ff;
      display: grid;
      place-items: center;
      font-size: 12px;
      font-weight: 800;
      user-select: none;
    }
    .msg-card {
      border: 1px solid #30445f;
      border-radius: 12px;
      background: #1e2a3d;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }
    .msg-line.mine .msg-card {
      background: #304f7e;
      border-color: #3f66a0;
    }
    .msg-head { font-size: 11px; color: #a8bbd8; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .msg-line.mine .msg-head { color: #d9e7ff; }
    .msg-body { font-size: 13px; color: #eef4ff; word-break: break-word; }
    .msg-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 4px;
    }
    .msg-pill {
      border: 1px solid #58709b;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      background: #24344c;
      color: #d7e5ff;
      cursor: pointer;
      user-select: none;
    }
    .msg-pill.active {
      border-color: #8fb6ff;
      color: #fff;
      background: #365687;
    }
    .chat-compose {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: end;
    }
    .chat-compose textarea {
      min-height: 56px;
      margin: 0;
      background: #121b29;
      border-color: #3c506f;
      color: #eff5ff;
    }
    .chat-compose button {
      height: fit-content;
      min-width: 132px;
    }
    .participants-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    }
    .participant-card {
      border: 1px solid var(--line-soft);
      background: var(--panel-2);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 3px;
    }
    .participant-name { font-weight: 700; font-size: 13px; }
    .participant-meta { font-size: 11px; color: var(--muted); }
    .participant-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }
    .participant-controls button {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 999px;
      width: auto;
    }
    .webcam-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    }
    .webcam-tile {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: var(--panel-2);
      padding: 6px;
      display: grid;
      gap: 6px;
    }
    .webcam-tile video {
      min-height: 140px;
      max-height: 220px;
      object-fit: cover;
      border-radius: 8px;
    }
    .media-device-panel {
      border: 1px solid var(--line-soft);
      background: var(--panel-2);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 8px;
    }
    .webcam-stage {
      display: grid;
      gap: 10px;
      grid-template-columns: minmax(220px, 340px) minmax(0, 1fr);
      align-items: start;
    }
    .webcam-stage-box {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: var(--panel-2);
      padding: 8px;
    }
    .webcam-stage-label {
      font-size: 12px;
      font-weight: 700;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: .04em;
    }
    .webcam-stage-local video {
      width: 100%;
      min-height: 180px;
      max-height: 300px;
      object-fit: cover;
      border-radius: 8px;
    }
    .host-options-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .webcam-label {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .reaction-bar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }
    .reaction-btn {
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 16px;
      line-height: 1;
      border: 1px solid var(--input-line);
      background: var(--input-bg);
      cursor: pointer;
    }
    .reaction-overlay {
      position: absolute;
      right: 14px;
      bottom: 20px;
      display: grid;
      gap: 6px;
      pointer-events: none;
      z-index: 4;
    }
    .reaction-pop {
      font-size: 24px;
      animation: floatUp 1.7s ease forwards;
      text-shadow: 0 4px 12px rgba(0,0,0,.25);
    }
    @keyframes floatUp {
      0% { transform: translateY(0) scale(0.9); opacity: 0; }
      15% { transform: translateY(-4px) scale(1); opacity: 1; }
      100% { transform: translateY(-46px) scale(1.05); opacity: 0; }
    }
    .open-party-list {
      display: grid;
      gap: 8px;
    }
    .open-party-item {
      border: 1px solid var(--line-soft);
      background: var(--panel-2);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 4px;
    }
    .open-party-title { font-weight: 700; }
    .open-party-meta { font-size: 12px; color: var(--muted); }
    .hidden-media { display: none !important; }
    .admin-tools.hidden { display: none; }
    .admin-login.hidden { display: none; }
    .hidden { display: none !important; }
    .admin-accordion {
      display: grid;
      gap: 8px;
    }
    .admin-accordion details.dropdown {
      background: var(--panel-2);
      border: 1px solid var(--line-soft);
      border-radius: 10px;
    }
    .admin-accordion details[open] {
      border-color: var(--tab-active-line);
      box-shadow: 0 0 0 2px rgba(255, 95, 31, 0.08);
    }
    .admin-accordion details > summary {
      font-size: 12px;
      letter-spacing: .04em;
      text-transform: uppercase;
      color: #4f6074;
    }
    .host-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr 1fr;
    }
    .host-grid .full { grid-column: 1 / -1; }
    .footer {
      margin-top: 12px;
      color: #718196;
      font-size: 13px;
      text-align: center;
    }
    a { color: #70d8ff; }
    .admin-delete {
      border: 1px solid #d8e1ec;
      background: #fbfcfe;
      border-radius: 10px;
      padding: 8px;
    }
    .admin-delete h3 { margin-bottom: 8px; }
    .count-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d4dee9;
      background: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #33475f;
    }
    .status-strip {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .status-chip {
      font-size: 11px;
      border: 1px solid #d4dee9;
      background: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      color: #44586f;
      font-weight: 700;
    }
    .status-chip.ok {
      border-color: #8fd7b8;
      background: #edf9f3;
      color: #0e6b42;
    }
    .adv-wrap.hidden { display: none; }
    details.dropdown {
      border: 1px solid var(--line-soft);
      border-radius: 10px;
      background: var(--panel-2);
      padding: 8px;
    }
    details.dropdown > summary {
      cursor: pointer;
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
      list-style: none;
    }
    details.dropdown > summary::-webkit-details-marker { display: none; }
    .admin-room-meta {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }
    @media (max-width: 1080px) {
      .workspace { grid-template-columns: 1fr; }
      .duo { grid-template-columns: 1fr; }
      .row > * { min-width: 100px; }
      .host-grid { grid-template-columns: 1fr; }
      .sidebar { max-height: none; }
      .webcam-stage { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .wrap { width: min(100%, calc(100% - 12px)); margin: 10px auto 18px; }
      .card { padding: 10px; }
      button { width: 100%; }
      .row > * { flex: 1 1 100%; min-width: 100%; }
      input, button, textarea { font-size: 16px; }
      .badge { font-size: 12px; }
      video { max-height: 230px; }
      .chat-compose { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="bg-scene" aria-hidden="true">
    <div class="bg-graphic"></div>
    <div class="bg-grid"></div>
    <div class="bg-noise"></div>
    <div class="bg-orb a"></div>
    <div class="bg-orb b"></div>
    <div class="bg-orb c"></div>
  </div>
  <div class="wrap">
    <div class="top">
      <div class="hero">
        <h1>Frenzy Telewatch</h1>
        <p>Host or join synced watch rooms in one clean dashboard.</p>
        <div class="wizard">
          <span id="stepSession" class="wizard-step active">1. Session</span>
          <span id="stepRoom" class="wizard-step">2. Room</span>
          <span id="stepShare" class="wizard-step">3. Share</span>
        </div>
      </div>
      <div class="row">
        <span id="roomBadge" class="badge">Room: none</span>
        <span id="roleBadge" class="badge">Role: viewer</span>
        <span id="syncBadge" class="badge">Sync: idle</span>
        <select id="themeSelect" class="theme-select" aria-label="Theme"></select>
      </div>
    </div>

    <div class="workspace">
      <aside class="sidebar">
        <div class="side-block">
          <h3>Account</h3>
          <div id="accountGuestWrap" class="side-controls">
            <input id="userEmailInput" type="email" placeholder="Email" />
            <input id="userPassInput" type="password" placeholder="Password" />
            <input id="userDisplayInput" placeholder="Display name (optional)" />
            <div class="row">
              <button id="userLoginBtn" class="secondary">Sign In</button>
              <button id="userRegisterBtn" class="secondary">Create</button>
            </div>
            <div class="row">
              <button id="forgotPassBtn" class="secondary">Account Recovery (Discord/Admin)</button>
            </div>
            <div class="muted">Optional: account unlocks premium tools. Donation tiers unlock more features.</div>
          </div>
          <div id="accountUserWrap" class="side-controls hidden">
            <div id="userBadge" class="side-item">Signed in</div>
            <div class="row">
              <button id="saveRoomBtn" class="secondary">Save Current Room</button>
              <button id="userLogoutBtn" class="secondary">Sign Out</button>
            </div>
            <select id="savedRoomsSelect"></select>
            <div class="row">
              <button id="joinSavedRoomBtn" class="secondary">Join Saved</button>
              <button id="removeSavedRoomBtn" class="danger-btn">Remove</button>
            </div>
          </div>
        </div>
        <div class="side-block">
          <h3>Layout</h3>
          <div class="side-controls">
            <select id="uiModeSelect">
              <option value="easy">Easy View</option>
              <option value="pro">Pro View</option>
            </select>
            <select id="layoutModeSelect">
              <option value="standard">Standard Layout</option>
              <option value="focus">Focus Mode</option>
            </select>
            <select id="densitySelect">
              <option value="comfortable">Comfortable</option>
              <option value="compact">Compact</option>
            </select>
          </div>
        </div>
        <div class="side-block" data-advanced-ui="true" data-host-only="true">
          <h3>Host Macros</h3>
          <div class="side-controls">
            <button id="macroStartBtn" class="secondary">Start Party</button>
            <button id="macroIntermissionBtn" class="secondary">Intermission</button>
            <button id="macroWrapBtn" class="secondary">Wrap Up</button>
            <button id="macroMainEventBtn" class="secondary">Main Event ON</button>
            <button id="macroMainEventOffBtn" class="secondary">Main Event OFF</button>
            <div id="mainEventState" class="muted">Main Event: OFF</div>
          </div>
        </div>
        <div class="side-block" data-advanced-ui="true" data-host-only="true">
          <h3>Room Templates</h3>
          <div class="side-controls">
            <select id="templateSelect"></select>
            <button id="saveTemplateBtn" class="secondary">Save Template</button>
            <button id="applyTemplateBtn" class="secondary">Apply Template</button>
          </div>
        </div>
        <div class="side-block">
          <h3>Quick Rooms</h3>
          <div id="sideRooms" class="side-list"></div>
        </div>
        <div class="side-block">
          <h3>Voice</h3>
          <div id="sideVoice" class="side-item">Not connected</div>
        </div>
        <div class="side-block">
          <h3>Participants</h3>
          <div id="sideParticipants" class="side-list"></div>
        </div>
      </aside>

      <section class="card stack">
        <h2>Control Panel</h2>
        <div class="panel-tabs">
          <button class="tab-btn active" data-tab-btn="session">Session</button>
          <button class="tab-btn" data-tab-btn="host" data-host-only="true">Host Setup</button>
          <button class="tab-btn" data-tab-btn="chat">Messages</button>
          <button class="tab-btn" data-tab-btn="admin" data-advanced-ui="true">Admin</button>
        </div>

        <div class="tab-pane active" data-tab-pane="session">
          <div class="block stack">
            <div>
              <label for="displayName">Display Name</label>
              <input id="displayName" placeholder="e.g. DFrenzy" />
            </div>
            <div>
              <label for="roomInput">Room Code</label>
              <input id="roomInput" placeholder="e.g. DADDYR" />
            </div>
            <div>
              <label for="inviteInput">Paste Invite Link (optional)</label>
              <input id="inviteInput" placeholder="https://frenzynets.com/telewatch/?room=CODE" />
            </div>
            <div class="row">
              <div>
                <label for="clientModeSelect">Watch Mode</label>
                <select id="clientModeSelect">
                  <option value="web">Web Browser</option>
                  <option value="desktop">Desktop App</option>
                </select>
              </div>
              <button id="openDesktopBtn" class="secondary">Open Desktop App</button>
              <a id="downloadDesktopBtn" class="secondary" href="/telewatch/">Open Watch Party</a>
            </div>
            <div class="row">
              <button id="createBtn">Create Room</button>
              <button id="joinBtn" class="secondary">Join Room</button>
            </div>
            <div class="row">
              <button id="quickHostBtn">Quick Host</button>
              <button id="recentJoinBtn" class="secondary">Join Recent</button>
            </div>
            <div>
              <label for="recentRoomsSelect">Recent Rooms</label>
              <select id="recentRoomsSelect"></select>
            </div>
            <div class="muted" id="joinHint">Share your room code in Discord voice chat. Everyone runs their own stream account.</div>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="host" id="hostTabPane">
          <div class="host-options-head">
            <div class="muted">Host controls are only shown to the active room host.</div>
            <button id="hostOptionsToggleBtn" class="secondary" style="width:auto">Minimize Host Options</button>
          </div>
          <div id="hostOptionsWrap">
          <div class="block stack">
            <h3>Host Setup</h3>
            <div class="host-grid">
              <div class="full">
                <label for="titleInput">Title</label>
                <input id="titleInput" placeholder="Episode / movie title" />
              </div>
              <div class="full">
                <label for="mediaInput">Media URL (Optional Direct File)</label>
                <input id="mediaInput" placeholder="https://.../video.mp4" />
              </div>
              <button id="advancedToggleBtn" class="secondary full">Show Advanced</button>
              <div id="advancedWrap" class="adv-wrap hidden full host-grid">
                <div>
                  <label for="shareSurfaceSelect">Share Source</label>
                  <select id="shareSurfaceSelect">
                    <option value="auto">Auto (picker default)</option>
                    <option value="browser">Browser Tab</option>
                    <option value="window">Window/App</option>
                    <option value="monitor">Monitor/Screen</option>
                  </select>
                </div>
                <div>
                  <label for="shareAudioSelect">Share Audio</label>
                  <select id="shareAudioSelect">
                    <option value="auto">Auto</option>
                    <option value="tab">Prefer Tab Audio</option>
                    <option value="system">Prefer System Audio</option>
                    <option value="off">No Audio</option>
                  </select>
                </div>
                <div>
                  <label for="shareQualitySelect">Share Quality</label>
                  <select id="shareQualitySelect">
                    <option value="balanced">Balanced (720p / 30fps)</option>
                    <option value="high">High (1080p / 60fps)</option>
                    <option value="ultra">Ultra (1440p / 60fps)</option>
                  </select>
                </div>
                <div>
                  <label for="movieQualitySelect">Movie Quality</label>
                  <select id="movieQualitySelect">
                    <option value="high">Cinema High (1080p)</option>
                    <option value="ultra">Cinema Ultra (1440p)</option>
                    <option value="balanced">Balanced (720p)</option>
                  </select>
                </div>
                <div>
                  <label for="webcamQualitySelect">Webcam Quality</label>
                  <select id="webcamQualitySelect">
                    <option value="high">Clear (1080p)</option>
                    <option value="balanced">Balanced (720p)</option>
                    <option value="ultra">Ultra (1440p)</option>
                  </select>
                </div>
                <div>
                  <label for="audioProfileSelect">Audio Profile</label>
                  <select id="audioProfileSelect">
                    <option value="cinema">Cinema Clear</option>
                    <option value="voice">Voice Crisp</option>
                  </select>
                </div>
                <div>
                  <label for="mediaModeSelect">Media Transport</label>
                  <select id="mediaModeSelect">
                    <option value="webrtc">WebRTC Direct (Low Server Load)</option>
                    <option value="sfu">SFU Relay (Best for 40-50+)</option>
                    <option value="broadcast">Broadcast (Admin Only, HLS/CDN)</option>
                  </select>
                </div>
                <div>
                  <label for="accessModeSelect">Party Access</label>
                  <select id="accessModeSelect">
                    <option value="public">Public (Anyone can join)</option>
                    <option value="invite">Invite Only (Host approval)</option>
                    <option value="closed">Closed (No new joins)</option>
                  </select>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button id="setAccessModeBtn" class="secondary">Set Access Mode</button>
                </div>
                <div class="full" data-advanced-ui="true">
                  <label>Cohost Permission Matrix</label>
                  <div class="row">
                    <label><input id="cohostKickPerm" type="checkbox" checked /> Kick</label>
                    <label><input id="cohostMutePerm" type="checkbox" checked /> Mute</label>
                    <label><input id="cohostAccessPerm" type="checkbox" checked /> Access</label>
                    <label><input id="cohostPinPerm" type="checkbox" checked /> Pin</label>
                  </div>
                  <button id="setCohostPermsBtn" class="secondary">Apply Cohost Permissions</button>
                </div>
                <div>
                  <label for="inviteTtlInput">Invite Expires (Minutes)</label>
                  <input id="inviteTtlInput" type="number" min="5" max="10080" step="5" value="720" />
                </div>
                <div>
                  <label for="inviteMaxUsesInput">Invite Max Uses (0 = Unlimited)</label>
                  <input id="inviteMaxUsesInput" type="number" min="0" max="500" step="1" value="0" />
                </div>
                <div class="full">
                  <label>Invite Presets</label>
                  <div class="row">
                    <button class="secondary invite-preset-btn" data-ttl="60" data-uses="1">1h Single</button>
                    <button class="secondary invite-preset-btn" data-ttl="180" data-uses="10">3h Small Group</button>
                    <button class="secondary invite-preset-btn" data-ttl="1440" data-uses="0">24h Unlimited</button>
                    <button class="secondary invite-preset-btn" data-ttl="10080" data-uses="0">7d Unlimited</button>
                  </div>
                </div>
              </div>
              <button id="setMediaBtn" class="secondary">Set Media</button>
              <button id="copyLinkBtn" class="secondary">Copy Invite</button>
              <button id="startShareBtn" class="secondary">Share Monitor / Tab</button>
              <button id="stopShareBtn" class="secondary" disabled>Stop Share</button>
              <button id="resetRoomBtn" class="secondary">Reset Room</button>
              <button id="deleteRoomBtn" class="secondary full">Delete Room</button>
            </div>
            <div class="block stack full">
              <h3>Join Requests (Invite Only)</h3>
              <select id="joinRequestSelect"></select>
              <div class="row">
                <button id="approveJoinBtn" class="secondary">Approve Join</button>
                <button id="denyJoinBtn" class="secondary">Deny Join</button>
              </div>
            </div>
            <div class="block stack full" data-advanced-ui="true">
              <h3>Request Queue (Host)</h3>
              <select id="requestQueueSelect"></select>
              <div class="row">
                <input id="requestResolveNote" placeholder="Optional note to requester" />
                <button id="approveRequestBtn" class="secondary">Approve</button>
                <button id="denyRequestBtn" class="secondary">Deny</button>
              </div>
            </div>
          </div>
        </div>
        </div>

        <div class="tab-pane" data-tab-pane="chat">
          <div class="block stack">
            <h3>Make Request</h3>
            <div class="row">
              <select id="requestTypeSelect">
                <option value="general">General Request</option>
                <option value="media">Media Request</option>
                <option value="skip_intro">Skip Intro Vote</option>
                <option value="next_episode">Next Episode Vote</option>
                <option value="cohost">Co-host Request</option>
              </select>
              <button id="sendRequestBtn" class="secondary">Send Request</button>
            </div>
            <input id="requestTextInput" placeholder="Request text, e.g. play episode 2 or skip intro" />
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="admin" data-advanced-ui="true">
          <div class="block stack admin-login" id="adminLoginPanel">
            <h3>Admin Sign In</h3>
            <div class="muted">Sign in first to unlock admin actions.</div>
            <div>
              <label for="adminUserInput">Admin Username</label>
              <input id="adminUserInput" type="email" placeholder="Trimbledustn@gmail.com" />
            </div>
            <div>
              <label for="adminPassInput">Admin Password</label>
              <input id="adminPassInput" type="password" placeholder="Admin password" />
            </div>
            <button id="adminLoginBtn" class="secondary">Sign In Admin</button>
          </div>

          <div class="block stack admin-tools hidden" id="adminToolsPanel" data-start-collapsed="1">
            <h3>Admin Tools</h3>
            <div class="muted" id="adminWhoami">Admin: not signed in</div>
            <div class="admin-accordion">
              <details class="dropdown" open>
                <summary>Admin Session</summary>
                <div class="stack" style="margin-top:8px">
                  <div>
                    <label for="adminKeyInput">Admin Code</label>
                    <input id="adminKeyInput" type="password" placeholder="Required for protected options" />
                  </div>
                  <div class="row">
                    <button id="refreshAdminsBtn" class="secondary">Refresh Admins</button>
                    <button id="adminLogoutBtn" class="secondary">Sign Out</button>
                  </div>
                </div>
              </details>

              <details class="dropdown">
                <summary>Admin Accounts</summary>
                <div class="stack" style="margin-top:8px">
                  <div>
                    <label for="newAdminUserInput">Add Admin Username</label>
                    <input id="newAdminUserInput" type="email" placeholder="newadmin@email.com" />
                  </div>
                  <div>
                    <label for="newAdminPassInput">Add Admin Password</label>
                    <input id="newAdminPassInput" type="password" placeholder="At least 8 characters" />
                  </div>
                  <button id="addAdminBtn" class="secondary">Add / Update Admin</button>
                  <div>
                    <label for="adminListSelect">Admin Accounts</label>
                    <select id="adminListSelect"></select>
                  </div>
                  <button id="removeAdminBtn" class="danger-btn">Remove Selected Admin</button>
                </div>
              </details>

              <details class="dropdown">
                <summary>Security Block Lists</summary>
                <div class="stack" style="margin-top:8px">
                  <div class="row">
                    <input id="blockUserInput" type="email" placeholder="user@email.com" />
                    <input id="blockIpInput" placeholder="IP address" />
                  </div>
                  <input id="blockReasonInput" placeholder="Reason (optional)" />
                  <div class="row">
                    <button id="blockUserBtn" class="danger-btn">Block User</button>
                    <button id="unblockUserBtn" class="secondary">Unblock User</button>
                  </div>
                  <div class="row">
                    <button id="blockIpBtn" class="danger-btn">Block IP</button>
                    <button id="unblockIpBtn" class="secondary">Unblock IP</button>
                  </div>
                  <div class="row">
                    <select id="blockedUsersSelect"></select>
                    <select id="blockedIpsSelect"></select>
                  </div>
                  <button id="refreshBlocksBtn" class="secondary">Refresh Blocks</button>
                </div>
              </details>

              <details class="dropdown">
                <summary>Donation Tier Controls</summary>
                <div class="stack" style="margin-top:8px">
                  <div class="muted">Grant premium options by donation tier (manual until payment setup).</div>
                  <div class="row">
                    <input id="tierUserInput" type="email" placeholder="user@email.com" />
                    <select id="tierLevelSelect">
                      <option value="free">Free</option>
                      <option value="supporter">Supporter</option>
                      <option value="pro">Pro</option>
                    </select>
                  </div>
                  <div class="row">
                    <button id="setTierBtn" class="secondary">Set Tier</button>
                    <button id="getTierBtn" class="secondary">Get Tier</button>
                  </div>
                  <div id="tierResult" class="muted">Tier status: n/a</div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </section>

      <section class="card stack">
        <div class="row">
          <h2 id="nowTitle">Now Playing</h2>
          <div class="status-strip">
            <span class="count-pill" id="connState">Not connected</span>
            <span class="status-chip" id="liveChip">Not Live</span>
            <span class="status-chip" id="shareChip">Not Sharing</span>
            <span class="status-chip" id="fullChip">Room Open</span>
            <span class="status-chip" id="latencyChip" data-advanced-ui="true">Latency --</span>
            <span class="status-chip" id="driftChip" data-advanced-ui="true">Drift --</span>
            <span class="status-chip" id="reconnectChip" data-advanced-ui="true">Reconnects 0</span>
          </div>
        </div>
        <div id="sceneBoard" class="scene-board">
          <div class="scene-card" data-scene-card="open" draggable="true">
            <div class="scene-head">Open Parties <span class="drag-handle">Drag</span></div>
            <div class="muted">Showing only active parties.</div>
            <div id="openPartiesList" class="open-party-list"></div>
          </div>

          <div class="scene-card" data-scene-card="stage" draggable="true">
            <div class="scene-head">Stage <span class="drag-handle">Drag</span></div>
            <div class="stage">
              <div style="position:relative">
                <video id="player" controls playsinline></video>
                <div id="reactionOverlay" class="reaction-overlay"></div>
              </div>
              <video id="screenView" controls autoplay playsinline muted></video>
              <div class="family-lounge">
                <h3 style="margin:0">Family Lounge Voice + Webcam</h3>
                <div id="voiceStatus" class="muted">Voice: off</div>
                <div id="webcamStatus" class="muted">Webcam: off</div>
                <div id="shareSourceInfo" class="muted">Selected share source: none</div>
                <div id="shareAudioInfo" class="muted">Selected share audio: none</div>
                <div class="media-device-panel">
                  <div class="row">
                    <div>
                      <label for="micDeviceSelect">Microphone</label>
                      <select id="micDeviceSelect"></select>
                    </div>
                    <div>
                      <label for="camDeviceSelect">Webcam</label>
                      <select id="camDeviceSelect"></select>
                    </div>
                  </div>
                  <div class="row">
                    <div>
                      <label for="voiceQualitySelect">Voice Quality</label>
                      <select id="voiceQualitySelect">
                        <option value="voice">Voice Clear (Noise Reduction)</option>
                        <option value="cinema">Studio Wide (High Fidelity)</option>
                      </select>
                    </div>
                    <div>
                      <label for="liveWebcamQualitySelect">Webcam Quality</label>
                      <select id="liveWebcamQualitySelect">
                        <option value="high">High (1080p)</option>
                        <option value="ultra">Ultra (1440p)</option>
                        <option value="balanced">Balanced (720p)</option>
                      </select>
                    </div>
                    <div style="align-self:end">
                      <button id="refreshDevicesBtn" class="secondary">Refresh Devices</button>
                    </div>
                  </div>
                </div>
                <details class="dropdown" data-host-only="true">
                  <summary>Host Preview (What Viewers See)</summary>
                  <div class="stack" style="margin-top:8px">
                    <div id="hostPreviewInfo" class="muted">Preview source: none</div>
                    <video id="hostPreview" playsinline autoplay muted class="hidden-media"></video>
                  </div>
                </details>
                <div class="row" data-host-only="true">
                  <select id="webcamPolicySelect">
                    <option value="allow">Allow participant webcams</option>
                    <option value="deny">Block participant webcams</option>
                  </select>
                  <button id="setWebcamPolicyBtn" class="secondary">Apply Webcam Policy</button>
                </div>
                <div class="row">
                  <button id="joinVoiceBtn" class="secondary">Join Voice</button>
                  <button id="leaveVoiceBtn" class="secondary" disabled>Leave Voice</button>
                </div>
                <div class="row">
                  <button id="startWebcamBtn" class="secondary">Start Webcam</button>
                  <button id="stopWebcamBtn" class="secondary" disabled>Stop Webcam</button>
                </div>
                <div class="webcam-stage">
                  <div class="webcam-stage-box webcam-stage-local">
                    <div class="webcam-stage-label">Your Webcam</div>
                    <video id="localWebcamPreview" playsinline autoplay muted class="hidden-media"></video>
                  </div>
                  <div class="webcam-stage-box">
                    <div class="webcam-stage-label">Family Webcam Grid</div>
                    <div id="remoteWebcamGrid" class="webcam-grid hidden-media"></div>
                  </div>
                </div>
                <div class="row" data-host-only="true">
                  <select id="muteTargetSelect"></select>
                  <button id="muteTargetBtn" class="secondary">Mute</button>
                  <button id="unmuteTargetBtn" class="secondary">Unmute</button>
                </div>
                <div class="row" data-host-only="true">
                  <select id="kickTargetSelect"></select>
                  <button id="kickTargetBtn" class="danger-btn">Kick User</button>
                </div>
              </div>
              <div class="reaction-bar">
                <button class="reaction-btn" data-react="ðŸ”¥">ðŸ”¥</button>
                <button class="reaction-btn" data-react="ðŸ˜‚">ðŸ˜‚</button>
                <button class="reaction-btn" data-react="ðŸ‘">ðŸ‘</button>
                <button class="reaction-btn" data-react="â¤ï¸">â¤ï¸</button>
                <button class="reaction-btn" data-react="ðŸ˜®">ðŸ˜®</button>
              </div>
              <div class="row">
                <button id="playBtn" class="secondary">Play</button>
                <button id="pauseBtn" class="secondary">Pause</button>
                <button id="resyncBtn" class="secondary">Force Re-sync</button>
              </div>
            </div>
          </div>

          <div class="scene-card" data-scene-card="community" draggable="true">
            <div class="scene-head">Community <span class="drag-handle">Drag</span></div>
            <div class="duo community-layout">
              <div class="block stack">
                <h3>Participants</h3>
                <div id="participantsGrid" class="participants-grid"></div>
                <div id="eventsBlock" data-advanced-ui="true">
                  <h3>Events</h3>
                  <div class="muted">Playback and system events for this room.</div>
                  <div id="events" class="events"></div>
                </div>
              </div>
            <div class="block admin-delete" data-start-collapsed="1">
              <h3>Admin Console</h3>
                <div class="muted">Open the dedicated admin dashboard for room deletes and account management.</div>
                <div id="adminRoomsBlock" class="hidden" style="margin-top:8px" data-advanced-ui="true">
                  <label for="adminRoomsSelect">Active Rooms (Auto-detected)</label>
                  <select id="adminRoomsSelect"></select>
                  <div id="adminRoomsMeta" class="admin-room-meta"></div>
                  <div class="row" style="margin-top:8px">
                    <button id="copyAdminRoomBtn" class="secondary">Copy Code</button>
                  </div>
                </div>
                <div style="height:8px"></div>
                <a href="/telewatch/admin/" id="openAdminConsole">Open Admin Console</a>
              </div>
              <div class="message-center community-chat-panel">
                <div class="message-top">
                  <h3>Room Messages</h3>
                  <span id="chatCount" class="chat-count">0 messages</span>
                </div>
                <div class="muted">Room-only live chat.</div>
                <div id="pinnedChat" class="pinned-box">No pinned message</div>
                <div id="chatFeed" class="chat-feed"></div>
                <div class="chat-compose">
                  <textarea id="chatInput" placeholder="Message the room..."></textarea>
                  <button id="chatBtn" class="secondary">Send</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <div class="footer">
      This sync layer coordinates playback timing only. It does not rebroadcast protected streams.
      <a href="/">Back to FrenzyNets</a>
    </div>
  </div>

  <script defer src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
  <script>
    const API_PREFIXES = [
      'https://api.frenzynets.com',
      '/api/telewatch',
      'https://api.frenzynets.com/api/telewatch'
    ];
    const POLL_RETRY_MS = 1200;
    const LONG_POLL_WAIT_MS = 20000;
    const RTC_CFG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const els = {
      displayName: document.getElementById('displayName'),
      roomInput: document.getElementById('roomInput'),
      inviteInput: document.getElementById('inviteInput'),
      clientModeSelect: document.getElementById('clientModeSelect'),
      openDesktopBtn: document.getElementById('openDesktopBtn'),
      downloadDesktopBtn: document.getElementById('downloadDesktopBtn'),
      uiModeSelect: document.getElementById('uiModeSelect'),
      layoutModeSelect: document.getElementById('layoutModeSelect'),
      densitySelect: document.getElementById('densitySelect'),
      macroStartBtn: document.getElementById('macroStartBtn'),
      macroIntermissionBtn: document.getElementById('macroIntermissionBtn'),
      macroWrapBtn: document.getElementById('macroWrapBtn'),
      macroMainEventBtn: document.getElementById('macroMainEventBtn'),
      macroMainEventOffBtn: document.getElementById('macroMainEventOffBtn'),
      mainEventState: document.getElementById('mainEventState'),
      templateSelect: document.getElementById('templateSelect'),
      saveTemplateBtn: document.getElementById('saveTemplateBtn'),
      applyTemplateBtn: document.getElementById('applyTemplateBtn'),
      quickHostBtn: document.getElementById('quickHostBtn'),
      recentJoinBtn: document.getElementById('recentJoinBtn'),
      recentRoomsSelect: document.getElementById('recentRoomsSelect'),
      accountGuestWrap: document.getElementById('accountGuestWrap'),
      accountUserWrap: document.getElementById('accountUserWrap'),
      userEmailInput: document.getElementById('userEmailInput'),
      userPassInput: document.getElementById('userPassInput'),
      userDisplayInput: document.getElementById('userDisplayInput'),
      forgotPassBtn: document.getElementById('forgotPassBtn'),
      userLoginBtn: document.getElementById('userLoginBtn'),
      userRegisterBtn: document.getElementById('userRegisterBtn'),
      userBadge: document.getElementById('userBadge'),
      saveRoomBtn: document.getElementById('saveRoomBtn'),
      userLogoutBtn: document.getElementById('userLogoutBtn'),
      savedRoomsSelect: document.getElementById('savedRoomsSelect'),
      joinSavedRoomBtn: document.getElementById('joinSavedRoomBtn'),
      removeSavedRoomBtn: document.getElementById('removeSavedRoomBtn'),
      requestQueueSelect: document.getElementById('requestQueueSelect'),
      requestResolveNote: document.getElementById('requestResolveNote'),
      approveRequestBtn: document.getElementById('approveRequestBtn'),
      denyRequestBtn: document.getElementById('denyRequestBtn'),
      adminKeyInput: document.getElementById('adminKeyInput'),
      adminUserInput: document.getElementById('adminUserInput'),
      adminPassInput: document.getElementById('adminPassInput'),
      adminLoginBtn: document.getElementById('adminLoginBtn'),
      adminWhoami: document.getElementById('adminWhoami'),
      adminLoginPanel: document.getElementById('adminLoginPanel'),
      adminToolsPanel: document.getElementById('adminToolsPanel'),
      newAdminUserInput: document.getElementById('newAdminUserInput'),
      newAdminPassInput: document.getElementById('newAdminPassInput'),
      addAdminBtn: document.getElementById('addAdminBtn'),
      refreshAdminsBtn: document.getElementById('refreshAdminsBtn'),
      removeAdminBtn: document.getElementById('removeAdminBtn'),
      adminLogoutBtn: document.getElementById('adminLogoutBtn'),
      adminListSelect: document.getElementById('adminListSelect'),
      blockUserInput: document.getElementById('blockUserInput'),
      blockIpInput: document.getElementById('blockIpInput'),
      blockReasonInput: document.getElementById('blockReasonInput'),
      blockUserBtn: document.getElementById('blockUserBtn'),
      unblockUserBtn: document.getElementById('unblockUserBtn'),
      blockIpBtn: document.getElementById('blockIpBtn'),
      unblockIpBtn: document.getElementById('unblockIpBtn'),
      blockedUsersSelect: document.getElementById('blockedUsersSelect'),
      blockedIpsSelect: document.getElementById('blockedIpsSelect'),
      refreshBlocksBtn: document.getElementById('refreshBlocksBtn'),
      tierUserInput: document.getElementById('tierUserInput'),
      tierLevelSelect: document.getElementById('tierLevelSelect'),
      setTierBtn: document.getElementById('setTierBtn'),
      getTierBtn: document.getElementById('getTierBtn'),
      tierResult: document.getElementById('tierResult'),
      titleInput: document.getElementById('titleInput'),
      mediaInput: document.getElementById('mediaInput'),
      advancedToggleBtn: document.getElementById('advancedToggleBtn'),
      advancedWrap: document.getElementById('advancedWrap'),
      hostTabPane: document.getElementById('hostTabPane'),
      hostOptionsWrap: document.getElementById('hostOptionsWrap'),
      hostOptionsToggleBtn: document.getElementById('hostOptionsToggleBtn'),
      joinVoiceBtn: document.getElementById('joinVoiceBtn'),
      leaveVoiceBtn: document.getElementById('leaveVoiceBtn'),
      voiceStatus: document.getElementById('voiceStatus'),
      webcamStatus: document.getElementById('webcamStatus'),
      micDeviceSelect: document.getElementById('micDeviceSelect'),
      camDeviceSelect: document.getElementById('camDeviceSelect'),
      refreshDevicesBtn: document.getElementById('refreshDevicesBtn'),
      voiceQualitySelect: document.getElementById('voiceQualitySelect'),
      liveWebcamQualitySelect: document.getElementById('liveWebcamQualitySelect'),
      shareSourceInfo: document.getElementById('shareSourceInfo'),
      shareAudioInfo: document.getElementById('shareAudioInfo'),
      hostPreviewInfo: document.getElementById('hostPreviewInfo'),
      hostPreview: document.getElementById('hostPreview'),
      shareQualitySelect: document.getElementById('shareQualitySelect'),
      movieQualitySelect: document.getElementById('movieQualitySelect'),
      webcamQualitySelect: document.getElementById('webcamQualitySelect'),
      audioProfileSelect: document.getElementById('audioProfileSelect'),
      mediaModeSelect: document.getElementById('mediaModeSelect'),
      cohostKickPerm: document.getElementById('cohostKickPerm'),
      cohostMutePerm: document.getElementById('cohostMutePerm'),
      cohostAccessPerm: document.getElementById('cohostAccessPerm'),
      cohostPinPerm: document.getElementById('cohostPinPerm'),
      setCohostPermsBtn: document.getElementById('setCohostPermsBtn'),
      webcamPolicySelect: document.getElementById('webcamPolicySelect'),
      setWebcamPolicyBtn: document.getElementById('setWebcamPolicyBtn'),
      startWebcamBtn: document.getElementById('startWebcamBtn'),
      stopWebcamBtn: document.getElementById('stopWebcamBtn'),
      localWebcamPreview: document.getElementById('localWebcamPreview'),
      remoteWebcamGrid: document.getElementById('remoteWebcamGrid'),
      muteTargetSelect: document.getElementById('muteTargetSelect'),
      muteTargetBtn: document.getElementById('muteTargetBtn'),
      unmuteTargetBtn: document.getElementById('unmuteTargetBtn'),
      kickTargetSelect: document.getElementById('kickTargetSelect'),
      kickTargetBtn: document.getElementById('kickTargetBtn'),
      shareSurfaceSelect: document.getElementById('shareSurfaceSelect'),
      shareAudioSelect: document.getElementById('shareAudioSelect'),
      accessModeSelect: document.getElementById('accessModeSelect'),
      setAccessModeBtn: document.getElementById('setAccessModeBtn'),
      inviteTtlInput: document.getElementById('inviteTtlInput'),
      inviteMaxUsesInput: document.getElementById('inviteMaxUsesInput'),
      invitePresetButtons: Array.from(document.querySelectorAll('.invite-preset-btn')),
      joinRequestSelect: document.getElementById('joinRequestSelect'),
      approveJoinBtn: document.getElementById('approveJoinBtn'),
      denyJoinBtn: document.getElementById('denyJoinBtn'),
      createBtn: document.getElementById('createBtn'),
      joinBtn: document.getElementById('joinBtn'),
      setMediaBtn: document.getElementById('setMediaBtn'),
      copyLinkBtn: document.getElementById('copyLinkBtn'),
      startShareBtn: document.getElementById('startShareBtn'),
      stopShareBtn: document.getElementById('stopShareBtn'),
      resetRoomBtn: document.getElementById('resetRoomBtn'),
      deleteRoomBtn: document.getElementById('deleteRoomBtn'),
      chatInput: document.getElementById('chatInput'),
      requestTypeSelect: document.getElementById('requestTypeSelect'),
      requestTextInput: document.getElementById('requestTextInput'),
      sendRequestBtn: document.getElementById('sendRequestBtn'),
      chatBtn: document.getElementById('chatBtn'),
      playBtn: document.getElementById('playBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      resyncBtn: document.getElementById('resyncBtn'),
      roomBadge: document.getElementById('roomBadge'),
      roleBadge: document.getElementById('roleBadge'),
      syncBadge: document.getElementById('syncBadge'),
      themeSelect: document.getElementById('themeSelect'),
      connState: document.getElementById('connState'),
      liveChip: document.getElementById('liveChip'),
      shareChip: document.getElementById('shareChip'),
      fullChip: document.getElementById('fullChip'),
      latencyChip: document.getElementById('latencyChip'),
      driftChip: document.getElementById('driftChip'),
      reconnectChip: document.getElementById('reconnectChip'),
      openPartiesList: document.getElementById('openPartiesList'),
      sideRooms: document.getElementById('sideRooms'),
      sideVoice: document.getElementById('sideVoice'),
      sideParticipants: document.getElementById('sideParticipants'),
      sceneBoard: document.getElementById('sceneBoard'),
      sceneCards: Array.from(document.querySelectorAll('[data-scene-card]')),
      adminRoomsBlock: document.getElementById('adminRoomsBlock'),
      adminRoomsSelect: document.getElementById('adminRoomsSelect'),
      adminRoomsMeta: document.getElementById('adminRoomsMeta'),
      pinnedChat: document.getElementById('pinnedChat'),
      copyAdminRoomBtn: document.getElementById('copyAdminRoomBtn'),
      nowTitle: document.getElementById('nowTitle'),
      reactionOverlay: document.getElementById('reactionOverlay'),
      reactionButtons: Array.from(document.querySelectorAll('.reaction-btn')),
      participantsGrid: document.getElementById('participantsGrid'),
      events: document.getElementById('events'),
      eventsBlock: document.getElementById('eventsBlock'),
      chatFeed: document.getElementById('chatFeed'),
      chatCount: document.getElementById('chatCount'),
      player: document.getElementById('player'),
      screenView: document.getElementById('screenView'),
      stepSession: document.getElementById('stepSession'),
      stepRoom: document.getElementById('stepRoom'),
      stepShare: document.getElementById('stepShare'),
      joinHint: document.getElementById('joinHint'),
      tabButtons: Array.from(document.querySelectorAll('[data-tab-btn]')),
      tabPanes: Array.from(document.querySelectorAll('[data-tab-pane]'))
    };

    const state = {
      roomCode: '',
      participantToken: '',
      participantId: '',
      participants: [],
      adminToken: '',
      adminUsername: '',
      isHost: false,
      sinceEventId: 0,
      pollLoopActive: false,
      suppressOutbound: false,
      lastSeekSentAt: 0,
      lastRoom: null,
      hostMuted: {},
      adminRooms: [],
      requests: [],
      roomThemeKey: 'clean',
      localThemeKey: 'clean',
      accessMode: 'public',
      pendingJoinRequests: [],
      pendingJoinToken: '',
      inviteToken: '',
      autoRejoinTried: false,
      clientMode: 'web',
      allowWebcam: true,
      mediaMode: 'webrtc',
      mainEventEnabled: false,
      sfuEnabled: false,
      sfuUrl: '',
      chatScopeRoom: '',
      chatMessages: new Map(),
      pinnedMessageId: 0,
      reconnectCount: 0,
      lastPollLatencyMs: 0,
      cohostPerms: { kick: true, mute: true, access: true, pin: true },
      layoutMode: 'standard',
      densityMode: 'comfortable',
      uiMode: 'easy',
      hostOptionsMinimized: false,
      preferredMicId: '',
      preferredCamId: '',
      userToken: '',
      userEmail: '',
      userDisplayName: '',
      donationTier: 'free',
      savedRooms: []
    };
    const SESSION_KEY = 'telewatch_session';
    const ADMIN_SESSION_KEY = 'telewatch_admin_session';
    const RECENT_ROOMS_KEY = 'telewatch_recent_rooms';
    const THEME_KEY = 'telewatch_theme';
    const JOIN_REQUEST_KEY = 'telewatch_join_request';
    const INVITE_SETTINGS_KEY = 'telewatch_invite_settings';
    const CLIENT_MODE_KEY = 'telewatch_client_mode';
    const SCENE_ORDER_KEY = 'telewatch_scene_order';
    const LAYOUT_MODE_KEY = 'telewatch_layout_mode';
    const DENSITY_MODE_KEY = 'telewatch_density_mode';
    const ROOM_TEMPLATE_KEY = 'telewatch_room_templates_v1';
    const USER_SESSION_KEY = 'telewatch_user_session_v1';
    const UI_MODE_KEY = 'telewatch_ui_mode';
    const HOST_OPTIONS_MIN_KEY = 'telewatch_host_options_min';
    const MIC_DEVICE_KEY = 'telewatch_mic_device_id';
    const CAM_DEVICE_KEY = 'telewatch_cam_device_id';
    const ROOM_CAPACITY_LIMIT = 50;

    const THEMES = {
      clean: {
        label: 'Clean Default',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/clean-default.svg')",
          '--bg-graphic-opacity': '0.58',
          '--bg-gradient': 'linear-gradient(180deg, #f8f9fc, #f3f6fa)',
          '--panel': '#ffffff',
          '--panel-2': '#fbfcfe',
          '--line': '#dbe2ea',
          '--line-soft': '#e9eef4',
          '--text': '#18212c',
          '--muted': '#6a7787',
          '--accent': '#ff5f1f',
          '--accent-strong': '#e04d11',
          '--pill-bg': '#f8fafc',
          '--pill-line': '#dbe2ea',
          '--pill-text': '#314155',
          '--input-bg': '#ffffff',
          '--input-line': '#d1dae5',
          '--input-focus': '#ff925f',
          '--input-focus-glow': 'rgba(255, 95, 31, 0.15)',
          '--tab-active-bg': '#fff3ec',
          '--tab-active-text': '#a43f12',
          '--tab-active-line': '#ff925f'
        }
      },
      anime_sakura: {
        label: 'Anime Sakura',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-sakura.svg')",
          '--bg-graphic-opacity': '0.74',
          '--bg-gradient': 'linear-gradient(160deg, #fff6fb, #ffe2f2 45%, #ffd7ea)',
          '--panel': '#fff7fb',
          '--panel-2': '#fff1f8',
          '--line': '#f3c5df',
          '--line-soft': '#f8d8e9',
          '--text': '#431f35',
          '--muted': '#8f5f77',
          '--accent': '#ff4f9a',
          '--accent-strong': '#d9317c',
          '--pill-bg': '#ffeef8',
          '--pill-line': '#f4bddc',
          '--pill-text': '#6e2f51',
          '--input-bg': '#fffafd',
          '--input-line': '#efbad8',
          '--input-focus': '#ff4f9a',
          '--input-focus-glow': 'rgba(255, 79, 154, 0.25)',
          '--tab-active-bg': '#ffe7f3',
          '--tab-active-text': '#8f2459',
          '--tab-active-line': '#ff4f9a'
        }
      },
      blossom_garden: {
        label: 'Blossom Garden',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/blossom-garden.svg')",
          '--bg-graphic-opacity': '0.74',
          '--bg-gradient': 'linear-gradient(160deg, #fff6fb, #ffe2f2 45%, #ffd7ea)',
          '--panel': '#fff7fb',
          '--panel-2': '#fff1f8',
          '--line': '#f3c5df',
          '--line-soft': '#f8d8e9',
          '--text': '#431f35',
          '--muted': '#8f5f77',
          '--accent': '#ff4f9a',
          '--accent-strong': '#d9317c',
          '--pill-bg': '#ffeef8',
          '--pill-line': '#f4bddc',
          '--pill-text': '#6e2f51',
          '--input-bg': '#fffafd',
          '--input-line': '#efbad8',
          '--input-focus': '#ff4f9a',
          '--input-focus-glow': 'rgba(255, 79, 154, 0.25)',
          '--tab-active-bg': '#ffe7f3',
          '--tab-active-text': '#8f2459',
          '--tab-active-line': '#ff4f9a'
        }
      },
      anime_city_lights: {
        label: 'Anime City Lights',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-city-lights.svg')",
          '--bg-graphic-opacity': '0.7',
          '--bg-gradient': 'linear-gradient(155deg, #f2d8ff, #b792ff 45%, #33245f)',
          '--panel': '#2a2350',
          '--panel-2': '#332b5e',
          '--line': '#5a4d8c',
          '--line-soft': '#4a3f76',
          '--text': '#f3ecff',
          '--muted': '#c0b2e3',
          '--accent': '#ff78c9',
          '--accent-strong': '#d253a3',
          '--pill-bg': '#3a2f67',
          '--pill-line': '#6655a0',
          '--pill-text': '#f5e9ff',
          '--input-bg': '#2a2350',
          '--input-line': '#64569c',
          '--input-focus': '#ff78c9',
          '--input-focus-glow': 'rgba(255, 120, 201, 0.28)',
          '--tab-active-bg': '#4a3d7b',
          '--tab-active-text': '#ffe3f4',
          '--tab-active-line': '#ff78c9'
        }
      },
      anime_rain_alley: {
        label: 'Anime Rain Alley',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-rain-alley.svg')",
          '--bg-graphic-opacity': '0.68',
          '--bg-gradient': 'linear-gradient(145deg, #24355a, #1a2745 50%, #131b31)',
          '--panel': '#1d2948',
          '--panel-2': '#233154',
          '--line': '#445e8c',
          '--line-soft': '#354e77',
          '--text': '#eaf2ff',
          '--muted': '#abc0e2',
          '--accent': '#2be8ff',
          '--accent-strong': '#1db2c6',
          '--pill-bg': '#253559',
          '--pill-line': '#4b6798',
          '--pill-text': '#dff8ff',
          '--input-bg': '#1f2c4d',
          '--input-line': '#4d699a',
          '--input-focus': '#2be8ff',
          '--input-focus-glow': 'rgba(43, 232, 255, 0.24)',
          '--tab-active-bg': '#2e4670',
          '--tab-active-text': '#d9f8ff',
          '--tab-active-line': '#2be8ff'
        }
      },
      anime_classroom_sunset: {
        label: 'Anime Classroom Sunset',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-classroom-sunset.svg')",
          '--bg-graphic-opacity': '0.66',
          '--bg-gradient': 'linear-gradient(150deg, #ffd9b5, #ffb58f 55%, #ff8b80)',
          '--panel': '#fff2e8',
          '--panel-2': '#ffe8db',
          '--line': '#e7baa0',
          '--line-soft': '#f2cbb4',
          '--text': '#5b3029',
          '--muted': '#9a6659',
          '--accent': '#ff7f6c',
          '--accent-strong': '#d65e4f',
          '--pill-bg': '#ffe9db',
          '--pill-line': '#e9bea4',
          '--pill-text': '#6c3f34',
          '--input-bg': '#fff7f1',
          '--input-line': '#e8b59a',
          '--input-focus': '#ff7f6c',
          '--input-focus-glow': 'rgba(255, 127, 108, 0.24)',
          '--tab-active-bg': '#ffd7c9',
          '--tab-active-text': '#9a3f34',
          '--tab-active-line': '#ff7f6c'
        }
      },
      anime_night: {
        label: 'Anime Night',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/anime-night.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'radial-gradient(circle at 15% 10%, #2f2153, #141028 45%, #0b0a16)',
          '--panel': '#1b1730',
          '--panel-2': '#231b3d',
          '--line': '#3d3562',
          '--line-soft': '#302a4f',
          '--text': '#f2edff',
          '--muted': '#b7abd9',
          '--accent': '#ff66c9',
          '--accent-strong': '#c74797',
          '--pill-bg': '#272044',
          '--pill-line': '#3f3565',
          '--pill-text': '#f4e8ff',
          '--input-bg': '#19152d',
          '--input-line': '#433864',
          '--input-focus': '#ff66c9',
          '--input-focus-glow': 'rgba(255, 102, 201, 0.3)',
          '--tab-active-bg': '#362a58',
          '--tab-active-text': '#ffd1f0',
          '--tab-active-line': '#ff66c9'
        }
      },
      cyberpunk: {
        label: 'Cyberpunk Neon',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/cyberpunk-neon.svg')",
          '--bg-graphic-opacity': '0.54',
          '--bg-gradient': 'linear-gradient(140deg, #07090f, #120a26 45%, #061a1e)',
          '--panel': '#121624',
          '--panel-2': '#161b2c',
          '--line': '#2f3d59',
          '--line-soft': '#253048',
          '--text': '#eaf4ff',
          '--muted': '#93a9bf',
          '--accent': '#08f7fe',
          '--accent-strong': '#09b5ba',
          '--pill-bg': '#101c2d',
          '--pill-line': '#204861',
          '--pill-text': '#abf9ff',
          '--input-bg': '#0f1523',
          '--input-line': '#2e4569',
          '--input-focus': '#08f7fe',
          '--input-focus-glow': 'rgba(8, 247, 254, 0.25)',
          '--tab-active-bg': '#13263a',
          '--tab-active-text': '#8efeff',
          '--tab-active-line': '#08f7fe'
        }
      },
      ocean: {
        label: 'Ocean Breeze',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/ocean-breeze.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(160deg, #e5f7ff, #d6f0ff 45%, #c0e8fa)',
          '--panel': '#f7fcff',
          '--panel-2': '#eef8fc',
          '--line': '#b9dcea',
          '--line-soft': '#cfe9f2',
          '--text': '#173444',
          '--muted': '#567789',
          '--accent': '#0098d8',
          '--accent-strong': '#0076ab',
          '--pill-bg': '#ebf8ff',
          '--pill-line': '#b2d9ea',
          '--pill-text': '#205068',
          '--input-bg': '#fbfdff',
          '--input-line': '#a9d0e0',
          '--input-focus': '#0098d8',
          '--input-focus-glow': 'rgba(0, 152, 216, 0.2)',
          '--tab-active-bg': '#deeff8',
          '--tab-active-text': '#005985',
          '--tab-active-line': '#0098d8'
        }
      },
      forest: {
        label: 'Forest Camp',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/forest-camp.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(145deg, #e7f3df, #d3e8c2 50%, #c2ddad)',
          '--panel': '#f4f9ef',
          '--panel-2': '#edf5e5',
          '--line': '#c6d9b0',
          '--line-soft': '#d7e6c6',
          '--text': '#2b4122',
          '--muted': '#627956',
          '--accent': '#4f8a2f',
          '--accent-strong': '#3b6d20',
          '--pill-bg': '#edf6e4',
          '--pill-line': '#c0d7a8',
          '--pill-text': '#365227',
          '--input-bg': '#f7fbf2',
          '--input-line': '#b8d09d',
          '--input-focus': '#4f8a2f',
          '--input-focus-glow': 'rgba(79, 138, 47, 0.2)',
          '--tab-active-bg': '#e2efd6',
          '--tab-active-text': '#2d4f1b',
          '--tab-active-line': '#4f8a2f'
        }
      },
      sunset: {
        label: 'Sunset Glow',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/sunset-glow.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(150deg, #fff1da, #ffd6bf 45%, #ffc0b9)',
          '--panel': '#fff8ef',
          '--panel-2': '#fff3e8',
          '--line': '#f2ccae',
          '--line-soft': '#f8dfcc',
          '--text': '#4a2e21',
          '--muted': '#8f6350',
          '--accent': '#ff6a3d',
          '--accent-strong': '#d94b20',
          '--pill-bg': '#fff0e3',
          '--pill-line': '#efc8aa',
          '--pill-text': '#6a3f2d',
          '--input-bg': '#fffaf4',
          '--input-line': '#ebc3a5',
          '--input-focus': '#ff6a3d',
          '--input-focus-glow': 'rgba(255, 106, 61, 0.2)',
          '--tab-active-bg': '#ffe5d6',
          '--tab-active-text': '#9a3a1f',
          '--tab-active-line': '#ff6a3d'
        }
      },
      nordic_dark: {
        label: 'Nordic Dark',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/nordic-dark.svg')",
          '--bg-graphic-opacity': '0.52',
          '--bg-gradient': 'linear-gradient(155deg, #111827, #0f172a 50%, #1e293b)',
          '--panel': '#172033',
          '--panel-2': '#1d2940',
          '--line': '#334158',
          '--line-soft': '#28364d',
          '--text': '#e7edf7',
          '--muted': '#98a7bd',
          '--accent': '#5aa9ff',
          '--accent-strong': '#3a85d8',
          '--pill-bg': '#1d2a40',
          '--pill-line': '#38506f',
          '--pill-text': '#deebff',
          '--input-bg': '#1a263a',
          '--input-line': '#3d5270',
          '--input-focus': '#5aa9ff',
          '--input-focus-glow': 'rgba(90, 169, 255, 0.2)',
          '--tab-active-bg': '#243855',
          '--tab-active-text': '#cde2ff',
          '--tab-active-line': '#5aa9ff'
        }
      },
      galaxy: {
        label: 'Galaxy Purple',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/galaxy-purple.svg')",
          '--bg-graphic-opacity': '0.54',
          '--bg-gradient': 'radial-gradient(circle at 20% 10%, #39285e, #1a1434 45%, #0e0a1f)',
          '--panel': '#1d1638',
          '--panel-2': '#261d46',
          '--line': '#443a6a',
          '--line-soft': '#342c56',
          '--text': '#f0e9ff',
          '--muted': '#b8a9dd',
          '--accent': '#b574ff',
          '--accent-strong': '#8a47d1',
          '--pill-bg': '#271f47',
          '--pill-line': '#4d4080',
          '--pill-text': '#f0ddff',
          '--input-bg': '#1d1738',
          '--input-line': '#4a3f7d',
          '--input-focus': '#b574ff',
          '--input-focus-glow': 'rgba(181, 116, 255, 0.25)',
          '--tab-active-bg': '#3a2d63',
          '--tab-active-text': '#efd6ff',
          '--tab-active-line': '#b574ff'
        }
      },
      after_dark_neon: {
        label: 'After Dark Neon',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/after-dark-neon.svg')",
          '--bg-graphic-opacity': '0.56',
          '--bg-gradient': 'linear-gradient(145deg, #120b1f, #0b1323 55%, #1a0b1a)',
          '--panel': '#171326',
          '--panel-2': '#1d1730',
          '--line': '#3f3358',
          '--line-soft': '#302748',
          '--text': '#f4efff',
          '--muted': '#b7adcf',
          '--accent': '#ff4e98',
          '--accent-strong': '#d73578',
          '--pill-bg': '#221a35',
          '--pill-line': '#463664',
          '--pill-text': '#f8dbeb',
          '--input-bg': '#19142a',
          '--input-line': '#4a3a69',
          '--input-focus': '#ff4e98',
          '--input-focus-glow': 'rgba(255, 78, 152, 0.26)',
          '--tab-active-bg': '#34254d',
          '--tab-active-text': '#ffd6ea',
          '--tab-active-line': '#ff4e98'
        }
      },
      noir_lounge: {
        label: 'Noir Lounge',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/noir-lounge.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(150deg, #2b1e18, #1d1512 50%, #120f0d)',
          '--panel': '#2a201a',
          '--panel-2': '#31261f',
          '--line': '#5d4a3f',
          '--line-soft': '#463830',
          '--text': '#f8ecd9',
          '--muted': '#cab7a0',
          '--accent': '#d69a59',
          '--accent-strong': '#b77d3e',
          '--pill-bg': '#342920',
          '--pill-line': '#6a5444',
          '--pill-text': '#f2ddc3',
          '--input-bg': '#2a201a',
          '--input-line': '#6e5647',
          '--input-focus': '#d69a59',
          '--input-focus-glow': 'rgba(214, 154, 89, 0.24)',
          '--tab-active-bg': '#463427',
          '--tab-active-text': '#ffe8cb',
          '--tab-active-line': '#d69a59'
        }
      },
      latex_chrome: {
        label: 'Latex Chrome',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/latex-chrome.svg')",
          '--bg-graphic-opacity': '0.56',
          '--bg-gradient': 'linear-gradient(150deg, #0d0d14, #1a1b26 50%, #08090f)',
          '--panel': '#191b25',
          '--panel-2': '#212430',
          '--line': '#464c61',
          '--line-soft': '#353b50',
          '--text': '#eef2ff',
          '--muted': '#b6bed2',
          '--accent': '#cfd9ff',
          '--accent-strong': '#9ca8d6',
          '--pill-bg': '#242836',
          '--pill-line': '#515872',
          '--pill-text': '#f0f5ff',
          '--input-bg': '#181b26',
          '--input-line': '#4f5873',
          '--input-focus': '#cfd9ff',
          '--input-focus-glow': 'rgba(207, 217, 255, 0.22)',
          '--tab-active-bg': '#323a50',
          '--tab-active-text': '#edf2ff',
          '--tab-active-line': '#cfd9ff'
        }
      },
      velvet_red: {
        label: 'Velvet Red',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/velvet-red.svg')",
          '--bg-graphic-opacity': '0.62',
          '--bg-gradient': 'linear-gradient(150deg, #2b0d16, #531729 55%, #1a0a11)',
          '--panel': '#3a1420',
          '--panel-2': '#451828',
          '--line': '#734056',
          '--line-soft': '#5e3044',
          '--text': '#ffe8ef',
          '--muted': '#d1a8b8',
          '--accent': '#ff6f9f',
          '--accent-strong': '#d24b78',
          '--pill-bg': '#4a1c2d',
          '--pill-line': '#84546a',
          '--pill-text': '#ffe5ee',
          '--input-bg': '#3a1420',
          '--input-line': '#86546a',
          '--input-focus': '#ff6f9f',
          '--input-focus-glow': 'rgba(255, 111, 159, 0.26)',
          '--tab-active-bg': '#61263b',
          '--tab-active-text': '#ffe0ea',
          '--tab-active-line': '#ff6f9f'
        }
      },
      retro_arcade: {
        label: 'Retro Arcade',
        vars: {
          '--bg-graphic-image': "url('/assets/themes/retro-arcade.svg')",
          '--bg-graphic-opacity': '0.58',
          '--bg-gradient': 'linear-gradient(150deg, #121212, #1d1230 45%, #072a2a)',
          '--panel': '#1a1a22',
          '--panel-2': '#22222c',
          '--line': '#3b3d4d',
          '--line-soft': '#2d3140',
          '--text': '#f7f7f7',
          '--muted': '#b9bac8',
          '--accent': '#f4ff52',
          '--accent-strong': '#c4ca34',
          '--pill-bg': '#20212a',
          '--pill-line': '#464960',
          '--pill-text': '#f8f9b5',
          '--input-bg': '#181920',
          '--input-line': '#484b60',
          '--input-focus': '#f4ff52',
          '--input-focus-glow': 'rgba(244, 255, 82, 0.22)',
          '--tab-active-bg': '#2f3140',
          '--tab-active-text': '#f8f9b5',
          '--tab-active-line': '#f4ff52'
        }
      }
    };

    const rtc = {
      localScreenStream: null,
      localVoiceStream: null,
      localCamStream: null,
      peers: new Map(),
      pendingCandidates: new Map(),
      offeredTo: new Set(),
      audioEls: new Map(),
      camEls: new Map(),
      voiceOfferedTo: new Set(),
      camOfferedTo: new Set(),
      adaptive: new Map(),
      adaptiveTimer: null
    };
    const sfu = {
      room: null,
      connected: false,
      localScreenTrack: null,
      localScreenAudioTrack: null,
      localVoiceTrack: null,
      localCamTrack: null,
      remoteAudioEls: new Map()
    };
    let openPartyTimer = null;
    let adminRoomsTimer = null;
    let desktopFallbackTimer = null;

    function qp(name) {
      const u = new URL(window.location.href);
      return u.searchParams.get(name) || '';
    }

    function applyClientMode(mode) {
      const clean = String(mode || '').trim().toLowerCase() === 'desktop' ? 'desktop' : 'web';
      state.clientMode = clean;
      if (clean === 'web' && desktopFallbackTimer) {
        clearTimeout(desktopFallbackTimer);
        desktopFallbackTimer = null;
      }
      if (els.clientModeSelect) els.clientModeSelect.value = clean;
      if (els.joinHint) {
        els.joinHint.textContent = clean === 'desktop'
          ? 'Desktop mode selected. Create/join opens the FrenzyNet desktop app.'
          : 'Share your room code in Discord voice chat. Everyone runs their own stream account.';
      }
      try { localStorage.setItem(CLIENT_MODE_KEY, clean); } catch (_) {}
    }

    function openDesktopApp(actionHint) {
      const action = String(actionHint || 'join').trim().toLowerCase();
      const room = normalizeRoomCode(els.roomInput && els.roomInput.value);
      const name = String((els.displayName && els.displayName.value) || '').trim();
      const title = String((els.titleInput && els.titleInput.value) || '').trim();
      if (desktopFallbackTimer) {
        clearTimeout(desktopFallbackTimer);
        desktopFallbackTimer = null;
      }
      const u = new URL('frenzynet://telewatch');
      u.searchParams.set('action', action);
      if (room) u.searchParams.set('room', room);
      if (name) u.searchParams.set('name', name);
      if (title) u.searchParams.set('title', title);
      if (state.inviteToken) u.searchParams.set('invite', String(state.inviteToken));
      let blurred = false;
      const onBlur = () => { blurred = true; };
      window.addEventListener('blur', onBlur, { once: true });
      window.location.href = u.toString();
      setStatus(true, 'Opening desktop app...');
      desktopFallbackTimer = window.setTimeout(() => {
        window.removeEventListener('blur', onBlur);
        desktopFallbackTimer = null;
        if (state.clientMode === 'desktop' && !blurred) {
          applyClientMode('web');
          setStatus(false, 'Desktop app not detected. Switched to web mode.');
        }
      }, 2200);
    }

    function setStatus(ok, text) {
      els.connState.className = 'count-pill ' + (ok ? 'status-online' : 'status-warn');
      els.connState.textContent = text;
    }

    function updateHostPreview() {
      if (!els.hostPreview || !els.hostPreviewInfo) return;
      if (!state.isHost || !state.roomCode) {
        try { els.hostPreview.srcObject = null; } catch (_) {}
        els.hostPreview.removeAttribute('src');
        els.hostPreview.classList.add('hidden-media');
        els.hostPreviewInfo.textContent = 'Preview source: host only';
        return;
      }
      if (rtc.localScreenStream) {
        els.hostPreview.srcObject = rtc.localScreenStream;
        els.hostPreview.classList.remove('hidden-media');
        els.hostPreviewInfo.textContent = 'Preview source: live screen share';
        els.hostPreview.play().catch(() => {});
        return;
      }
      const mediaUrl = String((els.player && els.player.src) || '').trim();
      if (mediaUrl) {
        try { els.hostPreview.srcObject = null; } catch (_) {}
        els.hostPreview.src = mediaUrl;
        els.hostPreview.classList.remove('hidden-media');
        els.hostPreviewInfo.textContent = 'Preview source: media URL player';
        els.hostPreview.play().catch(() => {});
        return;
      }
      try { els.hostPreview.srcObject = null; } catch (_) {}
      els.hostPreview.removeAttribute('src');
      els.hostPreview.classList.add('hidden-media');
      els.hostPreviewInfo.textContent = 'Preview source: none';
    }

    function setSyncLabel(text) {
      els.syncBadge.textContent = 'Sync: ' + text;
    }

    function applyTheme(themeKey, persistLocal) {
      const key = Object.prototype.hasOwnProperty.call(THEMES, themeKey) ? themeKey : 'clean';
      const cfg = THEMES[key];
      for (const [cssVar, val] of Object.entries(cfg.vars)) {
        document.documentElement.style.setProperty(cssVar, val);
      }
      if (els.themeSelect) els.themeSelect.value = key;
      if (persistLocal) {
        state.localThemeKey = key;
        try { localStorage.setItem(THEME_KEY, key); } catch (_) {}
      }
      return key;
    }

    function setThemeControlState() {
      if (!els.themeSelect) return;
      const inRoom = !!state.roomCode;
      if (inRoom && !state.isHost) {
        els.themeSelect.disabled = true;
        els.themeSelect.title = 'Host controls room theme';
      } else {
        els.themeSelect.disabled = false;
        els.themeSelect.title = inRoom ? 'Host room theme control' : 'Personal theme preference';
      }
    }

    function setEventsVisibility() {
      if (!els.eventsBlock) return;
      const isAdmin = !!(state.adminToken && state.adminUsername);
      els.eventsBlock.style.display = isAdmin ? '' : 'none';
    }

    function joinRequestStorageKey(roomCode, displayName) {
      return `${normalizeRoomCode(roomCode)}::${String(displayName || '').trim().toLowerCase()}`;
    }

    function readPendingJoinToken(roomCode, displayName) {
      try {
        const raw = localStorage.getItem(JOIN_REQUEST_KEY) || '{}';
        const map = JSON.parse(raw);
        const key = joinRequestStorageKey(roomCode, displayName);
        return String((map && map[key]) || '').trim();
      } catch (_) {
        return '';
      }
    }

    function writePendingJoinToken(roomCode, displayName, token) {
      try {
        const raw = localStorage.getItem(JOIN_REQUEST_KEY) || '{}';
        const map = JSON.parse(raw) || {};
        const key = joinRequestStorageKey(roomCode, displayName);
        if (token) map[key] = token;
        else delete map[key];
        localStorage.setItem(JOIN_REQUEST_KEY, JSON.stringify(map));
      } catch (_) {}
    }

    function renderJoinRequests() {
      if (!els.joinRequestSelect) return;
      const rows = Array.isArray(state.pendingJoinRequests) ? state.pendingJoinRequests : [];
      els.joinRequestSelect.innerHTML = '';
      if (!rows.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No pending join requests';
        els.joinRequestSelect.appendChild(opt);
        return;
      }
      for (const r of rows) {
        const opt = document.createElement('option');
        opt.value = String(r.requestToken || '');
        opt.textContent = `${String(r.displayName || 'Guest')} Â· ${String(r.createdAt || '')}`;
        els.joinRequestSelect.appendChild(opt);
      }
    }

    function readInviteSettings() {
      let ttlMinutes = 720;
      let maxUses = 0;
      try {
        const raw = localStorage.getItem(INVITE_SETTINGS_KEY) || '';
        if (raw) {
          const parsed = JSON.parse(raw);
          ttlMinutes = Number(parsed.ttlMinutes);
          maxUses = Number(parsed.maxUses);
        }
      } catch (_) {}
      if (!Number.isFinite(ttlMinutes)) ttlMinutes = 720;
      if (!Number.isFinite(maxUses)) maxUses = 0;
      ttlMinutes = Math.max(5, Math.min(10080, Math.round(ttlMinutes)));
      maxUses = Math.max(0, Math.min(500, Math.round(maxUses)));
      return { ttlMinutes, maxUses };
    }

    function writeInviteSettings(ttlMinutes, maxUses) {
      const ttl = Math.max(5, Math.min(10080, Math.round(Number(ttlMinutes) || 720)));
      const uses = Math.max(0, Math.min(500, Math.round(Number(maxUses) || 0)));
      try {
        localStorage.setItem(INVITE_SETTINGS_KEY, JSON.stringify({ ttlMinutes: ttl, maxUses: uses }));
      } catch (_) {}
    }

    function applyInvitePreset(ttlMinutes, maxUses) {
      const ttl = Math.max(5, Math.min(10080, Math.round(Number(ttlMinutes) || 720)));
      const uses = Math.max(0, Math.min(500, Math.round(Number(maxUses) || 0)));
      if (els.inviteTtlInput) els.inviteTtlInput.value = String(ttl);
      if (els.inviteMaxUsesInput) els.inviteMaxUsesInput.value = String(uses);
      writeInviteSettings(ttl, uses);
      setStatus(true, `Invite preset set: ${ttl}m, ${uses === 0 ? 'unlimited uses' : uses + ' uses'}.`);
    }

    async function setRoomTheme(themeKey) {
      const clean = Object.prototype.hasOwnProperty.call(THEMES, themeKey) ? themeKey : 'clean';
      if (!state.roomCode || !state.participantToken || !state.isHost) {
        applyTheme(clean, true);
        return;
      }
      await sendControl('set_theme', { themeKey: clean });
      state.roomThemeKey = clean;
      applyTheme(clean, false);
      setStatus(true, 'Room theme updated: ' + (THEMES[clean]?.label || clean));
    }

    function initThemeSelector() {
      if (!els.themeSelect) return;
      els.themeSelect.innerHTML = '';
      for (const [key, cfg] of Object.entries(THEMES)) {
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = cfg.label;
        els.themeSelect.appendChild(opt);
      }
      const saved = (() => {
        try { return localStorage.getItem(THEME_KEY) || ''; } catch (_) { return ''; }
      })();
      state.localThemeKey = Object.prototype.hasOwnProperty.call(THEMES, saved) ? saved : 'clean';
      applyTheme(state.localThemeKey, true);
      setThemeControlState();
      els.themeSelect.addEventListener('change', async () => {
        const wanted = String(els.themeSelect.value || 'clean');
        if (state.roomCode) {
          if (!state.isHost) {
            applyTheme(state.roomThemeKey || 'clean', false);
            setStatus(false, 'Only host can change room theme.');
            return;
          }
          try {
            await setRoomTheme(wanted);
          } catch (err) {
            applyTheme(state.roomThemeKey || 'clean', false);
            setStatus(false, String(err && err.message ? err.message : err));
          }
          return;
        }
        applyTheme(wanted, true);
      });
    }

    function setWizardStep(step) {
      const idx = Math.max(1, Math.min(3, Number(step) || 1));
      const steps = [els.stepSession, els.stepRoom, els.stepShare];
      for (let i = 0; i < steps.length; i += 1) {
        if (!steps[i]) continue;
        steps[i].classList.toggle('active', i < idx);
      }
    }

    function parseInviteRoom(raw) {
      const txt = String(raw || '').trim();
      if (!txt) return '';
      const direct = normalizeRoomCode(txt);
      if (direct && direct.length >= 3 && !txt.includes('http')) return direct;
      try {
        const u = new URL(txt);
        return normalizeRoomCode(u.searchParams.get('room') || '');
      } catch (_) {
        return '';
      }
    }

    function readRecentRooms() {
      try {
        const raw = localStorage.getItem(RECENT_ROOMS_KEY) || '[]';
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        return arr.map((x) => normalizeRoomCode(x)).filter(Boolean).slice(0, 10);
      } catch (_) {
        return [];
      }
    }

    function renderRecentRooms() {
      if (!els.recentRoomsSelect) return;
      const rooms = readRecentRooms();
      els.recentRoomsSelect.innerHTML = '';
      const first = document.createElement('option');
      first.value = '';
      first.textContent = rooms.length ? 'Select a recent room' : 'No recent rooms yet';
      els.recentRoomsSelect.appendChild(first);
      for (const code of rooms) {
        const opt = document.createElement('option');
        opt.value = code;
        opt.textContent = code;
        els.recentRoomsSelect.appendChild(opt);
      }
    }

    function saveRecentRoom(code) {
      const cleaned = normalizeRoomCode(code);
      if (!cleaned) return;
      const rooms = readRecentRooms().filter((x) => x !== cleaned);
      rooms.unshift(cleaned);
      try { localStorage.setItem(RECENT_ROOMS_KEY, JSON.stringify(rooms.slice(0, 10))); } catch (_) {}
      renderRecentRooms();
    }

    function updateStatusChips(activeCount) {
      if (els.liveChip) {
        const live = Number(activeCount || 0) > 0;
        els.liveChip.textContent = live ? 'Live' : 'Not Live';
        els.liveChip.classList.toggle('ok', live);
      }
      if (els.shareChip) {
        const sharing = !!rtc.localScreenStream;
        els.shareChip.textContent = sharing ? 'Sharing On' : 'Not Sharing';
        els.shareChip.classList.toggle('ok', sharing);
      }
      if (els.fullChip) {
        const full = Number(activeCount || 0) >= ROOM_CAPACITY_LIMIT;
        els.fullChip.textContent = full ? 'Room Full' : 'Room Open';
        els.fullChip.classList.toggle('ok', !full);
      }
    }

    function renderParticipants() {
      if (!els.participantsGrid) return;
      const rows = Array.isArray(state.participants) ? state.participants : [];
      els.participantsGrid.innerHTML = '';
      if (!rows.length) {
        const d = document.createElement('div');
        d.className = 'muted';
        d.textContent = 'No participants yet';
        els.participantsGrid.appendChild(d);
        return;
      }
      for (const p of rows) {
        const card = document.createElement('div');
        card.className = 'participant-card';
        card.dataset.participantId = String(p.participantId || '');
        const mutedByHost = !!state.hostMuted[String(p.participantId || '').toLowerCase()];
        const hasRemoteCam = !!rtc.camEls.get(String(p.participantId || ''));
        const hasLocalCam = !!(p.isSelf && camOn());
        card.innerHTML = `
          <div class="participant-name">${String(p.displayName || 'Guest')}</div>
          <div class="participant-meta">${p.isHost ? 'Host' : (p.isCohost ? 'Co-host' : 'Viewer')}${p.isSelf ? ' Â· You' : ''}</div>
          <div class="participant-meta">${mutedByHost ? 'Muted by host' : 'Unmuted'}</div>
          <div class="participant-meta">${(hasRemoteCam || hasLocalCam) ? 'Webcam on' : 'Webcam off'}</div>
        `;
        if (state.isHost && !p.isSelf) {
          const controls = document.createElement('div');
          controls.className = 'participant-controls';
          controls.innerHTML = `
            <button class="secondary" data-act="mute">Mute</button>
            <button class="secondary" data-act="unmute">Unmute</button>
            <button class="secondary" data-act="cohost">${p.isCohost ? 'Remove Co-host' : 'Make Co-host'}</button>
            <button class="danger-btn" data-act="kick">Kick</button>
          `;
          controls.addEventListener('click', async (ev) => {
            const btn = ev.target && ev.target.closest('button[data-act]');
            if (!btn) return;
            const act = String(btn.getAttribute('data-act') || '');
            const pid = String(p.participantId || '').toLowerCase();
            try {
              if (act === 'mute') await sendControl('mute_user', { toParticipantId: pid, muted: true });
              if (act === 'unmute') await sendControl('mute_user', { toParticipantId: pid, muted: false });
              if (act === 'kick') await sendControl('kick_user', { toParticipantId: pid });
              if (act === 'cohost') await sendControl('set_cohost', { toParticipantId: pid, enabled: !p.isCohost });
            } catch (err) {
              setStatus(false, String(err && err.message ? err.message : err));
            }
          });
          card.appendChild(controls);
        }
        els.participantsGrid.appendChild(card);
      }
      if (state.isHost) {
        const keep = new Set(rows.map((r) => String(r.participantId || '')));
        for (const pid of Array.from(rtc.camEls.keys())) {
          if (!keep.has(pid)) {
            const tile = rtc.camEls.get(pid);
            if (tile) {
              try { tile.video.srcObject = null; tile.wrap.remove(); } catch (_) {}
            }
            rtc.camEls.delete(pid);
          }
        }
        if (els.remoteWebcamGrid) {
          els.remoteWebcamGrid.classList.toggle('hidden-media', rtc.camEls.size < 1);
        }
      }
      renderSideParticipants(rows);
    }

    function renderSideParticipants(rows) {
      if (!els.sideParticipants) return;
      const list = Array.isArray(rows) ? rows : [];
      els.sideParticipants.innerHTML = '';
      if (!list.length) {
        const d = document.createElement('div');
        d.className = 'side-item';
        d.textContent = 'No participants';
        els.sideParticipants.appendChild(d);
        return;
      }
      for (const p of list.slice(0, 20)) {
        const d = document.createElement('div');
        d.className = 'side-item';
        d.textContent = `${p.isHost ? '[Host] ' : ''}${String(p.displayName || 'Guest')}`;
        els.sideParticipants.appendChild(d);
      }
    }

    function updateMediaVisibility() {
      const inRoom = !!state.roomCode;
      const hasPlayerMedia = !!(els.player && els.player.src);
      const hasScreenMedia = !!(els.screenView && els.screenView.srcObject);
      if (els.player) {
        els.player.classList.toggle('hidden-media', !inRoom || (!hasPlayerMedia && !state.isHost));
      }
      if (els.screenView) {
        els.screenView.classList.toggle('hidden-media', !inRoom || !hasScreenMedia);
      }
      if (els.chatFeed) {
        els.chatFeed.classList.toggle('hidden-media', !inRoom);
      }
      if (els.chatInput) {
        els.chatInput.disabled = !inRoom;
      }
      if (els.chatBtn) {
        els.chatBtn.disabled = !inRoom;
      }
      if (els.pinnedChat) {
        if (!inRoom) {
          els.pinnedChat.textContent = 'Join a room to view room-only messages.';
        }
      }
      if (els.chatCount && !inRoom) {
        els.chatCount.textContent = '0 messages';
      }
    }

    function renderOpenParties(rooms) {
      if (!els.openPartiesList) return;
      const active = (Array.isArray(rooms) ? rooms : []).filter((r) => Number(r.activeCount || 0) > 0);
      els.openPartiesList.innerHTML = '';
      if (els.sideRooms) {
        els.sideRooms.innerHTML = '';
      }
      if (!active.length) {
        const d = document.createElement('div');
        d.className = 'muted';
        d.textContent = 'No active parties right now.';
        els.openPartiesList.appendChild(d);
        if (els.sideRooms) {
          const s = document.createElement('div');
          s.className = 'side-item';
          s.textContent = 'No active parties';
          els.sideRooms.appendChild(s);
        }
        return;
      }
      for (const r of active.slice(0, 20)) {
        const card = document.createElement('div');
        card.className = 'open-party-item';
        card.innerHTML = `
          <div class="open-party-title">${String(r.title || r.roomCode || 'Watch Party')}</div>
          <div class="open-party-meta">Code: ${String(r.roomCode || '')} Â· Viewers: ${Number(r.activeCount || 0)}</div>
        `;
        const btn = document.createElement('button');
        btn.className = 'secondary';
        btn.textContent = 'Join Party';
        btn.addEventListener('click', async () => {
          els.roomInput.value = normalizeRoomCode(r.roomCode || '');
          try { await joinRoom(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
        });
        card.appendChild(btn);
        els.openPartiesList.appendChild(card);

        if (els.sideRooms) {
          const side = document.createElement('button');
          side.className = 'side-item';
          side.textContent = `${String(r.roomCode || '')} Â· ${Number(r.activeCount || 0)} live`;
          side.addEventListener('click', async () => {
            els.roomInput.value = normalizeRoomCode(r.roomCode || '');
            try { await joinRoom(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
          });
          els.sideRooms.appendChild(side);
        }
      }
    }

    async function refreshOpenParties() {
      try {
        const data = await apiRequest('GET', '/api/public-rooms');
        renderOpenParties(Array.isArray(data.rooms) ? data.rooms : []);
      } catch (_) {
        if (els.openPartiesList && !els.openPartiesList.children.length) {
          const d = document.createElement('div');
          d.className = 'muted';
          d.textContent = 'Unable to load open parties right now.';
          els.openPartiesList.appendChild(d);
        }
      }
    }

    function addReaction(emoji, actor) {
      if (!els.reactionOverlay) return;
      const d = document.createElement('div');
      d.className = 'reaction-pop';
      d.textContent = String(emoji || 'ðŸ‘');
      d.title = actor || '';
      els.reactionOverlay.appendChild(d);
      setTimeout(() => {
        try { d.remove(); } catch (_) {}
      }, 1800);
    }

    async function sendReaction(emoji) {
      const clean = String(emoji || '').trim().slice(0, 4);
      if (!clean) return;
      await sendControl('reaction', { emoji: clean });
      addReaction(clean, 'you');
    }

    function upsertRequestFromEvent(ev) {
      if (!ev || ev.type !== 'request_item') return;
      const req = {
        id: Number(ev.id) || 0,
        actor: String(ev.actor || 'user'),
        type: String(ev.payload?.requestType || 'general'),
        text: String(ev.payload?.requestText || ''),
        status: 'pending',
        note: '',
      };
      if (!req.id) return;
      state.requests = state.requests.filter((r) => r.id !== req.id);
      state.requests.unshift(req);
    }

    function resolveRequestFromEvent(ev) {
      if (!ev || ev.type !== 'resolve_request') return;
      const id = Number(ev.payload?.requestId || 0);
      if (!id) return;
      const status = String(ev.payload?.status || 'denied');
      const note = String(ev.payload?.note || '');
      state.requests = state.requests.map((r) => {
        if (r.id !== id) return r;
        return Object.assign({}, r, { status, note });
      });
    }

    function renderRequestQueue() {
      if (!els.requestQueueSelect) return;
      const pending = (state.requests || []).filter((r) => r.status === 'pending');
      els.requestQueueSelect.innerHTML = '';
      if (!pending.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No pending requests';
        els.requestQueueSelect.appendChild(o);
        return;
      }
      for (const r of pending) {
        const o = document.createElement('option');
        o.value = String(r.id);
        o.textContent = `#${r.id} ${r.actor} Â· ${r.type} Â· ${r.text}`;
        els.requestQueueSelect.appendChild(o);
      }
    }

    async function sendRequestItem() {
      const type = String((els.requestTypeSelect && els.requestTypeSelect.value) || 'general');
      const text = String((els.requestTextInput && els.requestTextInput.value) || '').trim();
      if (!text) {
        setStatus(false, 'Request text required.');
        return;
      }
      await sendControl('request_item', { requestType: type, requestText: text });
      els.requestTextInput.value = '';
      setStatus(true, 'Request sent.');
    }

    async function resolveSelectedRequest(status) {
      if (!state.isHost) return;
      const requestId = Number((els.requestQueueSelect && els.requestQueueSelect.value) || 0);
      const note = String((els.requestResolveNote && els.requestResolveNote.value) || '').trim();
      if (!requestId) {
        setStatus(false, 'Select a request first.');
        return;
      }
      await sendControl('resolve_request', { requestId, status, note });
      if (els.requestResolveNote) els.requestResolveNote.value = '';
      setStatus(true, `Request #${requestId} ${status}.`);
    }

    function voiceOn() {
      return !!(rtc.localVoiceStream && rtc.localVoiceStream.getAudioTracks().length);
    }

    function camOn() {
      return !!(rtc.localCamStream && rtc.localCamStream.getVideoTracks().length);
    }

    function getQualityProfile(rawIn) {
      const raw = String(rawIn || 'balanced').toLowerCase();
      if (raw === 'ultra') {
        return { key: 'ultra', maxBitrate: 10000000, maxFramerate: 60, width: 2560, height: 1440, frameRate: 60 };
      }
      if (raw === 'high') {
        return { key: 'high', maxBitrate: 6500000, maxFramerate: 60, width: 1920, height: 1080, frameRate: 60 };
      }
      return { key: 'balanced', maxBitrate: 3200000, maxFramerate: 30, width: 1280, height: 720, frameRate: 30 };
    }

    function getShareQualityProfile() {
      return getQualityProfile((els.shareQualitySelect && els.shareQualitySelect.value) || 'balanced');
    }

    function getMovieQualityProfile() {
      return getQualityProfile((els.movieQualitySelect && els.movieQualitySelect.value) || 'high');
    }

    function getWebcamQualityProfile() {
      return getQualityProfile((els.webcamQualitySelect && els.webcamQualitySelect.value) || 'high');
    }

    function viewerCount() {
      const count = Number((state.participants || []).length || 0);
      if (!state.isHost) return Math.max(0, count);
      return Math.max(0, count - 1);
    }

    function scaleQualityForAudience(profile, viewers) {
      const safe = Object.assign({}, profile || getQualityProfile('balanced'));
      const n = Math.max(0, Number(viewers || 0));
      if (n >= 40) {
        safe.maxBitrate = Math.min(safe.maxBitrate, 1800000);
        safe.maxFramerate = Math.min(safe.maxFramerate, 24);
        safe.width = Math.min(safe.width, 1280);
        safe.height = Math.min(safe.height, 720);
        safe.frameRate = Math.min(safe.frameRate, 24);
        safe.key = `${safe.key}-event-lite`;
        return safe;
      }
      if (n >= 24) {
        safe.maxBitrate = Math.min(safe.maxBitrate, 2800000);
        safe.maxFramerate = Math.min(safe.maxFramerate, 30);
        safe.width = Math.min(safe.width, 1280);
        safe.height = Math.min(safe.height, 720);
        safe.frameRate = Math.min(safe.frameRate, 30);
        safe.key = `${safe.key}-event`;
        return safe;
      }
      if (n >= 16) {
        safe.maxBitrate = Math.min(safe.maxBitrate, 4200000);
        safe.maxFramerate = Math.min(safe.maxFramerate, 30);
        safe.frameRate = Math.min(safe.frameRate, 30);
        safe.key = `${safe.key}-scaled`;
      }
      return safe;
    }

    function currentMediaMode() {
      const raw = String(state.mediaMode || 'webrtc').toLowerCase();
      return (raw === 'sfu' || raw === 'broadcast') ? raw : 'webrtc';
    }

    function isSfuMode() {
      return currentMediaMode() === 'sfu';
    }

    function isBroadcastMode() {
      return currentMediaMode() === 'broadcast';
    }

    function applyMediaModeState(mode, persistControl) {
      const raw = String(mode || 'webrtc').toLowerCase();
      const clean = (raw === 'sfu' || raw === 'broadcast') ? raw : 'webrtc';
      const prev = String(state.mediaMode || 'webrtc').toLowerCase();
      state.mediaMode = clean;
      if (prev === 'sfu' && clean !== 'sfu' && sfu.room) {
        try { sfu.room.disconnect(); } catch (_) {}
        sfu.room = null;
        sfu.connected = false;
        clearSfuRemoteAudio();
      }
      if (els.mediaModeSelect) {
        els.mediaModeSelect.value = clean;
        if (persistControl) {
          els.mediaModeSelect.disabled = !!state.roomCode;
        }
      }
    }

    function updateMediaModeGate() {
      if (!els.mediaModeSelect) return;
      const signedInAdmin = !!(state.adminToken && state.adminUsername);
      const sfuOpt = Array.from(els.mediaModeSelect.options || []).find((o) => String(o.value) === 'sfu');
      const broadcastOpt = Array.from(els.mediaModeSelect.options || []).find((o) => String(o.value) === 'broadcast');
      if (sfuOpt) {
        sfuOpt.disabled = !state.sfuEnabled || !hasTier('pro');
        sfuOpt.textContent = hasTier('pro')
          ? 'SFU Relay (Best for 40-50+)'
          : 'SFU Relay (Pro donation tier)';
      }
      if (broadcastOpt) {
        broadcastOpt.disabled = !signedInAdmin;
        broadcastOpt.textContent = signedInAdmin
          ? 'Broadcast (Admin Only, HLS/CDN)'
          : 'Broadcast (Admin sign-in required)';
      }
      if (!signedInAdmin && !state.roomCode && currentMediaMode() === 'broadcast') {
        applyMediaModeState('webrtc', false);
      }
    }

    function renderMainEventState() {
      const on = !!state.mainEventEnabled;
      const signedInAdmin = !!(state.adminToken && state.adminUsername);
      if (els.mainEventState) {
        els.mainEventState.textContent = `Main Event: ${on ? 'ON' : 'OFF'}${signedInAdmin ? '' : ' (admin required)'}`;
      }
      if (els.macroMainEventBtn) {
        els.macroMainEventBtn.disabled = !signedInAdmin || on;
      }
      if (els.macroMainEventOffBtn) {
        els.macroMainEventOffBtn.disabled = !signedInAdmin || !on;
      }
    }

    function sfuRoomEventConsts() {
      return window.LivekitClient && window.LivekitClient.RoomEvent ? window.LivekitClient.RoomEvent : {};
    }

    function sfuTrackSourceConsts() {
      return window.LivekitClient && window.LivekitClient.Track && window.LivekitClient.Track.Source
        ? window.LivekitClient.Track.Source
        : {};
    }

    function attachSfuScreenTrack(track) {
      if (!els.screenView || !track || !track.mediaStreamTrack) return;
      try {
        els.screenView.srcObject = new MediaStream([track.mediaStreamTrack]);
        els.screenView.muted = true;
        els.screenView.play().catch(() => {});
      } catch (_) {}
      updateMediaVisibility();
    }

    function clearSfuRemoteAudio() {
      for (const el of sfu.remoteAudioEls.values()) {
        try {
          el.srcObject = null;
          el.remove();
        } catch (_) {}
      }
      sfu.remoteAudioEls.clear();
    }

    function handleSfuTrackSubscribed(track, publication, participant) {
      if (!track) return;
      const sourceConsts = sfuTrackSourceConsts();
      const source = publication && publication.source ? publication.source : '';
      const key = `${String(participant && participant.identity || '')}:${String(publication && publication.trackSid || '')}`;
      if (track.kind === 'video') {
        const isScreen = source === sourceConsts.ScreenShare || source === 'screen_share';
        if (isScreen && !state.isHost) {
          attachSfuScreenTrack(track);
          setSyncLabel('receiving host stream');
          updateStatusChips((state.participants || []).length);
        }
        return;
      }
      if (track.kind === 'audio') {
        try {
          const audio = track.attach();
          audio.autoplay = true;
          audio.playsInline = true;
          audio.dataset.sfuAudio = key;
          document.body.appendChild(audio);
          sfu.remoteAudioEls.set(key, audio);
        } catch (_) {}
      }
    }

    function handleSfuTrackUnsubscribed(track, publication, participant) {
      const key = `${String(participant && participant.identity || '')}:${String(publication && publication.trackSid || '')}`;
      const audio = sfu.remoteAudioEls.get(key);
      if (audio) {
        try { audio.srcObject = null; audio.remove(); } catch (_) {}
        sfu.remoteAudioEls.delete(key);
      }
      if (track && track.kind === 'video' && !state.isHost && els.screenView) {
        const src = els.screenView.srcObject;
        const streamTracks = src && src.getTracks ? src.getTracks() : [];
        if (!streamTracks || !streamTracks.length) {
          try { els.screenView.srcObject = null; } catch (_) {}
        }
      }
    }

    async function fetchSfuConfig() {
      try {
        const data = await apiRequest('GET', '/api/watch/sfu/config');
        state.sfuEnabled = !!(data && data.enabled);
        state.sfuUrl = String((data && data.url) || '').trim();
        if (els.mediaModeSelect) {
          const hasSfuOpt = Array.from(els.mediaModeSelect.options).some((o) => String(o.value) === 'sfu');
          if (hasSfuOpt) {
            const sfuOpt = Array.from(els.mediaModeSelect.options).find((o) => String(o.value) === 'sfu');
            if (sfuOpt) sfuOpt.disabled = !state.sfuEnabled;
          }
        }
      } catch (_) {
        state.sfuEnabled = false;
        state.sfuUrl = '';
      }
    }

    async function disconnectSfu() {
      try { await stopScreenShare(); } catch (_) {}
      try { await stopVoiceChat(); } catch (_) {}
      try { await stopWebcamShare(); } catch (_) {}
      clearSfuRemoteAudio();
      if (sfu.room) {
        try { sfu.room.disconnect(); } catch (_) {}
      }
      sfu.room = null;
      sfu.connected = false;
    }

    async function ensureSfuConnected() {
      if (!isSfuMode()) return;
      if (!state.roomCode || !state.participantToken) return;
      if (sfu.connected && sfu.room) return;
      if (!state.sfuEnabled || !state.sfuUrl) {
        throw new Error('SFU mode is not configured on server.');
      }
      if (!window.LivekitClient || !window.LivekitClient.Room) {
        throw new Error('SFU client library failed to load.');
      }
      const tokenRes = await apiRequest('POST', '/api/watch/sfu/token', {
        roomCode: state.roomCode,
        participantToken: state.participantToken,
        displayName: String((els.displayName && els.displayName.value) || '').trim() || 'Viewer',
      });
      const roomUrl = String(tokenRes.url || state.sfuUrl || '').trim();
      const token = String(tokenRes.token || '').trim();
      if (!roomUrl || !token) {
        throw new Error('SFU token request failed.');
      }
      const LK = window.LivekitClient;
      const ev = sfuRoomEventConsts();
      const room = new LK.Room({
        adaptiveStream: true,
        dynacast: true,
      });
      room.on(ev.TrackSubscribed || 'trackSubscribed', (track, publication, participant) => {
        handleSfuTrackSubscribed(track, publication, participant);
      });
      room.on(ev.TrackUnsubscribed || 'trackUnsubscribed', (track, publication, participant) => {
        handleSfuTrackUnsubscribed(track, publication, participant);
      });
      room.on(ev.Disconnected || 'disconnected', () => {
        sfu.connected = false;
        clearSfuRemoteAudio();
      });
      await room.connect(roomUrl, token);
      sfu.room = room;
      sfu.connected = true;
      addEventLine('Connected to SFU relay');
    }

    async function setSenderQuality(sender, profile) {
      if (!sender || !sender.getParameters || !sender.setParameters || !profile) return;
      try {
        const params = sender.getParameters() || {};
        if (!Array.isArray(params.encodings) || !params.encodings.length) params.encodings = [{}];
        params.encodings[0].maxBitrate = profile.maxBitrate;
        params.encodings[0].maxFramerate = profile.maxFramerate;
        await sender.setParameters(params);
      } catch (_) {}
    }

    function updateVoiceUi() {
      if (els.voiceStatus) {
        const muted = !!state.hostMuted[state.participantId || ''];
        els.voiceStatus.textContent = voiceOn()
          ? (muted ? 'Voice: on (muted by host)' : 'Voice: on')
          : 'Voice: off';
      }
      if (els.webcamStatus) {
        if (!state.allowWebcam && !state.isHost) {
          els.webcamStatus.textContent = 'Webcam: blocked by host';
        } else {
          els.webcamStatus.textContent = camOn() ? 'Webcam: on' : 'Webcam: off';
        }
      }
      if (els.sideVoice) {
        const voiceLabel = voiceOn() ? 'Voice connected' : 'Voice disconnected';
        const camLabel = camOn() ? 'Webcam on' : 'Webcam off';
        els.sideVoice.textContent = `${voiceLabel} Â· ${camLabel}`;
      }
      const inRoom = !!(state.roomCode && state.participantToken);
      if (els.joinVoiceBtn) els.joinVoiceBtn.disabled = voiceOn() || !inRoom;
      if (els.leaveVoiceBtn) els.leaveVoiceBtn.disabled = !voiceOn();
      if (els.micDeviceSelect) els.micDeviceSelect.disabled = false;
      if (els.camDeviceSelect) els.camDeviceSelect.disabled = false;
      if (els.refreshDevicesBtn) els.refreshDevicesBtn.disabled = false;
      if (els.voiceQualitySelect) els.voiceQualitySelect.disabled = false;
      if (els.liveWebcamQualitySelect) els.liveWebcamQualitySelect.disabled = false;
      const hostCanModerate = !!state.isHost;
      if (els.muteTargetBtn) els.muteTargetBtn.disabled = !hostCanModerate;
      if (els.unmuteTargetBtn) els.unmuteTargetBtn.disabled = !hostCanModerate;
      if (els.kickTargetBtn) els.kickTargetBtn.disabled = !hostCanModerate;
      if (els.approveJoinBtn) els.approveJoinBtn.disabled = !hostCanModerate;
      if (els.denyJoinBtn) els.denyJoinBtn.disabled = !hostCanModerate;
      if (els.setAccessModeBtn) els.setAccessModeBtn.disabled = !hostCanModerate;
      if (els.setWebcamPolicyBtn) els.setWebcamPolicyBtn.disabled = !hostCanModerate;
      if (els.setCohostPermsBtn) els.setCohostPermsBtn.disabled = !hostCanModerate;
      if (els.webcamPolicySelect) {
        els.webcamPolicySelect.disabled = !hostCanModerate;
        els.webcamPolicySelect.value = state.allowWebcam ? 'allow' : 'deny';
      }
      if (els.cohostKickPerm) els.cohostKickPerm.disabled = !hostCanModerate;
      if (els.cohostMutePerm) els.cohostMutePerm.disabled = !hostCanModerate;
      if (els.cohostAccessPerm) els.cohostAccessPerm.disabled = !hostCanModerate;
      if (els.cohostPinPerm) els.cohostPinPerm.disabled = !hostCanModerate;
      const canUseWebcam = !!state.roomCode && (state.isHost || state.allowWebcam);
      if (els.startWebcamBtn) els.startWebcamBtn.disabled = !canUseWebcam || camOn();
      if (els.stopWebcamBtn) els.stopWebcamBtn.disabled = !camOn();
      if (els.remoteWebcamGrid) {
        els.remoteWebcamGrid.classList.toggle('hidden-media', rtc.camEls.size < 1);
      }
    }

    async function setSenderAudioQuality(sender, maxBitrate) {
      if (!sender || !sender.getParameters || !sender.setParameters) return;
      try {
        const params = sender.getParameters() || {};
        if (!Array.isArray(params.encodings) || !params.encodings.length) params.encodings = [{}];
        params.encodings[0].maxBitrate = maxBitrate;
        await sender.setParameters(params);
      } catch (_) {}
    }

    function getAudioProfile() {
      const mode = String((els.voiceQualitySelect && els.voiceQualitySelect.value) || (els.audioProfileSelect && els.audioProfileSelect.value) || 'cinema').toLowerCase();
      if (mode === 'voice') {
        return {
          constraints: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 48000,
            channelCount: 1,
          },
          voiceBitrate: 192000,
          streamAudioBitrate: 256000,
        };
      }
      return {
        constraints: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 48000,
          channelCount: 2,
        },
        voiceBitrate: 256000,
        streamAudioBitrate: 384000,
      };
    }

    function syncQualitySelectors() {
      const voiceMode = String((els.voiceQualitySelect && els.voiceQualitySelect.value) || (els.audioProfileSelect && els.audioProfileSelect.value) || 'cinema').toLowerCase();
      if (els.voiceQualitySelect) els.voiceQualitySelect.value = voiceMode;
      if (els.audioProfileSelect) els.audioProfileSelect.value = voiceMode;
      const camMode = String((els.liveWebcamQualitySelect && els.liveWebcamQualitySelect.value) || (els.webcamQualitySelect && els.webcamQualitySelect.value) || 'high').toLowerCase();
      if (els.liveWebcamQualitySelect) els.liveWebcamQualitySelect.value = camMode;
      if (els.webcamQualitySelect) els.webcamQualitySelect.value = camMode;
    }

    function loadPreferredMediaDevices() {
      try { state.preferredMicId = String(localStorage.getItem(MIC_DEVICE_KEY) || '').trim(); } catch (_) {}
      try { state.preferredCamId = String(localStorage.getItem(CAM_DEVICE_KEY) || '').trim(); } catch (_) {}
    }

    function persistPreferredMediaDevices() {
      try {
        if (state.preferredMicId) localStorage.setItem(MIC_DEVICE_KEY, state.preferredMicId);
        else localStorage.removeItem(MIC_DEVICE_KEY);
      } catch (_) {}
      try {
        if (state.preferredCamId) localStorage.setItem(CAM_DEVICE_KEY, state.preferredCamId);
        else localStorage.removeItem(CAM_DEVICE_KEY);
      } catch (_) {}
    }

    function renderDeviceSelect(selectEl, rows, preferred, fallbackLabel) {
      if (!selectEl) return '';
      selectEl.innerHTML = '';
      if (!rows.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = fallbackLabel + ' unavailable';
        selectEl.appendChild(o);
        return '';
      }
      let picked = '';
      let idx = 0;
      for (const d of rows) {
        idx += 1;
        const o = document.createElement('option');
        o.value = String(d.deviceId || '');
        o.textContent = String(d.label || `${fallbackLabel} ${idx}`);
        selectEl.appendChild(o);
        if (!picked && preferred && o.value === preferred) picked = o.value;
      }
      if (!picked) picked = String(rows[0].deviceId || '');
      selectEl.value = picked;
      return picked;
    }

    async function refreshDeviceLists() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
      try {
        const rows = await navigator.mediaDevices.enumerateDevices();
        const audioInputs = rows.filter((d) => d && d.kind === 'audioinput');
        const videoInputs = rows.filter((d) => d && d.kind === 'videoinput');
        state.preferredMicId = renderDeviceSelect(els.micDeviceSelect, audioInputs, state.preferredMicId || (els.micDeviceSelect && els.micDeviceSelect.value) || '', 'Microphone');
        state.preferredCamId = renderDeviceSelect(els.camDeviceSelect, videoInputs, state.preferredCamId || (els.camDeviceSelect && els.camDeviceSelect.value) || '', 'Webcam');
        persistPreferredMediaDevices();
      } catch (_) {}
    }

    async function warmDevicePermissions() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
      let stream = null;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
      } catch (_) {
        try {
          stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        } catch (_) {
          try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
          } catch (_) {}
        }
      }
      if (stream) {
        for (const t of stream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
    }

    function applyHostOptionsVisibility() {
      const hostTabBtn = els.tabButtons.find((b) => b && b.getAttribute('data-tab-btn') === 'host');
      const canUseHostOptions = !!state.isHost;
      if (hostTabBtn) hostTabBtn.classList.toggle('hidden', !canUseHostOptions);
      if (els.hostTabPane) els.hostTabPane.classList.toggle('hidden', !canUseHostOptions);
      const hostOnlyEls = Array.from(document.querySelectorAll('[data-host-only="true"]'));
      for (const node of hostOnlyEls) {
        node.classList.toggle('hidden', !canUseHostOptions);
      }
      const activeHostPane = !!document.querySelector('.tab-pane.active[data-tab-pane="host"]');
      if (!canUseHostOptions && activeHostPane) {
        switchTab('chat');
      }
    }

    function renderHostOptionsMinimized() {
      if (!els.hostOptionsWrap || !els.hostOptionsToggleBtn) return;
      els.hostOptionsWrap.classList.toggle('hidden', !!state.hostOptionsMinimized);
      els.hostOptionsToggleBtn.textContent = state.hostOptionsMinimized ? 'Expand Host Options' : 'Minimize Host Options';
    }

    function refreshMuteTargets() {
      if (!els.muteTargetSelect) return;
      els.muteTargetSelect.innerHTML = '';
      if (els.kickTargetSelect) els.kickTargetSelect.innerHTML = '';
      const mine = String(state.participantId || '');
      const targets = (state.participants || []).filter((p) => p && !p.isSelf).map((p) => ({
        id: String(p.participantId || ''),
        name: String(p.displayName || p.participantId || 'user'),
        isHost: !!p.isHost
      })).filter((p) => p.id && p.id !== mine);
      if (!targets.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No participants';
        els.muteTargetSelect.appendChild(o);
        if (els.kickTargetSelect) {
          const ko = document.createElement('option');
          ko.value = '';
          ko.textContent = 'No participants';
          els.kickTargetSelect.appendChild(ko);
        }
        return;
      }
      for (const t of targets) {
        const o = document.createElement('option');
        o.value = t.id;
        o.textContent = t.name;
        els.muteTargetSelect.appendChild(o);
        if (els.kickTargetSelect && !t.isHost) {
          const ko = document.createElement('option');
          ko.value = t.id;
          ko.textContent = t.name;
          els.kickTargetSelect.appendChild(ko);
        }
      }
      if (els.kickTargetSelect && !els.kickTargetSelect.options.length) {
        const ko = document.createElement('option');
        ko.value = '';
        ko.textContent = 'No kickable users';
        els.kickTargetSelect.appendChild(ko);
      }
    }

    function adaptiveTargetFor(baseBitrate, rttSec, packetLossDelta) {
      const base = Math.max(900000, Number(baseBitrate || 3200000));
      let factor = 1.0;
      if (rttSec > 0.55 || packetLossDelta > 40) factor = 0.35;
      else if (rttSec > 0.35 || packetLossDelta > 20) factor = 0.5;
      else if (rttSec > 0.2 || packetLossDelta > 10) factor = 0.7;
      else if (rttSec < 0.12 && packetLossDelta <= 2) factor = 1.0;
      return Math.max(450000, Math.min(base, Math.round(base * factor)));
    }

    async function applyAdaptiveSender(sender, targetBitrate, targetFps) {
      if (!sender || !sender.getParameters || !sender.setParameters) return;
      try {
        const params = sender.getParameters() || {};
        if (!Array.isArray(params.encodings) || !params.encodings.length) params.encodings = [{}];
        params.encodings[0].maxBitrate = Math.max(450000, Math.round(targetBitrate || 900000));
        params.encodings[0].maxFramerate = Math.max(15, Math.min(60, Math.round(targetFps || 30)));
        await sender.setParameters(params);
      } catch (_) {}
    }

    async function monitorAdaptiveQuality() {
      if (!state.isHost || !rtc.localScreenStream) return;
      const movieProfile = getMovieQualityProfile();
      const peerIds = Array.from(rtc.peers.keys());
      for (const pid of peerIds) {
        const row = rtc.peers.get(pid);
        if (!row || !row.pc) continue;
        const pc = row.pc;
        const videoSender = pc.getSenders().find((s) => s && s.track && s.track.kind === 'video');
        if (!videoSender) continue;
        let rttSec = 0.18;
        let packetsLost = 0;
        try {
          const stats = await pc.getStats();
          stats.forEach((report) => {
            if (report.type === 'candidate-pair' && report.state === 'succeeded' && report.currentRoundTripTime) {
              rttSec = Number(report.currentRoundTripTime) || rttSec;
            }
            if (report.type === 'remote-inbound-rtp' && report.kind === 'video') {
              if (Number.isFinite(report.roundTripTime)) rttSec = Number(report.roundTripTime);
              if (Number.isFinite(report.packetsLost)) packetsLost = Number(report.packetsLost);
            }
          });
        } catch (_) {}
        const prev = rtc.adaptive.get(pid) || { packetsLost: 0, targetBitrate: movieProfile.maxBitrate };
        const lossDelta = Math.max(0, packetsLost - Number(prev.packetsLost || 0));
        const target = adaptiveTargetFor(movieProfile.maxBitrate, rttSec, lossDelta);
        const fps = target < movieProfile.maxBitrate * 0.65 ? Math.min(30, movieProfile.maxFramerate) : movieProfile.maxFramerate;
        await applyAdaptiveSender(videoSender, target, fps);
        rtc.adaptive.set(pid, { packetsLost, targetBitrate: target, rttSec, lossDelta, ts: Date.now() });
      }
    }

    function startAdaptiveLoop() {
      if (rtc.adaptiveTimer) return;
      rtc.adaptiveTimer = setInterval(() => {
        monitorAdaptiveQuality().catch(() => {});
      }, 3500);
    }

    function stopAdaptiveLoop() {
      if (rtc.adaptiveTimer) {
        clearInterval(rtc.adaptiveTimer);
        rtc.adaptiveTimer = null;
      }
      rtc.adaptive.clear();
    }

    function shouldInitiateVoiceOffer(targetParticipantId) {
      const me = String(state.participantId || '');
      const peer = String(targetParticipantId || '');
      if (!me || !peer) return false;
      return me < peer;
    }

    function addLocalVoiceTrackToPeer(pc) {
      if (!rtc.localVoiceStream) return;
      const track = rtc.localVoiceStream.getAudioTracks()[0];
      if (!track) return;
      const profile = getAudioProfile();
      const existing = pc.getSenders().find((s) => s.track && s.track.kind === 'audio');
      if (existing) {
        existing.replaceTrack(track).catch(() => {});
        setSenderAudioQuality(existing, profile.voiceBitrate).catch(() => {});
      } else {
        const sender = pc.addTrack(track, rtc.localVoiceStream);
        setSenderAudioQuality(sender, profile.voiceBitrate).catch(() => {});
      }
    }

    async function createVoiceOfferFor(participantId) {
      if (!voiceOn() || !participantId) return;
      if (!shouldInitiateVoiceOffer(participantId)) return;
      const pc = ensurePeer(participantId);
      addLocalVoiceTrackToPeer(pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.voiceOfferedTo.add(participantId);
    }

    async function syncVoiceOffers() {
      if (!voiceOn()) return;
      const peers = (state.participants || [])
        .filter((p) => p && !p.isSelf)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(peers);
      for (const pid of Array.from(rtc.voiceOfferedTo)) {
        if (!keep.has(pid)) rtc.voiceOfferedTo.delete(pid);
      }
      for (const pid of peers) {
        if (!rtc.voiceOfferedTo.has(pid)) {
          try { await createVoiceOfferFor(pid); } catch (_) {}
        }
      }
    }

    function addLocalCamTrackToPeer(pc) {
      if (!rtc.localCamStream) return;
      const track = rtc.localCamStream.getVideoTracks()[0];
      if (!track) return;
      const existing = pc.getSenders().find((s) => s.track && s.track.kind === 'video' && s.track.id === track.id);
      if (existing) {
        existing.replaceTrack(track).catch(() => {});
      } else {
        pc.addTrack(track, rtc.localCamStream);
      }
    }

    function hostRemoteCamContainer(participantId, displayName) {
      if (!els.remoteWebcamGrid) return null;
      const key = String(participantId || '').trim();
      if (!key) return null;
      let tile = rtc.camEls.get(key);
      if (tile) return tile;
      const wrap = document.createElement('div');
      wrap.className = 'webcam-tile';
      const video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      video.muted = false;
      const label = document.createElement('div');
      label.className = 'webcam-label';
      label.textContent = displayName || key;
      wrap.appendChild(video);
      wrap.appendChild(label);
      els.remoteWebcamGrid.appendChild(wrap);
      tile = { wrap, video, label };
      rtc.camEls.set(key, tile);
      return tile;
    }

    async function syncCamOfferToHost() {
      if (!camOn() || state.isHost) return;
      const hostId = getHostParticipantId();
      if (!hostId) return;
      if (rtc.camOfferedTo.has(hostId)) return;
      const pc = ensurePeer(hostId);
      addLocalCamTrackToPeer(pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: hostId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.camOfferedTo.add(hostId);
    }

    async function startVoiceChat() {
      if (!state.roomCode || !state.participantToken) {
        throw new Error('Join a room first, then start voice chat.');
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Voice chat unavailable in this browser.');
      }
      const profile = getAudioProfile();
      const audioConstraints = Object.assign({}, profile.constraints || {});
      const selectedMic = String((els.micDeviceSelect && els.micDeviceSelect.value) || state.preferredMicId || '').trim();
      if (selectedMic) audioConstraints.deviceId = { exact: selectedMic };
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints, video: false });
      } catch (err) {
        if (selectedMic) {
          stream = await navigator.mediaDevices.getUserMedia({ audio: profile.constraints, video: false });
        } else {
          throw err;
        }
      }
      rtc.localVoiceStream = stream;
      if (selectedMic) {
        state.preferredMicId = selectedMic;
        persistPreferredMediaDevices();
      }
      refreshDeviceLists().catch(() => {});
      const mutedByHost = !!state.hostMuted[state.participantId || ''];
      for (const t of stream.getAudioTracks()) t.enabled = !mutedByHost;
      if (isSfuMode()) {
        await ensureSfuConnected();
        const micTrack = stream.getAudioTracks()[0];
        if (micTrack && sfu.room) {
          if (sfu.localVoiceTrack) {
            try { await sfu.room.localParticipant.unpublishTrack(sfu.localVoiceTrack); } catch (_) {}
          }
          await sfu.room.localParticipant.publishTrack(micTrack, { name: 'mic' });
          sfu.localVoiceTrack = micTrack;
        }
        updateVoiceUi();
        addEventLine('Voice joined');
        return;
      }
      updateVoiceUi();
      await syncVoiceOffers();
      addEventLine('Voice joined');
    }

    async function stopVoiceChat() {
      if (rtc.localVoiceStream) {
        for (const t of rtc.localVoiceStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      if (isSfuMode() && sfu.room && sfu.localVoiceTrack) {
        try { await sfu.room.localParticipant.unpublishTrack(sfu.localVoiceTrack); } catch (_) {}
      }
      sfu.localVoiceTrack = null;
      rtc.localVoiceStream = null;
      for (const row of rtc.peers.values()) {
        const pc = row.pc;
        for (const sender of pc.getSenders()) {
          if (sender.track && sender.track.kind === 'audio') {
            sender.replaceTrack(null).catch(() => {});
          }
        }
      }
      rtc.voiceOfferedTo.clear();
      updateVoiceUi();
      addEventLine('Voice left');
    }

    async function hostSetMuteTarget(muted) {
      if (!state.isHost) return;
      const toParticipantId = String((els.muteTargetSelect && els.muteTargetSelect.value) || '').trim().toLowerCase();
      if (!toParticipantId) return;
      await sendControl('mute_user', { toParticipantId, muted: !!muted });
      setStatus(true, (muted ? 'Muted ' : 'Unmuted ') + toParticipantId);
    }

    async function setWebcamPolicy() {
      if (!state.isHost) return;
      const mode = String((els.webcamPolicySelect && els.webcamPolicySelect.value) || 'allow').toLowerCase();
      const allowWebcam = mode !== 'deny';
      await sendControl('set_webcam_policy', { allowWebcam });
      state.allowWebcam = allowWebcam;
      updateVoiceUi();
      setStatus(true, allowWebcam ? 'Participant webcams enabled.' : 'Participant webcams blocked.');
    }

    async function setCohostPerms() {
      if (!state.isHost) return;
      const canKick = !!(els.cohostKickPerm && els.cohostKickPerm.checked);
      const canMute = !!(els.cohostMutePerm && els.cohostMutePerm.checked);
      const canAccess = !!(els.cohostAccessPerm && els.cohostAccessPerm.checked);
      const canPin = !!(els.cohostPinPerm && els.cohostPinPerm.checked);
      await sendControl('set_cohost_perms', { canKick, canMute, canAccess, canPin });
      state.cohostPerms = { kick: canKick, mute: canMute, access: canAccess, pin: canPin };
      setStatus(true, 'Cohost permissions updated.');
    }

    async function startWebcamShare() {
      if (!state.roomCode || !state.participantToken) {
        throw new Error('Join a room first, then start webcam.');
      }
      if (!state.isHost && !state.allowWebcam) {
        setStatus(false, 'Host has blocked participant webcams.');
        return;
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Webcam is unavailable in this browser.');
      }
      const q = getWebcamQualityProfile();
      const selectedCam = String((els.camDeviceSelect && els.camDeviceSelect.value) || state.preferredCamId || '').trim();
      const videoConstraints = {
        width: { ideal: q.width },
        height: { ideal: q.height },
        frameRate: { ideal: q.frameRate, max: q.maxFramerate }
      };
      if (selectedCam) videoConstraints.deviceId = { exact: selectedCam };
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints,
          audio: false
        });
      } catch (err) {
        if (selectedCam) {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: q.width }, height: { ideal: q.height }, frameRate: { ideal: q.frameRate, max: q.maxFramerate } },
            audio: false
          });
        } else {
          throw err;
        }
      }
      rtc.localCamStream = stream;
      if (selectedCam) {
        state.preferredCamId = selectedCam;
        persistPreferredMediaDevices();
      }
      refreshDeviceLists().catch(() => {});
      if (els.localWebcamPreview) {
        els.localWebcamPreview.srcObject = stream;
        els.localWebcamPreview.classList.remove('hidden-media');
        els.localWebcamPreview.play().catch(() => {});
      }
      updateVoiceUi();
      if (isSfuMode()) {
        await ensureSfuConnected();
        const camTrack = stream.getVideoTracks()[0];
        if (camTrack && sfu.room) {
          if (sfu.localCamTrack) {
            try { await sfu.room.localParticipant.unpublishTrack(sfu.localCamTrack); } catch (_) {}
          }
          await sfu.room.localParticipant.publishTrack(camTrack, { name: 'camera' });
          sfu.localCamTrack = camTrack;
        }
        addEventLine('Webcam started');
        return;
      }
      if (!state.isHost) {
        await syncCamOfferToHost();
      }
      addEventLine('Webcam started');
    }

    async function stopWebcamShare() {
      if (rtc.localCamStream) {
        for (const t of rtc.localCamStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localCamStream = null;
      if (isSfuMode() && sfu.room && sfu.localCamTrack) {
        try { await sfu.room.localParticipant.unpublishTrack(sfu.localCamTrack); } catch (_) {}
      }
      sfu.localCamTrack = null;
      if (els.localWebcamPreview) {
        try { els.localWebcamPreview.srcObject = null; } catch (_) {}
        els.localWebcamPreview.classList.add('hidden-media');
      }
      rtc.camOfferedTo.clear();
      for (const row of rtc.peers.values()) {
        const pc = row.pc;
        for (const sender of pc.getSenders()) {
          if (sender.track && sender.track.kind === 'video' && sender.track !== (rtc.localScreenStream && rtc.localScreenStream.getVideoTracks()[0])) {
            sender.replaceTrack(null).catch(() => {});
          }
        }
      }
      updateVoiceUi();
      addEventLine('Webcam stopped');
    }

    async function setAccessMode() {
      if (!state.isHost) return;
      const accessMode = String((els.accessModeSelect && els.accessModeSelect.value) || 'public').trim().toLowerCase();
      if (!['public', 'invite', 'closed'].includes(accessMode)) {
        setStatus(false, 'Invalid access mode.');
        return;
      }
      await sendControl('set_access_mode', { accessMode });
      state.accessMode = accessMode;
      setStatus(true, 'Access mode set to ' + accessMode + '.');
    }

    async function kickSelectedUser() {
      if (!state.isHost) return;
      const toParticipantId = String((els.kickTargetSelect && els.kickTargetSelect.value) || '').trim().toLowerCase();
      if (!toParticipantId) {
        setStatus(false, 'Select a user to kick.');
        return;
      }
      await sendControl('kick_user', { toParticipantId });
      setStatus(true, 'User removed from room.');
    }

    async function resolveJoinRequest(status) {
      if (!state.isHost) return;
      const requestToken = String((els.joinRequestSelect && els.joinRequestSelect.value) || '').trim();
      if (!requestToken) {
        setStatus(false, 'No join request selected.');
        return;
      }
      await sendControl('resolve_join_request', { requestToken, status });
      setStatus(true, `Join request ${status}.`);
    }

    async function refreshAdminRooms() {
      if (!(state.adminToken && state.adminUsername)) return;
      const data = await apiRequest('POST', '/api/watch/admin/rooms', { adminToken: state.adminToken });
      const rooms = Array.isArray(data.rooms) ? data.rooms : [];
      const activeRooms = rooms.filter((r) => !!r && Number(r.activeCount || 0) > 0);
      state.adminRooms = activeRooms;
      if (!els.adminRoomsSelect || !els.adminRoomsBlock) return;
      els.adminRoomsBlock.classList.remove('hidden');
      els.adminRoomsSelect.innerHTML = '';
      for (const r of activeRooms) {
        const o = document.createElement('option');
        o.value = r.roomCode;
        const hostName = String(r.hostName || '').trim() || 'No active host';
        const accessLabel = String(r.accessMode || 'public');
        o.textContent = `${r.roomCode} Â· ${r.activeCount} live Â· Host: ${hostName} Â· ${accessLabel}`;
        els.adminRoomsSelect.appendChild(o);
      }
      if (!activeRooms.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No active rooms right now';
        els.adminRoomsSelect.appendChild(o);
      }
      renderAdminRoomMeta();
    }

    function renderAdminRoomMeta() {
      if (!els.adminRoomsMeta || !els.adminRoomsSelect) return;
      const selectedCode = String((els.adminRoomsSelect && els.adminRoomsSelect.value) || '').trim();
      const selectedRoom = (state.adminRooms || []).find((r) => String(r.roomCode || '') === selectedCode) || (state.adminRooms || [])[0] || null;
      if (!selectedRoom) {
        els.adminRoomsMeta.innerHTML = '<div>Active rooms: 0</div>';
        return;
      }
      els.adminRoomsMeta.innerHTML = `
        <div>Host: ${String(selectedRoom.hostName || 'No active host')}</div>
        <div>Title: ${String(selectedRoom.title || 'Untitled')}</div>
        <div>Participants: ${Number(selectedRoom.activeCount || 0)}</div>
        <div>Access: ${String(selectedRoom.accessMode || 'public')}</div>
      `;
    }

    function screenShareHelpMessage(err) {
      const name = String(err && err.name ? err.name : '');
      const msg = String(err && err.message ? err.message : '');
      if (!window.isSecureContext) {
        return 'Screen share requires HTTPS. Open this page from https://frenzynets.com/telewatch/.';
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        return 'This browser does not support screen capture. Use latest Chrome/Edge/Firefox.';
      }
      if (name === 'NotAllowedError' || name === 'PermissionDeniedError') {
        return 'Screen-share permission denied. Click Share Monitor / Tab again and allow monitor/tab/window access.';
      }
      if (name === 'NotFoundError') {
        return 'No display source found. Connect a monitor or choose a visible window/tab.';
      }
      if (name === 'NotReadableError' || msg.toLowerCase().includes('system')) {
        return 'OS blocked capture. Check system privacy settings and allow screen recording for your browser.';
      }
      return msg || 'Unable to start screen share. Reopen the page and try again.';
    }

    function normalizeRoomCode(raw) {
      return String(raw || '').trim().toUpperCase().replace(/[^A-Z0-9_-]/g, '').slice(0, 24);
    }

    function addEventLine(text) {
      if (!(state.adminToken && state.adminUsername)) return;
      const d = document.createElement('div');
      d.textContent = text;
      els.events.prepend(d);
      while (els.events.children.length > 80) {
        els.events.removeChild(els.events.lastChild);
      }
    }

    function renderPinnedMessage() {
      if (!els.pinnedChat) return;
      const id = Number(state.pinnedMessageId || 0);
      const entry = id ? state.chatMessages.get(id) : null;
      if (!entry) {
        els.pinnedChat.textContent = 'No pinned message';
        return;
      }
      els.pinnedChat.textContent = `${entry.actor}: ${entry.message}`;
    }

    function sendChatReaction(messageId, emoji) {
      const id = Number(messageId || 0);
      const clean = String(emoji || '').trim().slice(0, 8);
      if (!id || !clean) return;
      sendControl('react_chat', { messageId: id, emoji: clean }).catch((err) => {
        setStatus(false, String(err && err.message ? err.message : err));
      });
    }

    function togglePinMessage(messageId) {
      const id = Number(messageId || 0);
      if (!id) return;
      const nextPinned = state.pinnedMessageId !== id;
      sendControl('pin_chat', { messageId: id, pinned: nextPinned }).catch((err) => {
        setStatus(false, String(err && err.message ? err.message : err));
      });
    }

    function normalizeActorName(v) {
      return String(v || '').trim().toLowerCase();
    }

    function ownActorNames() {
      const set = new Set();
      set.add(normalizeActorName((els.displayName && els.displayName.value) || ''));
      set.add(normalizeActorName(state.userDisplayName || ''));
      set.add(normalizeActorName(state.userEmail || ''));
      return set;
    }

    function isOwnMessage(row) {
      const actor = normalizeActorName(row && row.actor ? row.actor : '');
      if (!actor) return false;
      return ownActorNames().has(actor);
    }

    function actorInitial(actor) {
      const text = String(actor || '').trim();
      if (!text) return '?';
      return text.charAt(0).toUpperCase();
    }

    function renderChatFeed() {
      if (!els.chatFeed) return;
      const sorted = Array.from(state.chatMessages.values()).sort((a, b) => a.id - b.id);
      const hiddenCount = Math.max(0, sorted.length - 80);
      const entries = sorted.slice(Math.max(0, sorted.length - 80));
      const wasNearBottom = Math.abs((els.chatFeed.scrollTop + els.chatFeed.clientHeight) - els.chatFeed.scrollHeight) < 36;
      if (els.chatCount) {
        const total = sorted.length;
        els.chatCount.textContent = `${total} message${total === 1 ? '' : 's'}`;
      }
      els.chatFeed.innerHTML = '';
      if (hiddenCount > 0) {
        const note = document.createElement('div');
        note.className = 'empty-state';
        note.textContent = `${hiddenCount} older messages archived`;
        els.chatFeed.appendChild(note);
      }
      for (const row of entries) {
        const d = document.createElement('div');
        const mine = isOwnMessage(row);
        d.className = 'msg-line' + (mine ? ' mine' : '');
        d.dataset.messageId = String(row.id);
        d.dataset.pinned = row.pinned ? 'true' : 'false';
        const ts = row.ts || new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const isPinned = !!row.pinned;
        const reactions = row.reactions || {};
        const avatar = document.createElement('div');
        avatar.className = 'msg-avatar';
        avatar.textContent = actorInitial(row.actor);
        const card = document.createElement('div');
        card.className = 'msg-card';
        const head = document.createElement('div');
        head.className = 'msg-head';
        head.textContent = `${String(row.actor || 'Guest')} Â· ${ts}${isPinned ? ' Â· PINNED' : ''}`;
        const body = document.createElement('div');
        body.className = 'msg-body';
        body.textContent = String(row.message || '');
        const act = document.createElement('div');
        act.className = 'msg-actions';
        const choices = ['ðŸ”¥', 'ðŸ˜‚', 'ðŸ‘', 'â¤ï¸'];
        for (const emoji of choices) {
          const count = Number(reactions[emoji] || 0);
          const pill = document.createElement('button');
          pill.className = 'msg-pill' + (count > 0 ? ' active' : '');
          pill.textContent = count > 0 ? `${emoji} ${count}` : emoji;
          pill.addEventListener('click', () => sendChatReaction(row.id, emoji));
          act.appendChild(pill);
        }
        if (state.isHost || (state.participants || []).some((p) => p && p.isSelf && p.isCohost)) {
          const pin = document.createElement('button');
          pin.className = 'msg-pill' + (isPinned ? ' active' : '');
          pin.textContent = isPinned ? 'Unpin' : 'Pin';
          pin.addEventListener('click', () => togglePinMessage(row.id));
          act.appendChild(pin);
        }
        card.appendChild(head);
        card.appendChild(body);
        card.appendChild(act);
        if (mine) {
          d.appendChild(card);
          d.appendChild(avatar);
        } else {
          d.appendChild(avatar);
          d.appendChild(card);
        }
        els.chatFeed.appendChild(d);
      }
      if (wasNearBottom || entries.length < 2) {
        els.chatFeed.scrollTop = els.chatFeed.scrollHeight;
      }
      renderPinnedMessage();
    }

    function addChatLine(sender, message, messageId, createdAt) {
      if (!state.roomCode) return;
      if (state.chatScopeRoom && state.chatScopeRoom !== state.roomCode) {
        state.chatMessages = new Map();
        state.pinnedMessageId = 0;
      }
      state.chatScopeRoom = state.roomCode;
      const id = Number(messageId || 0);
      if (!id) return;
      const ts = createdAt
        ? new Date(createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const existing = state.chatMessages.get(id) || { id, reactions: {}, pinned: false };
      existing.actor = String(sender || 'user');
      existing.message = String(message || '');
      existing.ts = ts;
      state.chatMessages.set(id, existing);
      renderChatFeed();
    }

    function switchTab(name) {
      const target = String(name || 'session').toLowerCase();
      for (const btn of els.tabButtons) {
        btn.classList.toggle('active', btn.getAttribute('data-tab-btn') === target);
      }
      for (const pane of els.tabPanes) {
        pane.classList.toggle('active', pane.getAttribute('data-tab-pane') === target);
      }
    }

    function applySceneOrder(order) {
      if (!els.sceneBoard) return;
      const cards = new Map((els.sceneCards || []).map((c) => [c.getAttribute('data-scene-card'), c]));
      const cleaned = Array.isArray(order) ? order.map((x) => String(x || '').trim()).filter((x) => cards.has(x)) : [];
      for (const key of cards.keys()) {
        if (!cleaned.includes(key)) cleaned.push(key);
      }
      for (const key of cleaned) {
        const card = cards.get(key);
        if (card) els.sceneBoard.appendChild(card);
      }
      try { localStorage.setItem(SCENE_ORDER_KEY, JSON.stringify(cleaned)); } catch (_) {}
    }

    function initSceneDrag() {
      if (!els.sceneBoard || !els.sceneCards || !els.sceneCards.length) return;
      let dragging = null;
      for (const card of els.sceneCards) {
        card.addEventListener('dragstart', () => {
          dragging = card;
          card.classList.add('dragging');
        });
        card.addEventListener('dragend', () => {
          card.classList.remove('dragging');
          dragging = null;
          const order = Array.from(els.sceneBoard.querySelectorAll('[data-scene-card]')).map((n) => n.getAttribute('data-scene-card'));
          applySceneOrder(order);
        });
      }
      els.sceneBoard.addEventListener('dragover', (ev) => {
        ev.preventDefault();
        if (!dragging) return;
        const cards = Array.from(els.sceneBoard.querySelectorAll('[data-scene-card]:not(.dragging)'));
        const next = cards.find((c) => {
          const rect = c.getBoundingClientRect();
          return ev.clientY < rect.top + rect.height / 2;
        });
        if (!next) els.sceneBoard.appendChild(dragging);
        else els.sceneBoard.insertBefore(dragging, next);
      });
      let saved = [];
      try {
        saved = JSON.parse(localStorage.getItem(SCENE_ORDER_KEY) || '[]');
      } catch (_) {}
      applySceneOrder(saved);
    }

    function initCollapsibleBlocks() {
      const roots = Array.from(document.querySelectorAll('.side-block, .block'));
      let idx = 0;
      for (const root of roots) {
        if (!root || root.dataset.collapseReady === '1') continue;
        const titleEl = root.querySelector(':scope > h3, :scope > h2');
        const titleText = String((titleEl && titleEl.textContent) || 'Section').trim() || 'Section';
        const children = Array.from(root.children);
        const body = document.createElement('div');
        body.className = 'collapse-body';
        for (const child of children) {
          if (titleEl && child === titleEl) continue;
          body.appendChild(child);
        }
        const head = document.createElement('div');
        head.className = 'collapse-head';
        const label = document.createElement('h3');
        label.className = 'collapse-title';
        label.textContent = titleText;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'secondary collapse-btn';
        btn.setAttribute('aria-expanded', 'true');
        btn.textContent = 'âˆ’';
        const key = `telewatch_block_collapsed_${root.id || root.getAttribute('data-scene-card') || ('idx_' + idx)}`;
        idx += 1;
        const setCollapsed = (next) => {
          const collapsed = !!next;
          root.classList.toggle('is-collapsed', collapsed);
          btn.textContent = collapsed ? '+' : 'âˆ’';
          btn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
          try { localStorage.setItem(key, collapsed ? '1' : '0'); } catch (_) {}
        };
        btn.addEventListener('click', () => {
          setCollapsed(!root.classList.contains('is-collapsed'));
        });
        head.appendChild(label);
        head.appendChild(btn);
        if (titleEl) {
          try { titleEl.remove(); } catch (_) {}
        }
        root.prepend(head);
        root.appendChild(body);
        root.dataset.collapseReady = '1';
        const saved = (() => {
          try { return localStorage.getItem(key) || '0'; } catch (_) { return '0'; }
        })();
        if (saved === '1') {
          setCollapsed(true);
        } else if (saved === '0' && root.getAttribute('data-start-collapsed') === '1') {
          setCollapsed(true);
        }
      }
    }

    function applyLayoutMode(mode, persist) {
      const clean = String(mode || 'standard').toLowerCase() === 'focus' ? 'focus' : 'standard';
      state.layoutMode = clean;
      document.body.classList.toggle('focus-mode', clean === 'focus');
      if (els.layoutModeSelect) els.layoutModeSelect.value = clean;
      if (persist) {
        try { localStorage.setItem(LAYOUT_MODE_KEY, clean); } catch (_) {}
      }
    }

    function applyDensityMode(mode, persist) {
      const clean = String(mode || 'comfortable').toLowerCase() === 'compact' ? 'compact' : 'comfortable';
      state.densityMode = clean;
      document.body.classList.toggle('compact-mode', clean === 'compact');
      if (els.densitySelect) els.densitySelect.value = clean;
      if (persist) {
        try { localStorage.setItem(DENSITY_MODE_KEY, clean); } catch (_) {}
      }
    }

    function applyUIMode(mode, persist) {
      const clean = String(mode || 'easy').toLowerCase() === 'pro' ? 'pro' : 'easy';
      state.uiMode = clean;
      document.body.classList.toggle('ui-easy', clean === 'easy');
      if (els.uiModeSelect) els.uiModeSelect.value = clean;
      if (clean === 'easy') {
        const activePane = document.querySelector('.tab-pane.active');
        if (activePane && activePane.getAttribute('data-tab-pane') === 'admin') {
          switchTab('session');
        }
      }
      if (persist) {
        try { localStorage.setItem(UI_MODE_KEY, clean); } catch (_) {}
      }
    }

    function readRoomTemplates() {
      try {
        const raw = localStorage.getItem(ROOM_TEMPLATE_KEY) || '[]';
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.slice(0, 12) : [];
      } catch (_) {
        return [];
      }
    }

    function writeRoomTemplates(list) {
      try { localStorage.setItem(ROOM_TEMPLATE_KEY, JSON.stringify((Array.isArray(list) ? list : []).slice(0, 12))); } catch (_) {}
    }

    function renderTemplateOptions() {
      if (!els.templateSelect) return;
      const rows = readRoomTemplates();
      els.templateSelect.innerHTML = '';
      const first = document.createElement('option');
      first.value = '';
      first.textContent = rows.length ? 'Select template' : 'No saved templates';
      els.templateSelect.appendChild(first);
      for (const t of rows) {
        const opt = document.createElement('option');
        opt.value = String(t.id || '');
        opt.textContent = String(t.name || t.id || 'Template');
        els.templateSelect.appendChild(opt);
      }
    }

    function currentTemplateSnapshot() {
      return {
        accessMode: String((els.accessModeSelect && els.accessModeSelect.value) || 'public'),
        shareQuality: String((els.shareQualitySelect && els.shareQualitySelect.value) || 'high'),
        movieQuality: String((els.movieQualitySelect && els.movieQualitySelect.value) || 'high'),
        webcamQuality: String((els.webcamQualitySelect && els.webcamQualitySelect.value) || 'high'),
        audioProfile: String((els.audioProfileSelect && els.audioProfileSelect.value) || 'cinema'),
        allowWebcam: String((els.webcamPolicySelect && els.webcamPolicySelect.value) || 'allow') !== 'deny',
      };
    }

    function applyTemplateSnapshot(snap) {
      if (!snap || typeof snap !== 'object') return;
      if (els.accessModeSelect && snap.accessMode) els.accessModeSelect.value = String(snap.accessMode);
      if (els.shareQualitySelect && snap.shareQuality) els.shareQualitySelect.value = String(snap.shareQuality);
      if (els.movieQualitySelect && snap.movieQuality) els.movieQualitySelect.value = String(snap.movieQuality);
      if (els.webcamQualitySelect && snap.webcamQuality) els.webcamQualitySelect.value = String(snap.webcamQuality);
      if (els.audioProfileSelect && snap.audioProfile) els.audioProfileSelect.value = String(snap.audioProfile);
      if (els.webcamPolicySelect) els.webcamPolicySelect.value = snap.allowWebcam ? 'allow' : 'deny';
    }

    async function runHostMacro(kind) {
      const k = String(kind || '').toLowerCase();
      if (k !== 'main_event' && !state.isHost) {
        setStatus(false, 'Only host can run macros.');
        return;
      }
      if (k === 'start') {
        await sendControl('set_access_mode', { accessMode: 'public' });
        await sendControl('set_webcam_policy', { allowWebcam: true });
        setStatus(true, 'Macro: Start Party applied.');
      } else if (k === 'intermission') {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        await sendControl('chat', { message: 'Intermission started. We will resume shortly.' });
        setStatus(true, 'Macro: Intermission applied.');
      } else if (k === 'wrap') {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        await sendControl('set_access_mode', { accessMode: 'closed' });
        await sendControl('chat', { message: 'Watch party is wrapping up. Thanks for joining.' });
        setStatus(true, 'Macro: Wrap Up applied.');
      } else if (k === 'main_event') {
        const signedInAdmin = !!(state.adminToken && state.adminUsername);
        if (!signedInAdmin) {
          throw new Error('Admin sign-in required for Main Event broadcast mode.');
        }
        state.mainEventEnabled = true;
        renderMainEventState();
        if (!state.roomCode) {
          if (els.accessModeSelect) els.accessModeSelect.value = 'public';
          if (els.mediaModeSelect) {
            applyMediaModeState('broadcast', false);
            els.mediaModeSelect.value = 'broadcast';
          }
          if (els.shareQualitySelect) els.shareQualitySelect.value = 'balanced';
          if (els.movieQualitySelect) els.movieQualitySelect.value = 'high';
          if (els.webcamPolicySelect) els.webcamPolicySelect.value = 'deny';
          if (els.audioProfileSelect) els.audioProfileSelect.value = 'cinema';
          if (els.titleInput && !String(els.titleInput.value || '').trim()) {
            els.titleInput.value = 'Main Event Night';
          }
          setStatus(true, 'Main Event preset applied. Create room to launch Broadcast mode.');
          switchTab('host');
          setWizardStep(2);
          return;
        }
        if (currentMediaMode() !== 'broadcast') {
          throw new Error('Room is already live in non-broadcast mode. Start a new room for Main Event.');
        }
        if (state.isHost) {
          await sendControl('set_access_mode', { accessMode: 'public' });
          await sendControl('set_webcam_policy', { allowWebcam: false });
          await sendControl('chat', { message: 'Main Event mode is live. Broadcast mode enabled for high audience scale.' });
        }
        setStatus(true, 'Main Event mode applied to current broadcast room.');
      } else if (k === 'main_event_off') {
        const signedInAdmin = !!(state.adminToken && state.adminUsername);
        if (!signedInAdmin) {
          throw new Error('Admin sign-in required to disable Main Event mode.');
        }
        state.mainEventEnabled = false;
        renderMainEventState();
        if (!state.roomCode) {
          if (els.accessModeSelect) els.accessModeSelect.value = 'invite';
          if (els.mediaModeSelect) {
            applyMediaModeState('webrtc', false);
            els.mediaModeSelect.value = 'webrtc';
          }
          if (els.shareQualitySelect) els.shareQualitySelect.value = 'high';
          if (els.webcamPolicySelect) els.webcamPolicySelect.value = 'allow';
          setStatus(true, 'Main Event preset disabled.');
          return;
        }
        if (state.isHost) {
          await sendControl('set_access_mode', { accessMode: 'invite' });
          await sendControl('set_webcam_policy', { allowWebcam: true });
          await sendControl('chat', { message: 'Main Event mode has been disabled by admin.' });
        }
        setStatus(true, 'Main Event mode disabled.');
      }
    }

    function updateHealthStrip(room) {
      if (els.latencyChip) {
        const ms = Math.max(0, Math.round(Number(state.lastPollLatencyMs || 0)));
        els.latencyChip.textContent = `Latency ${ms}ms`;
      }
      if (els.reconnectChip) {
        els.reconnectChip.textContent = `Reconnects ${Number(state.reconnectCount || 0)}`;
      }
      if (els.driftChip) {
        const drift = room ? Math.abs((Number(els.player.currentTime) || 0) - (Number(room.playbackSec) || 0)) : 0;
        els.driftChip.textContent = `Drift ${drift.toFixed(1)}s`;
      }
    }

    function isPremiumUser() {
      return !!(state.userToken && state.userEmail);
    }

    function normalizedDonationTier() {
      const t = String(state.donationTier || 'free').trim().toLowerCase();
      if (t === 'pro' || t === 'supporter') return t;
      return 'free';
    }

    function hasTier(required) {
      const want = String(required || 'free').toLowerCase();
      const rank = { free: 0, supporter: 1, pro: 2 };
      return (rank[normalizedDonationTier()] || 0) >= (rank[want] || 0);
    }

    function enforceDonationGates() {
      const tier = normalizedDonationTier();
      if (els.mediaModeSelect && els.mediaModeSelect.value === 'sfu' && !hasTier('pro')) {
        els.mediaModeSelect.value = 'webrtc';
        applyMediaModeState('webrtc', false);
      }
      if (els.shareQualitySelect && els.shareQualitySelect.value === 'ultra' && !hasTier('supporter')) {
        els.shareQualitySelect.value = 'high';
      }
      if (els.movieQualitySelect && els.movieQualitySelect.value === 'ultra' && !hasTier('supporter')) {
        els.movieQualitySelect.value = 'high';
      }
      if (els.webcamQualitySelect && els.webcamQualitySelect.value === 'ultra' && !hasTier('supporter')) {
        els.webcamQualitySelect.value = 'high';
      }
      updateMediaModeGate();
      if (els.userBadge && isPremiumUser()) {
        els.userBadge.textContent = `Premium: ${state.userDisplayName || state.userEmail} Â· Tier: ${tier}`;
      }
    }

    function renderPremiumState() {
      const premium = isPremiumUser();
      if (els.accountGuestWrap) els.accountGuestWrap.classList.toggle('hidden', premium);
      if (els.accountUserWrap) els.accountUserWrap.classList.toggle('hidden', !premium);
      if (els.userBadge) {
        els.userBadge.textContent = premium
          ? `Premium: ${state.userDisplayName || state.userEmail} Â· Tier: ${normalizedDonationTier()}`
          : 'Not signed in';
      }
      if (els.macroStartBtn) els.macroStartBtn.disabled = !premium;
      if (els.macroIntermissionBtn) els.macroIntermissionBtn.disabled = !premium;
      if (els.macroWrapBtn) els.macroWrapBtn.disabled = !premium;
      if (!premium) state.mainEventEnabled = false;
      if (els.saveTemplateBtn) els.saveTemplateBtn.disabled = !premium;
      if (els.applyTemplateBtn) els.applyTemplateBtn.disabled = !premium;
      if (els.saveRoomBtn) els.saveRoomBtn.disabled = !premium;
      if (els.joinSavedRoomBtn) els.joinSavedRoomBtn.disabled = !premium;
      if (els.removeSavedRoomBtn) els.removeSavedRoomBtn.disabled = !premium;
      enforceDonationGates();
      renderMainEventState();
    }

    function saveUserSession() {
      try {
        if (!state.userToken || !state.userEmail) {
          localStorage.removeItem(USER_SESSION_KEY);
          return;
        }
        localStorage.setItem(USER_SESSION_KEY, JSON.stringify({
          userToken: state.userToken,
          userEmail: state.userEmail,
          userDisplayName: state.userDisplayName,
          donationTier: normalizedDonationTier(),
        }));
      } catch (_) {}
    }

    function clearUserSession() {
      state.userToken = '';
      state.userEmail = '';
      state.userDisplayName = '';
      state.donationTier = 'free';
      state.savedRooms = [];
      try { localStorage.removeItem(USER_SESSION_KEY); } catch (_) {}
      renderSavedRooms();
      renderPremiumState();
    }

    function renderSavedRooms() {
      if (!els.savedRoomsSelect) return;
      els.savedRoomsSelect.innerHTML = '';
      const list = Array.isArray(state.savedRooms) ? state.savedRooms : [];
      if (!list.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = isPremiumUser() ? 'No saved rooms yet' : 'Sign in for saved rooms';
        els.savedRoomsSelect.appendChild(opt);
        return;
      }
      for (const row of list) {
        const opt = document.createElement('option');
        opt.value = String(row.roomCode || '');
        const title = String(row.savedName || row.roomTitle || row.roomCode || '');
        opt.textContent = `${title} (${String(row.roomCode || '')})`;
        els.savedRoomsSelect.appendChild(opt);
      }
    }

    async function refreshSavedRooms() {
      if (!isPremiumUser()) {
        state.savedRooms = [];
        renderSavedRooms();
        return;
      }
      const data = await apiRequest('POST', '/api/watch/user/saved-rooms', { userToken: state.userToken });
      state.savedRooms = Array.isArray(data.rooms) ? data.rooms : [];
      renderSavedRooms();
    }

    async function userLogin() {
      const username = String((els.userEmailInput && els.userEmailInput.value) || '').trim().toLowerCase();
      const password = String((els.userPassInput && els.userPassInput.value) || '').trim();
      if (!username || !password) throw new Error('Enter email and password.');
      const data = await apiRequest('POST', '/api/watch/user/login', { username, password });
      state.userToken = String(data.userToken || '');
      state.userEmail = String(data.username || username);
      state.userDisplayName = String(data.displayName || '');
      state.donationTier = String(data.donationTier || 'free').toLowerCase();
      saveUserSession();
      renderPremiumState();
      await refreshSavedRooms();
      setStatus(true, 'Premium account connected.');
    }

    async function userRegister() {
      const username = String((els.userEmailInput && els.userEmailInput.value) || '').trim().toLowerCase();
      const password = String((els.userPassInput && els.userPassInput.value) || '').trim();
      const displayName = String((els.userDisplayInput && els.userDisplayInput.value) || '').trim() || (els.displayName && els.displayName.value.trim()) || 'Viewer';
      if (!username || !password) throw new Error('Enter email and password.');
      const data = await apiRequest('POST', '/api/watch/user/register', { username, password, displayName });
      state.userToken = String(data.userToken || '');
      state.userEmail = String(data.username || username);
      state.userDisplayName = String(data.displayName || displayName);
      state.donationTier = String(data.donationTier || 'free').toLowerCase();
      saveUserSession();
      renderPremiumState();
      await refreshSavedRooms();
      setStatus(true, 'Premium account created.');
    }

    async function requestPasswordReset() {
      const username = String((els.userEmailInput && els.userEmailInput.value) || '').trim().toLowerCase();
      const help = `Account recovery is handled by admins in Discord.\nEmail: ${username || '(not provided)'}\nOpen Discord support now?`;
      const open = window.confirm(help);
      if (!open) {
        setStatus(true, 'Account recovery is Discord/admin only.');
        return;
      }
      try {
        window.open('https://discord.gg/4uRUSAN498', '_blank', 'noopener');
      } catch (_) {}
      setStatus(true, 'Opened Discord support for account recovery.');
    }

    async function userLogout() {
      const token = String(state.userToken || '').trim();
      if (token) {
        try { await apiRequest('POST', '/api/watch/user/logout', { userToken: token }); } catch (_) {}
      }
      clearUserSession();
      setStatus(true, 'Signed out.');
    }

    async function saveCurrentRoomForUser() {
      if (!isPremiumUser()) return;
      const roomCode = normalizeRoomCode(state.roomCode || els.roomInput.value);
      if (!roomCode) {
        setStatus(false, 'Join a room first.');
        return;
      }
      const savedName = String(window.prompt('Saved room name', roomCode) || '').trim();
      await apiRequest('POST', '/api/watch/user/save-room', {
        userToken: state.userToken,
        roomCode,
        roomTitle: String((els.titleInput && els.titleInput.value) || '').trim(),
        savedName,
      });
      await refreshSavedRooms();
      setStatus(true, `Saved room ${roomCode}.`);
    }

    async function apiRequest(method, path, body, queryParams) {
      let lastError = null;
      for (const prefix of API_PREFIXES) {
        try {
          const url = new URL(prefix + path, window.location.origin);
          if (queryParams) {
            Object.entries(queryParams).forEach(([k, v]) => {
              if (v !== undefined && v !== null && v !== '') {
                url.searchParams.set(k, String(v));
              }
            });
          }
          const res = await fetch(url.toString(), {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: body ? JSON.stringify(body) : undefined,
            cache: 'no-store'
          });
          const text = await res.text();
          let data = {};
          try { data = text ? JSON.parse(text) : {}; } catch (_) {}
          if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
          return data;
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('request_failed');
    }

    async function sendControl(action, extra) {
      if (!state.roomCode || !state.participantToken) return;
      const body = Object.assign({
        roomCode: state.roomCode,
        participantToken: state.participantToken,
        action
      }, extra || {});
      return await apiRequest('POST', '/api/watch/control', body);
    }

    function delayMs(ms) {
      return new Promise((resolve) => setTimeout(resolve, Math.max(0, Number(ms) || 0)));
    }

    function stopPollingLoop() {
      state.pollLoopActive = false;
    }

    async function startPollingLoop() {
      if (state.pollLoopActive) return;
      state.pollLoopActive = true;
      while (state.pollLoopActive && state.roomCode && state.participantToken) {
        const ok = await pollState();
        if (!state.pollLoopActive) break;
        if (!ok) await delayMs(POLL_RETRY_MS);
      }
    }

    function saveSession() {
      try {
        if (!state.roomCode || !state.participantToken) return;
        localStorage.setItem(
          SESSION_KEY,
          JSON.stringify({
            roomCode: state.roomCode,
            participantToken: state.participantToken,
            participantId: state.participantId || '',
            isHost: !!state.isHost
          })
        );
      } catch (_) {}
    }

    function clearSession() {
      try { localStorage.removeItem(SESSION_KEY); } catch (_) {}
    }

    function upsertIceQueue(participantId, candidate) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      list.push(candidate);
      rtc.pendingCandidates.set(participantId, list);
    }

    async function flushIceQueue(participantId, pc) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      rtc.pendingCandidates.delete(participantId);
      for (const c of list) {
        try { await pc.addIceCandidate(c); } catch (_) {}
      }
    }

    function closePeer(participantId) {
      const row = rtc.peers.get(participantId);
      if (!row) return;
      try { row.pc.close(); } catch (_) {}
      rtc.peers.delete(participantId);
      rtc.pendingCandidates.delete(participantId);
      rtc.offeredTo.delete(participantId);
      rtc.voiceOfferedTo.delete(participantId);
      rtc.camOfferedTo.delete(participantId);
      rtc.adaptive.delete(participantId);
      const audioEl = rtc.audioEls.get(participantId);
      if (audioEl) {
        try { audioEl.srcObject = null; audioEl.remove(); } catch (_) {}
        rtc.audioEls.delete(participantId);
      }
      const camTile = rtc.camEls.get(participantId);
      if (camTile) {
        try { camTile.video.srcObject = null; camTile.wrap.remove(); } catch (_) {}
        rtc.camEls.delete(participantId);
      }
    }

    function ensurePeer(participantId) {
      const existing = rtc.peers.get(participantId);
      if (existing) return existing.pc;
      const pc = new RTCPeerConnection(RTC_CFG);
      pc.onicecandidate = (ev) => {
        if (!ev.candidate) return;
        sendControl('signal', {
          toParticipantId: participantId,
          signalType: 'ice',
          candidate: String(ev.candidate.candidate || '')
        }).catch(() => {});
      };
      pc.onconnectionstatechange = () => {
        if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) closePeer(participantId);
      };
      pc.ontrack = (ev) => {
        const track = ev.track;
        if (track && track.kind === 'audio') {
          let audioEl = rtc.audioEls.get(participantId);
          if (!audioEl) {
            audioEl = document.createElement('audio');
            audioEl.autoplay = true;
            audioEl.playsInline = true;
            audioEl.style.display = 'none';
            document.body.appendChild(audioEl);
            rtc.audioEls.set(participantId, audioEl);
          }
          if (ev.streams && ev.streams[0]) {
            audioEl.srcObject = ev.streams[0];
            audioEl.play().catch(() => {});
          }
          return;
        }
        if (state.isHost && track && track.kind === 'video') {
          const participant = (state.participants || []).find((p) => String(p.participantId || '') === participantId);
          const tile = hostRemoteCamContainer(participantId, participant ? String(participant.displayName || participantId) : participantId);
          if (tile && ev.streams && ev.streams[0]) {
            tile.video.srcObject = ev.streams[0];
            tile.video.play().catch(() => {});
            if (els.remoteWebcamGrid) els.remoteWebcamGrid.classList.remove('hidden-media');
          }
          return;
        }
        if (!state.isHost && ev.streams && ev.streams[0]) {
          els.screenView.srcObject = ev.streams[0];
          els.screenView.muted = false;
          els.screenView.play().catch(() => {});
          setSyncLabel('screen live');
        }
      };
      rtc.peers.set(participantId, { pc });
      return pc;
    }

    function getHostParticipantId() {
      const row = (state.participants || []).find((p) => p && p.isHost);
      return row ? String(row.participantId || '') : '';
    }

    async function syncHostTrackSenders(participantId, pc) {
      if (!state.isHost || !rtc.localScreenStream) return;
      const videoProfile = scaleQualityForAudience(getMovieQualityProfile(), viewerCount());
      const audioProfile = getAudioProfile();
      const tracks = rtc.localScreenStream.getTracks().filter((t) => t.kind === 'video' || t.kind === 'audio');
      for (const track of tracks) {
        const existing = pc.getSenders().find((s) => s.track && s.track.kind === track.kind);
        let sender = existing;
        if (sender) {
          sender.replaceTrack(track).catch(() => {});
        } else {
          sender = pc.addTrack(track, rtc.localScreenStream);
        }
        if (track.kind === 'video') await setSenderQuality(sender, videoProfile);
        if (track.kind === 'audio') await setSenderAudioQuality(sender, audioProfile.streamAudioBitrate);
      }
    }

    async function createOfferFor(participantId) {
      if (!state.isHost || !rtc.localScreenStream || !participantId) return;
      const pc = ensurePeer(participantId);
      await syncHostTrackSenders(participantId, pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.offeredTo.add(participantId);
    }

    async function broadcastOffersToViewers() {
      if (!state.isHost || !rtc.localScreenStream) return;
      const viewerIds = (state.participants || [])
        .filter((p) => p && !p.isSelf && !p.isHost)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(viewerIds);
      for (const pid of Array.from(rtc.peers.keys())) {
        if (!keep.has(pid)) closePeer(pid);
      }
      for (const pid of viewerIds) {
        if (!rtc.offeredTo.has(pid)) {
          try { await createOfferFor(pid); } catch (_) {}
        }
      }
    }

    async function startScreenShare() {
      if (!state.isHost) return;
      if (!window.isSecureContext) {
        throw new Error('Open Telewatch over HTTPS to share your screen.');
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        throw new Error('Browser screen-share API unavailable. Use latest Chrome/Edge/Firefox.');
      }
      const surface = String((els.shareSurfaceSelect && els.shareSurfaceSelect.value) || 'auto');
      const audioMode = String((els.shareAudioSelect && els.shareAudioSelect.value) || 'auto');
      const viewers = viewerCount();
      const captureQuality = scaleQualityForAudience(getShareQualityProfile(), viewers);
      const movieQuality = scaleQualityForAudience(getMovieQualityProfile(), viewers);
      const videoCfg = {};
      videoCfg.width = { ideal: captureQuality.width };
      videoCfg.height = { ideal: captureQuality.height };
      videoCfg.frameRate = { ideal: captureQuality.frameRate, max: captureQuality.maxFramerate };
      if (surface === 'browser') {
        videoCfg.displaySurface = 'browser';
        videoCfg.selfBrowserSurface = 'exclude';
      } else if (surface === 'window') {
        videoCfg.displaySurface = 'window';
      } else if (surface === 'monitor') {
        videoCfg.displaySurface = 'monitor';
      }
      const constraints = {
        video: Object.keys(videoCfg).length ? videoCfg : true,
        audio: audioMode !== 'off'
      };
      if (audioMode === 'tab') {
        constraints.preferCurrentTab = true;
      } else if (audioMode === 'system') {
        constraints.systemAudio = 'include';
      }
      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
      rtc.localScreenStream = stream;
      const vidTrack = stream.getVideoTracks()[0];
      const audTrack = stream.getAudioTracks()[0];
      if (els.shareSourceInfo) {
        els.shareSourceInfo.textContent = 'Selected share source: ' + (vidTrack && vidTrack.label ? vidTrack.label : 'unknown');
      }
      if (els.shareAudioInfo) {
        els.shareAudioInfo.textContent = 'Selected share audio: ' + (audTrack && audTrack.label ? audTrack.label : 'none');
      }
      setStatus(true, `Sharing capture ${captureQuality.key} / movie ${movieQuality.key} (${viewers} viewers).`);
      els.screenView.srcObject = stream;
      els.screenView.muted = true;
      try { await els.screenView.play(); } catch (_) {}
      els.startShareBtn.disabled = true;
      els.stopShareBtn.disabled = false;
      setWizardStep(3);
      setSyncLabel('sharing monitor/tab');
      updateStatusChips((state.participants || []).length);
      const track = stream.getVideoTracks()[0];
      if (track) {
        track.addEventListener('ended', () => {
          stopScreenShare().catch(() => {});
        });
      }
      const hasAudio = stream.getAudioTracks().length > 0;
      if (hasAudio) {
        addEventLine('Screen share audio detected and will be sent to viewers.');
      } else {
        addEventLine('No share audio detected. In picker enable tab/system audio.');
      }
      if (isSfuMode()) {
        await ensureSfuConnected();
        if (!sfu.room) throw new Error('SFU room unavailable.');
        if (sfu.localScreenTrack) {
          try { await sfu.room.localParticipant.unpublishTrack(sfu.localScreenTrack); } catch (_) {}
        }
        if (sfu.localScreenAudioTrack) {
          try { await sfu.room.localParticipant.unpublishTrack(sfu.localScreenAudioTrack); } catch (_) {}
        }
        if (vidTrack) {
          await sfu.room.localParticipant.publishTrack(vidTrack, { name: 'screen' });
          sfu.localScreenTrack = vidTrack;
        }
        if (audTrack) {
          await sfu.room.localParticipant.publishTrack(audTrack, { name: 'screen-audio' });
          sfu.localScreenAudioTrack = audTrack;
        }
        updateMediaVisibility();
        updateHostPreview();
        return;
      }
      await broadcastOffersToViewers();
      startAdaptiveLoop();
      updateMediaVisibility();
      updateHostPreview();
    }

    async function stopScreenShare() {
      if (rtc.localScreenStream) {
        for (const t of rtc.localScreenStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localScreenStream = null;
      if (isSfuMode() && sfu.room) {
        if (sfu.localScreenTrack) {
          try { await sfu.room.localParticipant.unpublishTrack(sfu.localScreenTrack); } catch (_) {}
        }
        if (sfu.localScreenAudioTrack) {
          try { await sfu.room.localParticipant.unpublishTrack(sfu.localScreenAudioTrack); } catch (_) {}
        }
      }
      sfu.localScreenTrack = null;
      sfu.localScreenAudioTrack = null;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      if (state.isHost) {
        els.screenView.srcObject = null;
      }
      for (const pid of Array.from(rtc.peers.keys())) closePeer(pid);
      stopAdaptiveLoop();
      setSyncLabel('share stopped');
      updateStatusChips((state.participants || []).length);
      if (els.shareSourceInfo) els.shareSourceInfo.textContent = 'Selected share source: none';
      if (els.shareAudioInfo) els.shareAudioInfo.textContent = 'Selected share audio: none';
      updateMediaVisibility();
      updateHostPreview();
    }

    async function processSignal(payload) {
      if (isSfuMode()) return;
      const toId = String(payload.toParticipantId || '');
      if (!toId || toId !== state.participantId) return;
      const fromId = String(payload.fromParticipantId || '');
      const kind = String(payload.signalType || '').toLowerCase();
      if (!fromId || !kind) return;
      const pc = ensurePeer(fromId);
      if (state.isHost) await syncHostTrackSenders(fromId, pc);
      if (kind === 'offer') {
        await pc.setRemoteDescription({ type: 'offer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
        if (voiceOn()) addLocalVoiceTrackToPeer(pc);
        if (camOn() && !state.isHost && fromId === getHostParticipantId()) addLocalCamTrackToPeer(pc);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await sendControl('signal', {
          toParticipantId: fromId,
          signalType: 'answer',
          sdp: String(answer.sdp || '')
        });
      } else if (kind === 'answer') {
        await pc.setRemoteDescription({ type: 'answer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
      } else if (kind === 'ice') {
        const candidate = String(payload.candidate || '');
        if (!candidate) return;
        const iceObj = { candidate, sdpMid: '0', sdpMLineIndex: 0 };
        if (pc.remoteDescription) {
          try { await pc.addIceCandidate(iceObj); } catch (_) {}
        } else {
          upsertIceQueue(fromId, iceObj);
        }
      }
    }

    async function createRoom() {
      const inviteCode = parseInviteRoom(els.inviteInput && els.inviteInput.value);
      const chosenCode = normalizeRoomCode(inviteCode || els.roomInput.value);
      const selectedTheme = Object.prototype.hasOwnProperty.call(THEMES, String((els.themeSelect && els.themeSelect.value) || ''))
        ? String(els.themeSelect.value)
        : (state.localThemeKey || 'clean');
      const payload = {
        roomCode: chosenCode || undefined,
        displayName: els.displayName.value.trim() || 'Host',
        title: els.titleInput.value.trim(),
        mediaUrl: els.mediaInput.value.trim(),
        themeKey: selectedTheme,
        mediaMode: currentMediaMode(),
        adminToken: String(state.adminToken || ''),
        accessMode: String((els.accessModeSelect && els.accessModeSelect.value) || 'public').trim().toLowerCase()
      };
      const data = await apiRequest('POST', '/api/watch/create', payload);
      state.roomCode = data.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = true;
      state.sinceEventId = 0;
      applyMediaModeState(String(data.mediaMode || payload.mediaMode || 'webrtc'), true);
      state.roomThemeKey = selectedTheme || 'clean';
      applyTheme(state.roomThemeKey, false);
      els.roomInput.value = state.roomCode;
      saveRecentRoom(state.roomCode);
      if (isPremiumUser()) {
        apiRequest('POST', '/api/watch/user/save-room', {
          userToken: state.userToken,
          roomCode: state.roomCode,
          roomTitle: String((els.titleInput && els.titleInput.value) || '').trim(),
          savedName: '',
        }).then(() => refreshSavedRooms()).catch(() => {});
      }
      onSessionStart();
      addEventLine('Room created: ' + state.roomCode);
    }

    async function joinRoom() {
      const inviteCode = parseInviteRoom(els.inviteInput && els.inviteInput.value);
      const roomCode = normalizeRoomCode(inviteCode || els.roomInput.value);
      const displayName = els.displayName.value.trim() || '';
      const requestToken = readPendingJoinToken(roomCode, displayName);
      const inviteToken = String(state.inviteToken || '').trim();
      const payload = {
        roomCode,
        displayName
      };
      if (requestToken) payload.requestToken = requestToken;
      if (inviteToken) payload.inviteToken = inviteToken;
      const data = await apiRequest('POST', '/api/watch/join', payload);
      if (data && data.pendingApproval) {
        state.pendingJoinToken = String(data.requestToken || requestToken || '');
        writePendingJoinToken(roomCode, displayName, state.pendingJoinToken);
        setStatus(false, 'Join request sent. Waiting for host approval...');
        return;
      }
      writePendingJoinToken(roomCode, displayName, '');
      state.pendingJoinToken = '';
      state.roomCode = payload.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = !!data.isHost;
      state.inviteToken = '';
      state.sinceEventId = 0;
      applyMediaModeState(String((data.room && data.room.mediaMode) || state.mediaMode || 'webrtc'), true);
      onSessionStart();
      saveRecentRoom(state.roomCode);
      if (isPremiumUser()) {
        apiRequest('POST', '/api/watch/user/save-room', {
          userToken: state.userToken,
          roomCode: state.roomCode,
          roomTitle: String((data.room && data.room.title) || ''),
          savedName: '',
        }).then(() => refreshSavedRooms()).catch(() => {});
      }
      applyRoomState(data.room || null, true);
      addEventLine('Joined room: ' + state.roomCode);
    }

    async function quickHost() {
      if (!els.titleInput.value.trim()) {
        const titleGuess = document.title.replace(/\s*\|\s*Frenzy.*$/i, '').trim();
        els.titleInput.value = titleGuess || 'Watch Party';
      }
      if (!state.roomCode || !state.participantToken) {
        await createRoom();
      }
      await copyInviteLink();
      switchTab('host');
      setStatus(true, 'Quick Host ready. Invite copied.');
    }

    async function deleteRoomByCode(codeOverride) {
      const code = normalizeRoomCode(codeOverride || els.adminDeleteCodeInput.value || els.roomInput.value || state.roomCode);
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!code) {
        setStatus(false, 'Enter a room code first.');
        return;
      }
      const ok = window.confirm(`Delete room code ${code}?`);
      if (!ok) return;
      const data = await apiRequest('POST', '/api/watch/delete', {
        roomCode: code,
        adminCode,
        adminToken: state.adminToken,
      });
      setStatus(false, `Room ${data.roomCode || code} deleted.`);
      addEventLine(`Room ${data.roomCode || code} deleted.`);
    }

    function renderAdminIdentity() {
      const signedIn = !!(state.adminToken && state.adminUsername);
      els.adminWhoami.textContent = signedIn ? ('Admin: ' + state.adminUsername) : 'Admin: not signed in';
      els.adminLoginPanel.classList.toggle('hidden', signedIn);
      els.adminToolsPanel.classList.toggle('hidden', !signedIn);
      if (els.adminRoomsBlock) els.adminRoomsBlock.classList.toggle('hidden', !signedIn);
      setEventsVisibility();
      updateMediaModeGate();
      renderMainEventState();
      if (adminRoomsTimer) {
        clearInterval(adminRoomsTimer);
        adminRoomsTimer = null;
      }
      if (signedIn) {
        adminRoomsTimer = setInterval(() => {
          refreshAdminRooms().catch(() => {});
        }, 10000);
      }
    }

    function saveAdminSession() {
      try {
        if (!state.adminToken || !state.adminUsername) {
          localStorage.removeItem(ADMIN_SESSION_KEY);
          return;
        }
        localStorage.setItem(ADMIN_SESSION_KEY, JSON.stringify({
          adminToken: state.adminToken,
          adminUsername: state.adminUsername
        }));
      } catch (_) {}
    }

    function clearAdminSession() {
      state.adminToken = '';
      state.adminUsername = '';
      try { localStorage.removeItem(ADMIN_SESSION_KEY); } catch (_) {}
      renderAdminIdentity();
    }

    async function adminLogin() {
      const username = String(els.adminUserInput.value || '').trim().toLowerCase();
      const password = String(els.adminPassInput.value || '').trim();
      if (!username || !password) {
        throw new Error('Enter admin username and password.');
      }
      const data = await apiRequest('POST', '/api/watch/admin/login', { username, password });
      state.adminToken = String(data.adminToken || '');
      state.adminUsername = String(data.username || username);
      saveAdminSession();
      renderAdminIdentity();
      await refreshAdminRooms().catch(() => {});
      await refreshAdminList();
      await refreshBlocks().catch(() => {});
      setStatus(true, 'Admin signed in.');
    }

    async function addAdminUser() {
      const newUsername = String(els.newAdminUserInput.value || '').trim().toLowerCase();
      const newPassword = String(els.newAdminPassInput.value || '').trim();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!adminCode) throw new Error('Admin code required.');
      if (!newUsername || !newPassword) throw new Error('Enter new admin username and password.');
      await apiRequest('POST', '/api/watch/admin/add', {
        adminToken: state.adminToken,
        adminCode,
        newUsername,
        newPassword
      });
      els.newAdminPassInput.value = '';
      await refreshAdminList();
      setStatus(true, 'Admin user added: ' + newUsername);
      addEventLine('Admin added: ' + newUsername);
    }

    async function refreshAdminList() {
      if (!state.adminToken) return;
      const data = await apiRequest('POST', '/api/watch/admin/list', { adminToken: state.adminToken });
      const admins = Array.isArray(data.admins) ? data.admins : [];
      els.adminListSelect.innerHTML = '';
      for (const row of admins) {
        const opt = document.createElement('option');
        opt.value = row.username;
        opt.textContent = row.isOwner ? `${row.username} (owner)` : row.username;
        els.adminListSelect.appendChild(opt);
      }
      if (!admins.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No admins found';
        els.adminListSelect.appendChild(opt);
      }
    }

    async function refreshBlocks() {
      if (!state.adminToken) return;
      const [userData, ipData] = await Promise.all([
        apiRequest('POST', '/api/watch/admin/user-block/list', { adminToken: state.adminToken }),
        apiRequest('POST', '/api/watch/admin/ip-block/list', { adminToken: state.adminToken }),
      ]);
      const users = Array.isArray(userData.blocks) ? userData.blocks : [];
      const ips = Array.isArray(ipData.blocks) ? ipData.blocks : [];
      if (els.blockedUsersSelect) {
        els.blockedUsersSelect.innerHTML = '';
        for (const r of users) {
          const o = document.createElement('option');
          o.value = String(r.username || '');
          o.textContent = `${String(r.username || '')}${r.reason ? ' Â· ' + String(r.reason) : ''}`;
          els.blockedUsersSelect.appendChild(o);
        }
        if (!users.length) {
          const o = document.createElement('option');
          o.value = '';
          o.textContent = 'No blocked users';
          els.blockedUsersSelect.appendChild(o);
        }
      }
      if (els.blockedIpsSelect) {
        els.blockedIpsSelect.innerHTML = '';
        for (const r of ips) {
          const o = document.createElement('option');
          o.value = String(r.ipAddress || '');
          o.textContent = `${String(r.ipAddress || '')}${r.reason ? ' Â· ' + String(r.reason) : ''}`;
          els.blockedIpsSelect.appendChild(o);
        }
        if (!ips.length) {
          const o = document.createElement('option');
          o.value = '';
          o.textContent = 'No blocked IPs';
          els.blockedIpsSelect.appendChild(o);
        }
      }
    }

    async function blockUser(shouldBlock) {
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      const adminCode = String(els.adminKeyInput.value || '').trim();
      const username = cleanUsername((els.blockUserInput && els.blockUserInput.value) || (els.blockedUsersSelect && els.blockedUsersSelect.value) || '');
      const reason = String((els.blockReasonInput && els.blockReasonInput.value) || '').trim();
      if (!username) throw new Error('Enter user email.');
      if (shouldBlock) {
        await apiRequest('POST', '/api/watch/admin/user-block/add', { adminToken: state.adminToken, adminCode, username, reason });
      } else {
        await apiRequest('POST', '/api/watch/admin/user-block/remove', { adminToken: state.adminToken, adminCode, username });
      }
      await refreshBlocks();
      setStatus(true, shouldBlock ? `User blocked: ${username}` : `User unblocked: ${username}`);
    }

    async function blockIp(shouldBlock) {
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      const adminCode = String(els.adminKeyInput.value || '').trim();
      const ipAddress = String((els.blockIpInput && els.blockIpInput.value) || (els.blockedIpsSelect && els.blockedIpsSelect.value) || '').trim();
      const reason = String((els.blockReasonInput && els.blockReasonInput.value) || '').trim();
      if (!ipAddress) throw new Error('Enter IP address.');
      if (shouldBlock) {
        await apiRequest('POST', '/api/watch/admin/ip-block/add', { adminToken: state.adminToken, adminCode, ipAddress, reason });
      } else {
        await apiRequest('POST', '/api/watch/admin/ip-block/remove', { adminToken: state.adminToken, adminCode, ipAddress });
      }
      await refreshBlocks();
      setStatus(true, shouldBlock ? `IP blocked: ${ipAddress}` : `IP unblocked: ${ipAddress}`);
    }

    async function setDonationTierForUser() {
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      const adminCode = String(els.adminKeyInput.value || '').trim();
      const username = cleanUsername((els.tierUserInput && els.tierUserInput.value) || '');
      const donationTier = String((els.tierLevelSelect && els.tierLevelSelect.value) || 'free').trim().toLowerCase();
      if (!username) throw new Error('Enter user email.');
      const data = await apiRequest('POST', '/api/watch/admin/user-tier/set', {
        adminToken: state.adminToken,
        adminCode,
        username,
        donationTier,
      });
      if (els.tierResult) {
        els.tierResult.textContent = `Tier status: ${String(data.username || username)} -> ${String(data.donationTier || donationTier)}`;
      }
      setStatus(true, 'Donation tier updated.');
    }

    async function getDonationTierForUser() {
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      const username = cleanUsername((els.tierUserInput && els.tierUserInput.value) || '');
      if (!username) throw new Error('Enter user email.');
      const data = await apiRequest('POST', '/api/watch/admin/user-tier/get', {
        adminToken: state.adminToken,
        username,
      });
      if (els.tierLevelSelect && data.donationTier) {
        els.tierLevelSelect.value = String(data.donationTier).toLowerCase();
      }
      if (els.tierResult) {
        els.tierResult.textContent = `Tier status: ${String(data.username || username)} -> ${String(data.donationTier || 'free')}`;
      }
      setStatus(true, 'Donation tier loaded.');
    }

    function cleanUsername(raw) {
      return String(raw || '').trim().toLowerCase();
    }

    async function removeSelectedAdmin() {
      const username = String((els.adminListSelect && els.adminListSelect.value) || '').trim().toLowerCase();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!username) throw new Error('Select an admin to remove.');
      if (!adminCode) throw new Error('Admin code required.');
      const ok = window.confirm(`Remove admin ${username}?`);
      if (!ok) return;
      await apiRequest('POST', '/api/watch/admin/remove', { adminToken: state.adminToken, adminCode, username });
      await refreshAdminList();
      setStatus(true, `Admin removed: ${username}`);
      addEventLine(`Admin removed: ${username}`);
    }

    async function adminLogout() {
      const token = String(state.adminToken || '').trim();
      if (!token) return;
      try {
        await apiRequest('POST', '/api/watch/admin/logout', { adminToken: token });
      } catch (_) {}
      clearAdminSession();
      setStatus(false, 'Admin signed out.');
      if (els.adminRoomsSelect) els.adminRoomsSelect.innerHTML = '';
      if (els.blockedUsersSelect) els.blockedUsersSelect.innerHTML = '';
      if (els.blockedIpsSelect) els.blockedIpsSelect.innerHTML = '';
    }

    function updateBadges() {
      els.roomBadge.textContent = 'Room: ' + (state.roomCode || 'none');
      els.roleBadge.textContent = 'Role: ' + (state.isHost ? 'host' : 'viewer');
      applyHostOptionsVisibility();
    }

    function onSessionStart() {
      state.chatMessages = new Map();
      state.pinnedMessageId = 0;
      state.chatScopeRoom = state.roomCode || '';
      state.requests = [];
      state.hostMuted = {};
      renderChatFeed();
      updateBadges();
      setThemeControlState();
      els.createBtn.disabled = true;
      els.joinBtn.disabled = true;
      els.setMediaBtn.disabled = !state.isHost;
      els.playBtn.disabled = !state.isHost;
      els.pauseBtn.disabled = !state.isHost;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      els.resetRoomBtn.disabled = !state.isHost;
      els.deleteRoomBtn.disabled = !state.isHost;
      if (els.mediaModeSelect) els.mediaModeSelect.disabled = true;
      if (els.setAccessModeBtn) els.setAccessModeBtn.disabled = !state.isHost;
      if (els.accessModeSelect) els.accessModeSelect.disabled = !state.isHost;
      if (els.inviteTtlInput) els.inviteTtlInput.disabled = !state.isHost;
      if (els.inviteMaxUsesInput) els.inviteMaxUsesInput.disabled = !state.isHost;
      els.chatBtn.disabled = false;
      updateVoiceUi();
      setWizardStep(2);
      switchTab(state.isHost ? 'host' : 'chat');
      stopPollingLoop();
      saveSession();
      updateMediaVisibility();
      updateHostPreview();
      if (isSfuMode()) {
        ensureSfuConnected().catch((err) => {
          const msg = String(err && err.message ? err.message : err);
          setStatus(false, 'SFU connect failed: ' + msg);
        });
      }
      startPollingLoop();
    }

    function applyRoomState(room, force) {
      if (!room) return;
      state.lastRoom = room;
      applyMediaModeState(String(room.mediaMode || state.mediaMode || 'webrtc'), true);
      if (els.joinHint) {
        els.joinHint.textContent = isSfuMode()
          ? 'SFU room active: better scaling for larger watch parties.'
          : (state.clientMode === 'desktop'
            ? 'Desktop mode selected. Create/join opens the FrenzyNet desktop app.'
            : 'Share your room code in Discord voice chat. Everyone runs their own stream account.');
      }
      state.accessMode = String(room.accessMode || 'public');
      state.allowWebcam = room.allowWebcam !== false;
      const perms = room.cohostPerms || {};
      state.cohostPerms = {
        kick: perms.kick !== false,
        mute: perms.mute !== false,
        access: perms.access !== false,
        pin: perms.pin !== false,
      };
      if (els.accessModeSelect && ['public', 'invite', 'closed'].includes(state.accessMode)) {
        els.accessModeSelect.value = state.accessMode;
      }
      if (els.webcamPolicySelect) {
        els.webcamPolicySelect.value = state.allowWebcam ? 'allow' : 'deny';
      }
      if (els.cohostKickPerm) els.cohostKickPerm.checked = !!state.cohostPerms.kick;
      if (els.cohostMutePerm) els.cohostMutePerm.checked = !!state.cohostPerms.mute;
      if (els.cohostAccessPerm) els.cohostAccessPerm.checked = !!state.cohostPerms.access;
      if (els.cohostPinPerm) els.cohostPinPerm.checked = !!state.cohostPerms.pin;
      const roomTheme = Object.prototype.hasOwnProperty.call(THEMES, String(room.themeKey || '')) ? String(room.themeKey) : 'clean';
      state.roomThemeKey = roomTheme;
      applyTheme(roomTheme, false);
      setThemeControlState();
      els.nowTitle.textContent = room.title ? ('Now Playing: ' + room.title) : 'Now Playing';
      if (!state.isHost) {
        els.titleInput.value = room.title || '';
        els.mediaInput.value = room.mediaUrl || '';
        if (!state.allowWebcam && camOn()) {
          stopWebcamShare().catch(() => {});
        }
      }
      updateVoiceUi();
      updateHealthStrip(room);

      const p = els.player;
      const mediaUrl = (room.mediaUrl || '').trim();
      if (mediaUrl && p.src !== mediaUrl) {
        state.suppressOutbound = true;
        p.src = mediaUrl;
        p.load();
        state.suppressOutbound = false;
      }

      const drift = Math.abs((Number(p.currentTime) || 0) - (Number(room.playbackSec) || 0));
      if (force || drift > 1.5) {
        try {
          state.suppressOutbound = true;
          p.currentTime = Number(room.playbackSec) || 0;
          state.suppressOutbound = false;
          setSyncLabel('aligned');
        } catch (_) {
          state.suppressOutbound = false;
        }
      }

      if (!state.isHost) {
        if (room.isPlaying && p.paused) {
          state.suppressOutbound = true;
          p.play().catch(() => {});
          state.suppressOutbound = false;
        }
        if (!room.isPlaying && !p.paused) {
          state.suppressOutbound = true;
          p.pause();
          state.suppressOutbound = false;
        }
      }
      updateHostPreview();
    }

    async function setupMedia() {
      if (!state.isHost) return;
      await sendControl('set_media', {
        mediaUrl: els.mediaInput.value.trim(),
        title: els.titleInput.value.trim()
      });
      setSyncLabel('media updated');
      updateHostPreview();
    }

    async function sendChat() {
      const message = els.chatInput.value.trim();
      if (!message) return;
      await sendControl('chat', { message });
      els.chatInput.value = '';
    }

    async function copyInviteLink() {
      if (!state.roomCode) return;
      let url = window.location.origin + '/telewatch/?room=' + encodeURIComponent(state.roomCode);
      if (state.isHost) {
        try {
          const ttlRaw = Number((els.inviteTtlInput && els.inviteTtlInput.value) || 720);
          const maxUsesRaw = Number((els.inviteMaxUsesInput && els.inviteMaxUsesInput.value) || 0);
          const ttlMinutes = Math.max(5, Math.min(10080, Math.round(Number.isFinite(ttlRaw) ? ttlRaw : 720)));
          const maxUses = Math.max(0, Math.min(500, Math.round(Number.isFinite(maxUsesRaw) ? maxUsesRaw : 0)));
          if (els.inviteTtlInput) els.inviteTtlInput.value = String(ttlMinutes);
          if (els.inviteMaxUsesInput) els.inviteMaxUsesInput.value = String(maxUses);
          writeInviteSettings(ttlMinutes, maxUses);
          const res = await sendControl('create_invite', { ttlMinutes, maxUses });
          const token = String(res && res.actionPayload && res.actionPayload.inviteToken ? res.actionPayload.inviteToken : '').trim();
          if (token) {
            url += '&invite=' + encodeURIComponent(token);
          }
        } catch (_) {}
      }
      try {
        await navigator.clipboard.writeText(url);
        setSyncLabel('watch link copied');
      } catch (_) {
        setSyncLabel(url);
      }
    }

    async function resetRoom() {
      if (!state.isHost) return;
      await sendControl('reset_room', { title: els.titleInput.value.trim() });
      els.mediaInput.value = '';
      els.player.pause();
      try { els.player.currentTime = 0; } catch (_) {}
      setSyncLabel('room reset');
      addEventLine('Room reset by host');
    }

    async function pollState() {
      if (!state.roomCode || !state.participantToken) return false;
      try {
        const pollStart = performance.now();
        const waitMs = state.sinceEventId > 0 ? LONG_POLL_WAIT_MS : 0;
        const data = await apiRequest('GET', '/api/watch/state', null, {
          roomCode: state.roomCode,
          participantToken: state.participantToken,
          sinceEventId: state.sinceEventId,
          waitMs
        });
        state.lastPollLatencyMs = Math.max(0, performance.now() - pollStart);
        state.participantId = data.selfParticipantId || state.participantId;
        state.participants = Array.isArray(data.participants) ? data.participants : [];
        state.pendingJoinRequests = Array.isArray(data.pendingJoinRequests) ? data.pendingJoinRequests : [];
        state.autoRejoinTried = false;
        refreshMuteTargets();
        updateVoiceUi();
        renderParticipants();
        renderJoinRequests();
        setStatus(true, 'Connected Â· active viewers: ' + (data.activeCount || 0));
        updateStatusChips(data.activeCount || 0);
        applyRoomState(data.room || null, false);
        updateMediaVisibility();
        if (!isSfuMode() && state.isHost && rtc.localScreenStream) {
          await broadcastOffersToViewers();
        }
        if (!isSfuMode() && voiceOn()) {
          await syncVoiceOffers();
        }
        if (!isSfuMode() && camOn() && !state.isHost) {
          await syncCamOfferToHost();
        }
        for (const ev of (data.events || [])) {
          state.sinceEventId = Math.max(state.sinceEventId, Number(ev.id) || 0);
          const actor = ev.actor || 'user';
          if (ev.type === 'signal') {
            await processSignal(ev.payload || {});
            continue;
          }
          if (ev.type === 'reaction') {
            addReaction(String(ev.payload?.emoji || 'ðŸ‘'), actor);
            continue;
          }
          if (ev.type === 'request_item') {
            upsertRequestFromEvent(ev);
            renderRequestQueue();
            addEventLine(actor + ' Â· request submitted');
            continue;
          }
          if (ev.type === 'resolve_request') {
            resolveRequestFromEvent(ev);
            renderRequestQueue();
            addEventLine(actor + ' Â· request ' + String(ev.payload?.status || 'resolved'));
            continue;
          }
          if (ev.type === 'mute_user') {
            const targetId = String(ev.payload?.toParticipantId || '').toLowerCase();
            const muted = !!ev.payload?.muted;
            if (targetId) state.hostMuted[targetId] = muted;
            if (targetId && targetId === String(state.participantId || '').toLowerCase() && rtc.localVoiceStream) {
              for (const t of rtc.localVoiceStream.getAudioTracks()) t.enabled = !muted;
              updateVoiceUi();
            }
            renderParticipants();
            continue;
          }
          if (ev.type === 'kick_user') {
            const targetId = String(ev.payload?.toParticipantId || '').toLowerCase();
            if (targetId && targetId === String(state.participantId || '').toLowerCase()) {
              stopPollingLoop();
              await disconnectSfu().catch(() => {});
              state.roomCode = '';
              state.chatScopeRoom = '';
              state.participantToken = '';
              state.participantId = '';
              clearSession();
              state.chatMessages = new Map();
              state.pinnedMessageId = 0;
              renderChatFeed();
              await stopWebcamShare().catch(() => {});
              if (els.mediaModeSelect) els.mediaModeSelect.disabled = false;
              setStatus(false, 'You were removed by the host.');
              setSyncLabel('removed');
              updateBadges();
              setThemeControlState();
              return false;
            }
            continue;
          }
          if (ev.type === 'set_webcam_policy') {
            const allowed = !!ev.payload?.allowWebcam;
            state.allowWebcam = allowed;
            updateVoiceUi();
            if (!allowed && !state.isHost && camOn()) {
              await stopWebcamShare().catch(() => {});
              setStatus(false, 'Host disabled participant webcams.');
            }
            continue;
          }
          if (ev.type === 'set_cohost_perms') {
            const perms = ev.payload?.cohostPerms || {};
            state.cohostPerms = {
              kick: perms.kick !== false,
              mute: perms.mute !== false,
              access: perms.access !== false,
              pin: perms.pin !== false,
            };
            if (els.cohostKickPerm) els.cohostKickPerm.checked = !!state.cohostPerms.kick;
            if (els.cohostMutePerm) els.cohostMutePerm.checked = !!state.cohostPerms.mute;
            if (els.cohostAccessPerm) els.cohostAccessPerm.checked = !!state.cohostPerms.access;
            if (els.cohostPinPerm) els.cohostPinPerm.checked = !!state.cohostPerms.pin;
            continue;
          }
          if (ev.type === 'chat') {
            addChatLine(actor, String(ev.payload?.message || ''), Number(ev.id || 0), String(ev.createdAt || ''));
            continue;
          }
          if (ev.type === 'react_chat') {
            const msgId = Number(ev.payload?.messageId || 0);
            const emoji = String(ev.payload?.emoji || '');
            const item = state.chatMessages.get(msgId);
            if (item && emoji) {
              const current = Number((item.reactions && item.reactions[emoji]) || 0);
              item.reactions = Object.assign({}, item.reactions || {}, { [emoji]: current + 1 });
              state.chatMessages.set(msgId, item);
              renderChatFeed();
            }
            continue;
          }
          if (ev.type === 'pin_chat') {
            const msgId = Number(ev.payload?.messageId || 0);
            const pinned = !!ev.payload?.pinned;
            if (pinned) {
              state.pinnedMessageId = msgId;
              for (const [id, item] of state.chatMessages.entries()) {
                item.pinned = id === msgId;
              }
            } else if (state.pinnedMessageId === msgId) {
              state.pinnedMessageId = 0;
              const item = state.chatMessages.get(msgId);
              if (item) item.pinned = false;
            }
            renderChatFeed();
            continue;
          }
          addEventLine(actor + ' Â· ' + ev.type.replace('_', ' '));
        }
      } catch (err) {
        state.reconnectCount = Number(state.reconnectCount || 0) + 1;
        const msg = String(err && err.message ? err.message : 'network_error');
        if (msg.includes('invalid_participant') || msg.includes('HTTP 401')) {
          const prevRoom = String(state.roomCode || '');
          stopPollingLoop();
          await disconnectSfu().catch(() => {});
          clearSession();
          state.chatMessages = new Map();
          state.pinnedMessageId = 0;
          renderChatFeed();
          await stopWebcamShare().catch(() => {});
          state.roomCode = '';
          state.chatScopeRoom = '';
          state.participantToken = '';
          state.participantId = '';
          state.participants = [];
          if (els.mediaModeSelect) els.mediaModeSelect.disabled = false;
          updateBadges();
          const canAttemptAutoJoin = !state.autoRejoinTried && prevRoom && String(els.displayName && els.displayName.value || '').trim();
          if (canAttemptAutoJoin) {
            state.autoRejoinTried = true;
            els.roomInput.value = prevRoom;
            try {
              await joinRoom();
              setStatus(true, 'Session recovered after reconnect.');
              return true;
            } catch (_) {}
          }
          setStatus(false, 'Session expired. Rejoin the room.');
          setSyncLabel('disconnected');
          return false;
        }
        setStatus(false, 'Reconnect pending: ' + msg);
        setSyncLabel('retrying');
        updateStatusChips(0);
        updateHealthStrip(state.lastRoom || null);
        updateMediaVisibility();
        return false;
      }
      return true;
    }

    els.createBtn.addEventListener('click', async () => {
      if (state.clientMode === 'desktop') {
        openDesktopApp('create');
        return;
      }
      try {
        await createRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_capacity_reached')) {
          setStatus(false, 'Room limit reached (35 max). Delete an existing room first.');
          return;
        }
        if (msg.includes('room_code_taken') || msg.includes('409')) {
          setStatus(false, 'Room code already taken. Use a new code or click Join Room.');
          addEventLine('Room code already exists. Try Join Room for that code.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.joinBtn.addEventListener('click', async () => {
      if (state.clientMode === 'desktop') {
        openDesktopApp('join');
        return;
      }
      try {
        await joinRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_closed')) {
          setStatus(false, 'This room is closed. Host must reopen it.');
          return;
        }
        if (msg.includes('invite_invalid')) {
          setStatus(false, 'Invite link expired or invalid. Ask host for a new link.');
          return;
        }
        if (msg.includes('join_banned')) {
          setStatus(false, 'You are temporarily blocked from this room.');
          return;
        }
        if (msg.includes('join_request_denied')) {
          writePendingJoinToken(normalizeRoomCode(els.roomInput.value), els.displayName.value.trim() || '', '');
          setStatus(false, 'Join request denied by host.');
          return;
        }
        if (msg.includes('room_full')) {
          setStatus(false, `Room is full (${ROOM_CAPACITY_LIMIT} people max).`);
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.quickHostBtn) {
      els.quickHostBtn.addEventListener('click', async () => {
        if (state.clientMode === 'desktop') {
          openDesktopApp('quick_host');
          return;
        }
        try {
          await quickHost();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.recentJoinBtn) {
      els.recentJoinBtn.addEventListener('click', async () => {
        const selected = normalizeRoomCode((els.recentRoomsSelect && els.recentRoomsSelect.value) || '');
        if (!selected) {
          setStatus(false, 'Select a recent room first.');
          return;
        }
        els.roomInput.value = selected;
        if (state.clientMode === 'desktop') {
          openDesktopApp('join');
          return;
        }
        try {
          await joinRoom();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.advancedToggleBtn) {
      els.advancedToggleBtn.addEventListener('click', () => {
        const hidden = els.advancedWrap.classList.toggle('hidden');
        els.advancedToggleBtn.textContent = hidden ? 'Show Advanced' : 'Hide Advanced';
      });
    }
    if (els.resetRoomBtn) {
      els.resetRoomBtn.addEventListener('click', async () => {
        try {
          await resetRoom();
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.joinVoiceBtn) {
      els.joinVoiceBtn.addEventListener('click', async () => {
        try { await startVoiceChat(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.leaveVoiceBtn) {
      els.leaveVoiceBtn.addEventListener('click', async () => {
        try { await stopVoiceChat(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.setWebcamPolicyBtn) {
      els.setWebcamPolicyBtn.addEventListener('click', async () => {
        try { await setWebcamPolicy(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.setCohostPermsBtn) {
      els.setCohostPermsBtn.addEventListener('click', async () => {
        try { await setCohostPerms(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.startWebcamBtn) {
      els.startWebcamBtn.addEventListener('click', async () => {
        try { await startWebcamShare(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.stopWebcamBtn) {
      els.stopWebcamBtn.addEventListener('click', async () => {
        try { await stopWebcamShare(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.muteTargetBtn) {
      els.muteTargetBtn.addEventListener('click', async () => {
        try { await hostSetMuteTarget(true); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.unmuteTargetBtn) {
      els.unmuteTargetBtn.addEventListener('click', async () => {
        try { await hostSetMuteTarget(false); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.kickTargetBtn) {
      els.kickTargetBtn.addEventListener('click', async () => {
        try { await kickSelectedUser(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.setAccessModeBtn) {
      els.setAccessModeBtn.addEventListener('click', async () => {
        try { await setAccessMode(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.approveJoinBtn) {
      els.approveJoinBtn.addEventListener('click', async () => {
        try { await resolveJoinRequest('approved'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.denyJoinBtn) {
      els.denyJoinBtn.addEventListener('click', async () => {
        try { await resolveJoinRequest('denied'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
      if (els.copyAdminRoomBtn) {
        els.copyAdminRoomBtn.addEventListener('click', async () => {
          const code = String((els.adminRoomsSelect && els.adminRoomsSelect.value) || '').trim();
          if (!code) return;
        try {
          await navigator.clipboard.writeText(code);
          setStatus(true, 'Copied room code: ' + code);
        } catch (_) {
          setStatus(true, 'Room code: ' + code);
        }
      });
    }
    if (els.adminRoomsSelect) {
      els.adminRoomsSelect.addEventListener('change', () => {
        renderAdminRoomMeta();
      });
    }
    if (els.sendRequestBtn) {
      els.sendRequestBtn.addEventListener('click', async () => {
        try { await sendRequestItem(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.approveRequestBtn) {
      els.approveRequestBtn.addEventListener('click', async () => {
        try { await resolveSelectedRequest('approved'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.denyRequestBtn) {
      els.denyRequestBtn.addEventListener('click', async () => {
        try { await resolveSelectedRequest('denied'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    for (const rbtn of (els.reactionButtons || [])) {
      rbtn.addEventListener('click', async () => {
        try { await sendReaction(rbtn.getAttribute('data-react') || 'ðŸ‘'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.adminLoginBtn) els.adminLoginBtn.addEventListener('click', async () => {
      try {
        await adminLogin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_login_invalid')) {
          setStatus(false, 'Admin login failed. Check username/password.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.refreshAdminsBtn) els.refreshAdminsBtn.addEventListener('click', async () => {
      try {
        await refreshAdminList();
        setStatus(true, 'Admin list refreshed.');
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.addAdminBtn) els.addAdminBtn.addEventListener('click', async () => {
      try {
        await addAdminUser();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        if (msg.includes('admin_auth_required') || msg.includes('admin_auth_invalid')) {
          setStatus(false, 'Sign in as admin before adding admins.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.removeAdminBtn) els.removeAdminBtn.addEventListener('click', async () => {
      try {
        await removeSelectedAdmin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('owner_required')) {
          setStatus(false, 'Only the owner can remove admins.');
          return;
        }
        if (msg.includes('cannot_remove_owner')) {
          setStatus(false, 'Owner account cannot be removed.');
          return;
        }
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        setStatus(false, msg);
      }
    });
    if (els.adminLogoutBtn) els.adminLogoutBtn.addEventListener('click', async () => {
      await adminLogout();
    });
    if (els.refreshBlocksBtn) {
      els.refreshBlocksBtn.addEventListener('click', async () => {
        try { await refreshBlocks(); setStatus(true, 'Block lists refreshed.'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.blockUserBtn) {
      els.blockUserBtn.addEventListener('click', async () => {
        try { await blockUser(true); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.unblockUserBtn) {
      els.unblockUserBtn.addEventListener('click', async () => {
        try { await blockUser(false); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.blockIpBtn) {
      els.blockIpBtn.addEventListener('click', async () => {
        try { await blockIp(true); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.unblockIpBtn) {
      els.unblockIpBtn.addEventListener('click', async () => {
        try { await blockIp(false); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.setTierBtn) {
      els.setTierBtn.addEventListener('click', async () => {
        try { await setDonationTierForUser(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.getTierBtn) {
      els.getTierBtn.addEventListener('click', async () => {
        try { await getDonationTierForUser(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.layoutModeSelect) {
      els.layoutModeSelect.addEventListener('change', () => applyLayoutMode(els.layoutModeSelect.value, true));
    }
    if (els.densitySelect) {
      els.densitySelect.addEventListener('change', () => applyDensityMode(els.densitySelect.value, true));
    }
    if (els.mediaModeSelect) {
      els.mediaModeSelect.addEventListener('change', () => {
        if (state.roomCode) {
          els.mediaModeSelect.value = currentMediaMode();
          return;
        }
        applyMediaModeState(els.mediaModeSelect.value, false);
        enforceDonationGates();
      });
    }
    if (els.shareQualitySelect) els.shareQualitySelect.addEventListener('change', enforceDonationGates);
    if (els.movieQualitySelect) els.movieQualitySelect.addEventListener('change', enforceDonationGates);
    if (els.webcamQualitySelect) {
      els.webcamQualitySelect.addEventListener('change', () => {
        syncQualitySelectors();
        enforceDonationGates();
      });
    }
    if (els.audioProfileSelect) {
      els.audioProfileSelect.addEventListener('change', () => {
        syncQualitySelectors();
      });
    }
    if (els.voiceQualitySelect) {
      els.voiceQualitySelect.addEventListener('change', async () => {
        syncQualitySelectors();
        if (!voiceOn()) return;
        try {
          await stopVoiceChat();
          await startVoiceChat();
          setStatus(true, 'Voice quality updated.');
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.liveWebcamQualitySelect) {
      els.liveWebcamQualitySelect.addEventListener('change', async () => {
        syncQualitySelectors();
        enforceDonationGates();
        if (!camOn()) return;
        try {
          await stopWebcamShare();
          await startWebcamShare();
          setStatus(true, 'Webcam quality updated.');
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.micDeviceSelect) {
      els.micDeviceSelect.addEventListener('change', async () => {
        state.preferredMicId = String(els.micDeviceSelect.value || '').trim();
        persistPreferredMediaDevices();
        if (!voiceOn()) return;
        try {
          await stopVoiceChat();
          await startVoiceChat();
          setStatus(true, 'Microphone switched.');
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.camDeviceSelect) {
      els.camDeviceSelect.addEventListener('change', async () => {
        state.preferredCamId = String(els.camDeviceSelect.value || '').trim();
        persistPreferredMediaDevices();
        if (!camOn()) return;
        try {
          await stopWebcamShare();
          await startWebcamShare();
          setStatus(true, 'Webcam switched.');
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    if (els.refreshDevicesBtn) {
      els.refreshDevicesBtn.addEventListener('click', async () => {
        await warmDevicePermissions();
        await refreshDeviceLists();
        setStatus(true, 'Media devices refreshed.');
      });
    }
    if (els.hostOptionsToggleBtn) {
      els.hostOptionsToggleBtn.addEventListener('click', () => {
        state.hostOptionsMinimized = !state.hostOptionsMinimized;
        try { localStorage.setItem(HOST_OPTIONS_MIN_KEY, state.hostOptionsMinimized ? '1' : '0'); } catch (_) {}
        renderHostOptionsMinimized();
      });
    }
    if (els.uiModeSelect) {
      els.uiModeSelect.addEventListener('change', () => applyUIMode(els.uiModeSelect.value, true));
    }
    if (els.macroStartBtn) {
      els.macroStartBtn.addEventListener('click', async () => { try { await runHostMacro('start'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); } });
    }
    if (els.macroIntermissionBtn) {
      els.macroIntermissionBtn.addEventListener('click', async () => { try { await runHostMacro('intermission'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); } });
    }
    if (els.macroWrapBtn) {
      els.macroWrapBtn.addEventListener('click', async () => { try { await runHostMacro('wrap'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); } });
    }
    if (els.macroMainEventBtn) {
      els.macroMainEventBtn.addEventListener('click', async () => { try { await runHostMacro('main_event'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); } });
    }
    if (els.macroMainEventOffBtn) {
      els.macroMainEventOffBtn.addEventListener('click', async () => { try { await runHostMacro('main_event_off'); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); } });
    }
    if (els.saveTemplateBtn) {
      els.saveTemplateBtn.addEventListener('click', () => {
        const name = String(window.prompt('Template name') || '').trim();
        if (!name) return;
        const rows = readRoomTemplates();
        const id = name.toLowerCase().replace(/[^a-z0-9_-]+/g, '-').slice(0, 24) || ('tpl-' + Date.now());
        const without = rows.filter((r) => String(r.id || '') !== id);
        without.unshift({ id, name, snapshot: currentTemplateSnapshot() });
        writeRoomTemplates(without);
        renderTemplateOptions();
        if (els.templateSelect) els.templateSelect.value = id;
        setStatus(true, 'Template saved.');
      });
    }
    if (els.applyTemplateBtn) {
      els.applyTemplateBtn.addEventListener('click', async () => {
        const id = String((els.templateSelect && els.templateSelect.value) || '').trim();
        const row = readRoomTemplates().find((r) => String(r.id || '') === id);
        if (!row) {
          setStatus(false, 'Select a template first.');
          return;
        }
        applyTemplateSnapshot(row.snapshot || {});
        if (state.isHost && state.roomCode) {
          await setAccessMode().catch(() => {});
          await setWebcamPolicy().catch(() => {});
        }
        setStatus(true, 'Template applied.');
      });
    }
    if (els.userLoginBtn) {
      els.userLoginBtn.addEventListener('click', async () => {
        try { await userLogin(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.userRegisterBtn) {
      els.userRegisterBtn.addEventListener('click', async () => {
        try { await userRegister(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.forgotPassBtn) {
      els.forgotPassBtn.addEventListener('click', async () => {
        try { await requestPasswordReset(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.userLogoutBtn) {
      els.userLogoutBtn.addEventListener('click', async () => {
        await userLogout();
      });
    }
    if (els.saveRoomBtn) {
      els.saveRoomBtn.addEventListener('click', async () => {
        try { await saveCurrentRoomForUser(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.joinSavedRoomBtn) {
      els.joinSavedRoomBtn.addEventListener('click', async () => {
        const code = normalizeRoomCode((els.savedRoomsSelect && els.savedRoomsSelect.value) || '');
        if (!code) return;
        els.roomInput.value = code;
        try { await joinRoom(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    if (els.removeSavedRoomBtn) {
      els.removeSavedRoomBtn.addEventListener('click', async () => {
        if (!isPremiumUser()) return;
        const code = normalizeRoomCode((els.savedRoomsSelect && els.savedRoomsSelect.value) || '');
        if (!code) return;
        try {
          await apiRequest('POST', '/api/watch/user/delete-saved-room', { userToken: state.userToken, roomCode: code });
          await refreshSavedRooms();
          setStatus(true, `Removed saved room ${code}.`);
        } catch (err) {
          setStatus(false, String(err && err.message ? err.message : err));
        }
      });
    }
    for (const btn of els.tabButtons) {
      btn.addEventListener('click', () => switchTab(btn.getAttribute('data-tab-btn') || 'session'));
    }
    els.setMediaBtn.addEventListener('click', async () => {
      try { await setupMedia(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.chatBtn.addEventListener('click', async () => {
      try { await sendChat(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    if (els.chatInput) {
      els.chatInput.addEventListener('keydown', async (ev) => {
        if (ev.key !== 'Enter' || ev.shiftKey) return;
        ev.preventDefault();
        try { await sendChat(); } catch (err) { setStatus(false, String(err && err.message ? err.message : err)); }
      });
    }
    els.copyLinkBtn.addEventListener('click', copyInviteLink);
    els.startShareBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await startScreenShare();
      } catch (err) {
        setStatus(false, screenShareHelpMessage(err));
      }
    });
    els.stopShareBtn.addEventListener('click', async () => {
      try { await stopScreenShare(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.deleteRoomBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      const ok = window.confirm(`Delete room ${state.roomCode}? This removes the active watch session.`);
      if (!ok) return;
      try {
        await sendControl('delete_room', {});
        stopPollingLoop();
        await disconnectSfu().catch(() => {});
        await stopScreenShare();
        await stopVoiceChat();
        await stopWebcamShare();
        state.roomCode = '';
        state.chatScopeRoom = '';
        state.participantToken = '';
        state.participantId = '';
        state.participants = [];
        state.isHost = false;
        state.sinceEventId = 0;
        state.roomThemeKey = '';
        els.roomInput.value = '';
        els.createBtn.disabled = false;
        els.joinBtn.disabled = false;
        els.setMediaBtn.disabled = true;
        els.playBtn.disabled = true;
        els.pauseBtn.disabled = true;
        els.startShareBtn.disabled = true;
        els.stopShareBtn.disabled = true;
        els.resetRoomBtn.disabled = true;
        els.deleteRoomBtn.disabled = true;
        els.chatBtn.disabled = true;
        if (els.mediaModeSelect) els.mediaModeSelect.disabled = false;
        updateBadges();
        applyTheme(state.localThemeKey || 'clean', false);
        setThemeControlState();
        clearSession();
        state.chatMessages = new Map();
        state.pinnedMessageId = 0;
        renderChatFeed();
        setSyncLabel('room deleted');
        setStatus(false, 'Room deleted.');
        addEventLine('Room deleted by host.');
        updateMediaVisibility();
      } catch (err) {
        setStatus(false, String(err && err.message ? err.message : err));
      }
    });
    els.playBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 });
        await els.player.play().catch(() => {});
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.pauseBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        els.player.pause();
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.resyncBtn.addEventListener('click', () => applyRoomState(state.lastRoom, true));

    els.player.addEventListener('play', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('pause', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('seeked', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      const now = Date.now();
      if (now - state.lastSeekSentAt < 450) return;
      state.lastSeekSentAt = now;
      try { await sendControl('seek', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });

    (function init() {
      initThemeSelector();
      initSceneDrag();
      initCollapsibleBlocks();
      switchTab('session');
      setWizardStep(1);
      updateStatusChips(0);
      updateHealthStrip(null);
      updateMediaVisibility();
      renderParticipants();
      renderChatFeed();
      renderRequestQueue();
      renderJoinRequests();
      setEventsVisibility();
      refreshOpenParties();
      if (openPartyTimer) clearInterval(openPartyTimer);
      openPartyTimer = setInterval(refreshOpenParties, 15000);
      const roomFromQuery = normalizeRoomCode(qp('room') || '');
      const inviteFromQuery = String(qp('invite') || '').trim();
      const modeFromQuery = String(qp('mode') || '').trim().toLowerCase();
      if (inviteFromQuery) state.inviteToken = inviteFromQuery;
      if (roomFromQuery) els.roomInput.value = roomFromQuery;
      els.roomInput.addEventListener('input', () => {
        els.roomInput.value = normalizeRoomCode(els.roomInput.value);
      });
      if (els.inviteInput) {
        els.inviteInput.addEventListener('change', () => {
          const code = parseInviteRoom(els.inviteInput.value);
          if (code) els.roomInput.value = code;
        });
      }
      const savedClientMode = (() => {
        try { return localStorage.getItem(CLIENT_MODE_KEY) || 'web'; } catch (_) { return 'web'; }
      })();
      applyClientMode(modeFromQuery === 'desktop' ? 'desktop' : savedClientMode);
      if (els.clientModeSelect) {
        els.clientModeSelect.addEventListener('change', () => applyClientMode(els.clientModeSelect.value));
      }
    if (els.openDesktopBtn) {
      els.openDesktopBtn.addEventListener('click', () => openDesktopApp('open'));
    }
    if (els.downloadDesktopBtn) {
      els.downloadDesktopBtn.addEventListener('click', () => {
        setStatus(true, 'Opening Watch Party...');
      });
    }
      renderRecentRooms();
      try {
        const savedAdminKey = localStorage.getItem('telewatch_admin_key') || '';
        if (savedAdminKey) els.adminKeyInput.value = savedAdminKey;
      } catch (_) {}
      els.adminKeyInput.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_admin_key', els.adminKeyInput.value); } catch (_) {}
      });
      if (!els.adminUserInput.value.trim()) {
        els.adminUserInput.value = 'Trimbledustn@gmail.com';
      }
      if (els.shareSurfaceSelect && !els.shareSurfaceSelect.value) {
        els.shareSurfaceSelect.value = 'browser';
      }
      if (els.shareAudioSelect && !els.shareAudioSelect.value) {
        els.shareAudioSelect.value = 'tab';
      }
      if (els.shareQualitySelect && !els.shareQualitySelect.value) {
        els.shareQualitySelect.value = 'high';
      }
      if (els.movieQualitySelect && !els.movieQualitySelect.value) {
        els.movieQualitySelect.value = 'high';
      }
      if (els.webcamQualitySelect && !els.webcamQualitySelect.value) {
        els.webcamQualitySelect.value = 'high';
      }
      if (els.audioProfileSelect && !els.audioProfileSelect.value) {
        els.audioProfileSelect.value = 'cinema';
      }
      if (els.voiceQualitySelect && !els.voiceQualitySelect.value) {
        els.voiceQualitySelect.value = String((els.audioProfileSelect && els.audioProfileSelect.value) || 'cinema');
      }
      if (els.liveWebcamQualitySelect && !els.liveWebcamQualitySelect.value) {
        els.liveWebcamQualitySelect.value = String((els.webcamQualitySelect && els.webcamQualitySelect.value) || 'high');
      }
      loadPreferredMediaDevices();
      syncQualitySelectors();
      refreshDeviceLists().catch(() => {});
      if (navigator.mediaDevices && 'ondevicechange' in navigator.mediaDevices) {
        navigator.mediaDevices.ondevicechange = () => { refreshDeviceLists().catch(() => {}); };
      }
      try {
        state.hostOptionsMinimized = String(localStorage.getItem(HOST_OPTIONS_MIN_KEY) || '0') === '1';
      } catch (_) {
        state.hostOptionsMinimized = false;
      }
      renderHostOptionsMinimized();
      if (els.mediaModeSelect && !els.mediaModeSelect.value) {
        els.mediaModeSelect.value = 'webrtc';
      }
      applyMediaModeState((els.mediaModeSelect && els.mediaModeSelect.value) || 'webrtc', false);
      fetchSfuConfig().then(() => {
        if (!state.sfuEnabled && currentMediaMode() === 'sfu') {
          applyMediaModeState('webrtc', false);
        }
        enforceDonationGates();
      }).catch(() => {});
      if (els.webcamPolicySelect && !els.webcamPolicySelect.value) {
        els.webcamPolicySelect.value = 'allow';
      }
      const savedLayout = (() => {
        try { return localStorage.getItem(LAYOUT_MODE_KEY) || 'standard'; } catch (_) { return 'standard'; }
      })();
      const savedDensity = (() => {
        try { return localStorage.getItem(DENSITY_MODE_KEY) || 'comfortable'; } catch (_) { return 'comfortable'; }
      })();
      const savedUIMode = (() => {
        try { return localStorage.getItem(UI_MODE_KEY) || 'easy'; } catch (_) { return 'easy'; }
      })();
      applyLayoutMode(savedLayout, false);
      applyDensityMode(savedDensity, false);
      applyUIMode(savedUIMode, false);
      renderTemplateOptions();
      try {
        const rawUser = localStorage.getItem(USER_SESSION_KEY) || '';
        if (rawUser) {
          const u = JSON.parse(rawUser);
          state.userToken = String(u.userToken || '').trim();
          state.userEmail = String(u.userEmail || '').trim().toLowerCase();
          state.userDisplayName = String(u.userDisplayName || '').trim();
          state.donationTier = String(u.donationTier || 'free').trim().toLowerCase();
          if (els.userEmailInput && state.userEmail) els.userEmailInput.value = state.userEmail;
        }
      } catch (_) {}
      renderPremiumState();
      if (isPremiumUser()) {
        apiRequest('POST', '/api/watch/user/me', { userToken: state.userToken })
          .then((data) => {
            state.userEmail = String(data.username || state.userEmail);
            state.userDisplayName = String(data.displayName || state.userDisplayName);
            state.donationTier = String(data.donationTier || state.donationTier || 'free').toLowerCase();
            saveUserSession();
            renderPremiumState();
            refreshSavedRooms().catch(() => {});
          })
          .catch(() => {
            clearUserSession();
          });
      } else {
        renderSavedRooms();
      }
      const inviteSettings = readInviteSettings();
      if (els.inviteTtlInput) els.inviteTtlInput.value = String(inviteSettings.ttlMinutes);
      if (els.inviteMaxUsesInput) els.inviteMaxUsesInput.value = String(inviteSettings.maxUses);
      if (els.inviteTtlInput) {
        els.inviteTtlInput.addEventListener('change', () => {
          writeInviteSettings(els.inviteTtlInput.value, els.inviteMaxUsesInput ? els.inviteMaxUsesInput.value : 0);
        });
      }
      if (els.inviteMaxUsesInput) {
        els.inviteMaxUsesInput.addEventListener('change', () => {
          writeInviteSettings(els.inviteTtlInput ? els.inviteTtlInput.value : 720, els.inviteMaxUsesInput.value);
        });
      }
      for (const btn of (els.invitePresetButtons || [])) {
        btn.addEventListener('click', () => {
          const ttl = Number(btn.getAttribute('data-ttl') || 720);
          const uses = Number(btn.getAttribute('data-uses') || 0);
          applyInvitePreset(ttl, uses);
        });
      }
      try {
        const rawAdmin = localStorage.getItem(ADMIN_SESSION_KEY) || '';
        if (rawAdmin) {
          const a = JSON.parse(rawAdmin);
          state.adminToken = String(a.adminToken || '').trim();
          state.adminUsername = String(a.adminUsername || '').trim().toLowerCase();
          if (state.adminUsername) els.adminUserInput.value = state.adminUsername;
        }
      } catch (_) {}
      renderAdminIdentity();
      updateVoiceUi();
      applyHostOptionsVisibility();
      if (state.adminToken) {
        refreshAdminList().catch(() => {
          clearAdminSession();
        });
        refreshAdminRooms().catch(() => {});
        refreshBlocks().catch(() => {});
      }
      try {
        const savedName = localStorage.getItem('telewatch_name') || '';
        if (savedName) els.displayName.value = savedName;
      } catch (_) {}
      els.displayName.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_name', els.displayName.value.trim()); } catch (_) {}
      });
      try {
        const raw = localStorage.getItem(SESSION_KEY) || '';
        if (raw) {
          const s = JSON.parse(raw);
          const room = normalizeRoomCode(s.roomCode || '');
          const token = String(s.participantToken || '').trim();
          if (room && token) {
            state.roomCode = room;
            state.participantToken = token;
            state.participantId = String(s.participantId || '').trim();
            state.isHost = !!s.isHost;
            state.sinceEventId = 0;
            els.roomInput.value = room;
            onSessionStart();
            if (state.isHost) {
              setStatus(false, 'Session restored. Re-click Share Monitor / Tab after refresh.');
            } else {
              setStatus(false, 'Session restored. Reconnecting stream...');
            }
            return;
          }
        }
      } catch (_) {}
      updateBadges();
      if (roomFromQuery) {
        setStatus(false, inviteFromQuery ? 'Invite link detected. Enter name and click Join Room.' : 'Enter name and click Join Room');
      }
    })();

    window.addEventListener('beforeunload', (ev) => {
      const inActiveHostSession = !!(state.roomCode && state.isHost);
      const currentlySharing = !!rtc.localScreenStream;
      if (!(inActiveHostSession || currentlySharing)) return;
      ev.preventDefault();
      ev.returnValue = 'Leaving will stop your active host session/screen share. Continue?';
    });
  </script>
</body>
</html>
