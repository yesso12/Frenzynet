<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frenzy Telewatch | Synced Watch Rooms</title>
  <style>
    :root {
      --bg: #f4f6fa;
      --panel: #ffffff;
      --line: #dbe2ea;
      --line-soft: #e9eef4;
      --text: #18212c;
      --muted: #6a7787;
      --accent: #ff5f1f;
      --accent-strong: #e04d11;
      --good: #168252;
      --warn: #9e5d00;
      --danger: #b42318;
      --shadow: 0 10px 28px rgba(16, 24, 40, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--text);
      font-family: "Inter", "Segoe UI", Arial, sans-serif;
      background: linear-gradient(180deg, #f8f9fc, #f3f6fa);
      min-height: 100vh;
    }
    .wrap {
      width: min(1240px, calc(100% - 28px));
      margin: 18px auto 30px;
    }
    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border: 1px solid var(--line);
      border-radius: 14px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 14px 16px;
    }
    .hero {
      display: grid;
      gap: 4px;
    }
    .hero h1 {
      margin: 0;
      font-size: 25px;
      letter-spacing: 0.01em;
    }
    .hero p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      padding: 7px 11px;
      border-radius: 999px;
      background: #f8fafc;
      border: 1px solid var(--line);
      color: #314155;
      font-weight: 700;
      font-size: 12px;
    }
    .workspace {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
    }
    .card {
      border: 1px solid var(--line);
      border-radius: 15px;
      background: var(--panel);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    h2, h3 { margin: 0; }
    h2 { font-size: 18px; }
    h3 {
      margin-top: 2px;
      margin-bottom: 8px;
      font-size: 13px;
      color: #516072;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .muted { color: var(--muted); }
    .stack { display: grid; gap: 10px; }
    .panel-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      border-bottom: 1px solid var(--line);
      padding-bottom: 8px;
    }
    .tab-btn {
      border: 1px solid #d1dae5;
      background: #fff;
      color: #33475f;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .tab-btn.active {
      border-color: #ff925f;
      background: #fff3ec;
      color: #a43f12;
    }
    .tab-pane { display: none; }
    .tab-pane.active { display: grid; gap: 10px; }
    .block {
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      background: #fbfcfe;
      padding: 11px;
    }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 120px; }
    label {
      font-size: 11px;
      color: #5f6e7f;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      margin-bottom: 5px;
      display: block;
    }
    input, button, textarea, select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #d1dae5;
      background: #fff;
      color: var(--text);
      padding: 10px 11px;
      font: inherit;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #ff925f;
      box-shadow: 0 0 0 3px rgba(255, 95, 31, 0.15);
    }
    textarea { min-height: 70px; resize: vertical; }
    button {
      width: auto;
      background: linear-gradient(180deg, var(--accent), var(--accent-strong));
      border: 0;
      color: #fff;
      font-weight: 800;
      cursor: pointer;
      padding: 10px 13px;
      transition: transform 0.16s ease, filter 0.16s ease;
    }
    button:hover { transform: translateY(-1px); filter: brightness(1.04); }
    button.secondary {
      background: #fff;
      border: 1px solid #d1dae5;
      color: #2f3f52;
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    button.danger-btn {
      background: linear-gradient(180deg, #e5484d, #c23138);
      color: #fff;
    }
    video {
      width: 100%;
      max-height: 410px;
      border-radius: 12px;
      border: 1px solid #d2dbe6;
      background: #0f1720;
    }
    .status-online { color: var(--good); }
    .status-warn { color: var(--warn); }
    .stage {
      display: grid;
      gap: 10px;
    }
    .duo {
      display: grid;
      grid-template-columns: 1fr 330px;
      gap: 10px;
      align-items: start;
    }
    .events {
      max-height: 240px;
      overflow: auto;
      background: #f8fafc;
      border: 1px solid #dde5ef;
      border-radius: 9px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .events div { padding: 3px 0; border-bottom: 1px dashed #d6dfe9; }
    .events div:last-child { border-bottom: 0; }
    .chat-feed {
      max-height: 200px;
      overflow: auto;
      background: #f8fafc;
      border: 1px solid #dde5ef;
      border-radius: 9px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .chat-feed div { padding: 6px 0; border-bottom: 1px dashed #d6dfe9; }
    .chat-feed div:last-child { border-bottom: 0; }
    .msg-line { display: grid; gap: 1px; }
    .msg-head { font-size: 11px; color: #6f7d8f; }
    .msg-body { font-size: 13px; color: #1d2a39; word-break: break-word; }
    .admin-tools.hidden { display: none; }
    .admin-login.hidden { display: none; }
    .host-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr 1fr;
    }
    .host-grid .full { grid-column: 1 / -1; }
    .footer {
      margin-top: 12px;
      color: #718196;
      font-size: 13px;
      text-align: center;
    }
    a { color: #70d8ff; }
    .admin-delete {
      border: 1px solid #d8e1ec;
      background: #fbfcfe;
      border-radius: 10px;
      padding: 8px;
    }
    .admin-delete h3 { margin-bottom: 8px; }
    .count-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #d4dee9;
      background: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
      color: #33475f;
    }
    @media (max-width: 1080px) {
      .workspace { grid-template-columns: 1fr; }
      .duo { grid-template-columns: 1fr; }
      .row > * { min-width: 100px; }
      .host-grid { grid-template-columns: 1fr; }
    }
    @media (max-width: 760px) {
      .wrap { width: min(100%, calc(100% - 12px)); margin: 10px auto 18px; }
      .card { padding: 10px; }
      button { width: 100%; }
      .row > * { flex: 1 1 100%; min-width: 100%; }
      input, button, textarea { font-size: 16px; }
      .badge { font-size: 12px; }
      video { max-height: 230px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="hero">
        <h1>Frenzy Telewatch</h1>
        <p>Host or join synced watch rooms in one clean dashboard.</p>
      </div>
      <div class="row">
        <span id="roomBadge" class="badge">Room: none</span>
        <span id="roleBadge" class="badge">Role: viewer</span>
        <span id="syncBadge" class="badge">Sync: idle</span>
      </div>
    </div>

    <div class="workspace">
      <section class="card stack">
        <h2>Control Panel</h2>
        <div class="panel-tabs">
          <button class="tab-btn active" data-tab-btn="session">Session</button>
          <button class="tab-btn" data-tab-btn="host">Host Setup</button>
          <button class="tab-btn" data-tab-btn="chat">Messages</button>
          <button class="tab-btn" data-tab-btn="admin">Admin</button>
        </div>

        <div class="tab-pane active" data-tab-pane="session">
          <div class="block stack">
            <div>
              <label for="displayName">Display Name</label>
              <input id="displayName" placeholder="e.g. DFrenzy" />
            </div>
            <div>
              <label for="roomInput">Room Code</label>
              <input id="roomInput" placeholder="e.g. DADDYR" />
            </div>
            <div class="row">
              <button id="createBtn">Create Room</button>
              <button id="joinBtn" class="secondary">Join Room</button>
            </div>
            <div class="muted" id="joinHint">Share your room code in Discord voice chat. Everyone runs their own stream account.</div>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="host">
          <div class="block stack">
            <h3>Host Setup</h3>
            <div class="host-grid">
              <div class="full">
                <label for="titleInput">Title</label>
                <input id="titleInput" placeholder="Episode / movie title" />
              </div>
              <div class="full">
                <label for="mediaInput">Media URL (Optional Direct File)</label>
                <input id="mediaInput" placeholder="https://.../video.mp4" />
              </div>
              <div>
                <label for="shareSurfaceSelect">Share Source</label>
                <select id="shareSurfaceSelect">
                  <option value="auto">Auto (picker default)</option>
                  <option value="browser">Browser Tab</option>
                  <option value="window">Window/App</option>
                  <option value="monitor">Monitor/Screen</option>
                </select>
              </div>
              <div>
                <label for="shareAudioSelect">Share Audio</label>
                <select id="shareAudioSelect">
                  <option value="auto">Auto</option>
                  <option value="tab">Prefer Tab Audio</option>
                  <option value="system">Prefer System Audio</option>
                  <option value="off">No Audio</option>
                </select>
              </div>
              <button id="setMediaBtn" class="secondary">Set Media</button>
              <button id="copyLinkBtn" class="secondary">Copy Invite</button>
              <button id="startShareBtn" class="secondary">Share Monitor / Tab</button>
              <button id="stopShareBtn" class="secondary" disabled>Stop Share</button>
              <button id="deleteRoomBtn" class="secondary full">Delete Room</button>
            </div>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="chat">
          <div class="block stack">
            <h3>Room Messages</h3>
            <textarea id="chatInput" placeholder="Send timestamp notes, e.g. pause at 12:34"></textarea>
            <button id="chatBtn" class="secondary">Send Message</button>
          </div>
        </div>

        <div class="tab-pane" data-tab-pane="admin">
          <div class="block stack admin-login" id="adminLoginPanel">
            <h3>Admin Sign In</h3>
            <div class="muted">Sign in first to unlock admin actions.</div>
            <div>
              <label for="adminUserInput">Admin Username</label>
              <input id="adminUserInput" type="email" placeholder="Trimbledustn@gmail.com" />
            </div>
            <div>
              <label for="adminPassInput">Admin Password</label>
              <input id="adminPassInput" type="password" placeholder="Admin password" />
            </div>
            <button id="adminLoginBtn" class="secondary">Sign In Admin</button>
          </div>

          <div class="block stack admin-tools hidden" id="adminToolsPanel">
            <h3>Admin Tools</h3>
            <div class="muted" id="adminWhoami">Admin: not signed in</div>
            <div>
              <label for="adminKeyInput">Admin Code</label>
              <input id="adminKeyInput" type="password" placeholder="Required for protected options" />
            </div>
            <div>
              <label for="newAdminUserInput">Add Admin Username</label>
              <input id="newAdminUserInput" type="email" placeholder="newadmin@email.com" />
            </div>
            <div>
              <label for="newAdminPassInput">Add Admin Password</label>
              <input id="newAdminPassInput" type="password" placeholder="At least 8 characters" />
            </div>
            <div class="row">
              <button id="addAdminBtn" class="secondary">Add / Update Admin</button>
              <button id="refreshAdminsBtn" class="secondary">Refresh Admins</button>
            </div>
            <div>
              <label for="adminListSelect">Admin Accounts</label>
              <select id="adminListSelect"></select>
            </div>
            <div class="row">
              <button id="removeAdminBtn" class="danger-btn">Remove Selected Admin</button>
              <button id="adminLogoutBtn" class="secondary">Sign Out</button>
            </div>
          </div>
        </div>
      </section>

      <section class="card stack">
        <div class="row">
          <h2 id="nowTitle">Now Playing</h2>
          <span class="count-pill" id="connState">Not connected</span>
        </div>
        <div class="stage">
          <video id="player" controls playsinline></video>
          <video id="screenView" controls autoplay playsinline muted></video>
          <div class="row">
            <button id="playBtn" class="secondary">Play</button>
            <button id="pauseBtn" class="secondary">Pause</button>
            <button id="resyncBtn" class="secondary">Force Re-sync</button>
          </div>
        </div>

        <div class="duo">
          <div class="block stack">
            <h3>Room Messages</h3>
            <div class="muted">Live room chat appears here. Newest messages show first.</div>
            <div id="chatFeed" class="chat-feed"></div>
            <h3>Events</h3>
            <div class="muted">Playback and system events for this room.</div>
            <div id="events" class="events"></div>
          </div>
          <div class="block admin-delete">
            <h3>Admin Delete Room</h3>
            <label for="adminDeleteCodeInput">Room Code (blank = current room)</label>
            <input id="adminDeleteCodeInput" placeholder="Room code to delete" />
            <div style="height:8px"></div>
            <button id="adminDeleteBtn" class="danger-btn">Delete Room (Admin)</button>
          </div>
        </div>
      </section>
    </div>

    <div class="footer">
      This sync layer coordinates playback timing only. It does not rebroadcast protected streams.
      <a href="/">Back to FrenzyNets</a>
    </div>
  </div>

  <script>
    const API_PREFIXES = ['https://api.frenzynets.com/api/telewatch'];
    const POLL_MS = 1300;
    const RTC_CFG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const els = {
      displayName: document.getElementById('displayName'),
      roomInput: document.getElementById('roomInput'),
      adminKeyInput: document.getElementById('adminKeyInput'),
      adminUserInput: document.getElementById('adminUserInput'),
      adminPassInput: document.getElementById('adminPassInput'),
      adminLoginBtn: document.getElementById('adminLoginBtn'),
      adminWhoami: document.getElementById('adminWhoami'),
      adminLoginPanel: document.getElementById('adminLoginPanel'),
      adminToolsPanel: document.getElementById('adminToolsPanel'),
      newAdminUserInput: document.getElementById('newAdminUserInput'),
      newAdminPassInput: document.getElementById('newAdminPassInput'),
      addAdminBtn: document.getElementById('addAdminBtn'),
      refreshAdminsBtn: document.getElementById('refreshAdminsBtn'),
      removeAdminBtn: document.getElementById('removeAdminBtn'),
      adminLogoutBtn: document.getElementById('adminLogoutBtn'),
      adminListSelect: document.getElementById('adminListSelect'),
      adminDeleteCodeInput: document.getElementById('adminDeleteCodeInput'),
      titleInput: document.getElementById('titleInput'),
      mediaInput: document.getElementById('mediaInput'),
      shareSurfaceSelect: document.getElementById('shareSurfaceSelect'),
      shareAudioSelect: document.getElementById('shareAudioSelect'),
      createBtn: document.getElementById('createBtn'),
      joinBtn: document.getElementById('joinBtn'),
      adminDeleteBtn: document.getElementById('adminDeleteBtn'),
      setMediaBtn: document.getElementById('setMediaBtn'),
      copyLinkBtn: document.getElementById('copyLinkBtn'),
      startShareBtn: document.getElementById('startShareBtn'),
      stopShareBtn: document.getElementById('stopShareBtn'),
      deleteRoomBtn: document.getElementById('deleteRoomBtn'),
      chatInput: document.getElementById('chatInput'),
      chatBtn: document.getElementById('chatBtn'),
      playBtn: document.getElementById('playBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      resyncBtn: document.getElementById('resyncBtn'),
      roomBadge: document.getElementById('roomBadge'),
      roleBadge: document.getElementById('roleBadge'),
      syncBadge: document.getElementById('syncBadge'),
      connState: document.getElementById('connState'),
      nowTitle: document.getElementById('nowTitle'),
      events: document.getElementById('events'),
      chatFeed: document.getElementById('chatFeed'),
      player: document.getElementById('player'),
      screenView: document.getElementById('screenView'),
      tabButtons: Array.from(document.querySelectorAll('[data-tab-btn]')),
      tabPanes: Array.from(document.querySelectorAll('[data-tab-pane]'))
    };

    const state = {
      roomCode: '',
      participantToken: '',
      participantId: '',
      participants: [],
      adminToken: '',
      adminUsername: '',
      isHost: false,
      sinceEventId: 0,
      pollTimer: null,
      suppressOutbound: false,
      lastSeekSentAt: 0,
      lastRoom: null
    };
    const SESSION_KEY = 'telewatch_session';
    const ADMIN_SESSION_KEY = 'telewatch_admin_session';

    const rtc = {
      localScreenStream: null,
      peers: new Map(),
      pendingCandidates: new Map(),
      offeredTo: new Set()
    };

    function qp(name) {
      const u = new URL(window.location.href);
      return u.searchParams.get(name) || '';
    }

    function setStatus(ok, text) {
      els.connState.className = 'count-pill ' + (ok ? 'status-online' : 'status-warn');
      els.connState.textContent = text;
    }

    function setSyncLabel(text) {
      els.syncBadge.textContent = 'Sync: ' + text;
    }

    function screenShareHelpMessage(err) {
      const name = String(err && err.name ? err.name : '');
      const msg = String(err && err.message ? err.message : '');
      if (!window.isSecureContext) {
        return 'Screen share requires HTTPS. Open this page from https://frenzynets.com/telewatch/.';
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        return 'This browser does not support screen capture. Use latest Chrome/Edge/Firefox.';
      }
      if (name === 'NotAllowedError' || name === 'PermissionDeniedError') {
        return 'Screen-share permission denied. Click Share Monitor / Tab again and allow monitor/tab/window access.';
      }
      if (name === 'NotFoundError') {
        return 'No display source found. Connect a monitor or choose a visible window/tab.';
      }
      if (name === 'NotReadableError' || msg.toLowerCase().includes('system')) {
        return 'OS blocked capture. Check system privacy settings and allow screen recording for your browser.';
      }
      return msg || 'Unable to start screen share. Reopen the page and try again.';
    }

    function normalizeRoomCode(raw) {
      return String(raw || '').trim().toUpperCase().replace(/[^A-Z0-9_-]/g, '').slice(0, 24);
    }

    function addEventLine(text) {
      const d = document.createElement('div');
      d.textContent = text;
      els.events.prepend(d);
      while (els.events.children.length > 120) {
        els.events.removeChild(els.events.lastChild);
      }
    }

    function addChatLine(sender, message) {
      const d = document.createElement('div');
      d.className = 'msg-line';
      const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      d.innerHTML = `<div class="msg-head">${sender} · ${ts}</div><div class="msg-body"></div>`;
      d.querySelector('.msg-body').textContent = String(message || '');
      els.chatFeed.prepend(d);
      while (els.chatFeed.children.length > 200) {
        els.chatFeed.removeChild(els.chatFeed.lastChild);
      }
    }

    function switchTab(name) {
      const target = String(name || 'session').toLowerCase();
      for (const btn of els.tabButtons) {
        btn.classList.toggle('active', btn.getAttribute('data-tab-btn') === target);
      }
      for (const pane of els.tabPanes) {
        pane.classList.toggle('active', pane.getAttribute('data-tab-pane') === target);
      }
    }

    async function apiRequest(method, path, body, queryParams) {
      let lastError = null;
      for (const prefix of API_PREFIXES) {
        try {
          const url = new URL(prefix + path, window.location.origin);
          if (queryParams) {
            Object.entries(queryParams).forEach(([k, v]) => {
              if (v !== undefined && v !== null && v !== '') {
                url.searchParams.set(k, String(v));
              }
            });
          }
          const res = await fetch(url.toString(), {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: body ? JSON.stringify(body) : undefined,
            cache: 'no-store'
          });
          const text = await res.text();
          let data = {};
          try { data = text ? JSON.parse(text) : {}; } catch (_) {}
          if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
          return data;
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('request_failed');
    }

    async function sendControl(action, extra) {
      if (!state.roomCode || !state.participantToken) return;
      const body = Object.assign({
        roomCode: state.roomCode,
        participantToken: state.participantToken,
        action
      }, extra || {});
      await apiRequest('POST', '/api/watch/control', body);
    }

    function saveSession() {
      try {
        if (!state.roomCode || !state.participantToken) return;
        localStorage.setItem(
          SESSION_KEY,
          JSON.stringify({
            roomCode: state.roomCode,
            participantToken: state.participantToken,
            participantId: state.participantId || '',
            isHost: !!state.isHost
          })
        );
      } catch (_) {}
    }

    function clearSession() {
      try { localStorage.removeItem(SESSION_KEY); } catch (_) {}
    }

    function upsertIceQueue(participantId, candidate) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      list.push(candidate);
      rtc.pendingCandidates.set(participantId, list);
    }

    async function flushIceQueue(participantId, pc) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      rtc.pendingCandidates.delete(participantId);
      for (const c of list) {
        try { await pc.addIceCandidate(c); } catch (_) {}
      }
    }

    function closePeer(participantId) {
      const row = rtc.peers.get(participantId);
      if (!row) return;
      try { row.pc.close(); } catch (_) {}
      rtc.peers.delete(participantId);
      rtc.pendingCandidates.delete(participantId);
      rtc.offeredTo.delete(participantId);
    }

    function ensurePeer(participantId) {
      const existing = rtc.peers.get(participantId);
      if (existing) return existing.pc;
      const pc = new RTCPeerConnection(RTC_CFG);
      pc.onicecandidate = (ev) => {
        if (!ev.candidate) return;
        sendControl('signal', {
          toParticipantId: participantId,
          signalType: 'ice',
          candidate: String(ev.candidate.candidate || '')
        }).catch(() => {});
      };
      pc.onconnectionstatechange = () => {
        if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) closePeer(participantId);
      };
      pc.ontrack = (ev) => {
        if (state.isHost) return;
        if (ev.streams && ev.streams[0]) {
          els.screenView.srcObject = ev.streams[0];
          els.screenView.muted = false;
          els.screenView.play().catch(() => {});
          setSyncLabel('screen live');
        }
      };
      rtc.peers.set(participantId, { pc });
      return pc;
    }

    function getHostParticipantId() {
      const row = (state.participants || []).find((p) => p && p.isHost);
      return row ? String(row.participantId || '') : '';
    }

    function syncHostTrackSenders(participantId, pc) {
      if (!state.isHost || !rtc.localScreenStream) return;
      const tracks = rtc.localScreenStream.getTracks().filter((t) => t.kind === 'video' || t.kind === 'audio');
      for (const track of tracks) {
        const existing = pc.getSenders().find((s) => s.track && s.track.kind === track.kind);
        if (existing) existing.replaceTrack(track).catch(() => {});
        else pc.addTrack(track, rtc.localScreenStream);
      }
    }

    async function createOfferFor(participantId) {
      if (!state.isHost || !rtc.localScreenStream || !participantId) return;
      const pc = ensurePeer(participantId);
      syncHostTrackSenders(participantId, pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.offeredTo.add(participantId);
    }

    async function broadcastOffersToViewers() {
      if (!state.isHost || !rtc.localScreenStream) return;
      const viewerIds = (state.participants || [])
        .filter((p) => p && !p.isSelf && !p.isHost)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(viewerIds);
      for (const pid of Array.from(rtc.peers.keys())) {
        if (!keep.has(pid)) closePeer(pid);
      }
      for (const pid of viewerIds) {
        if (!rtc.offeredTo.has(pid)) {
          try { await createOfferFor(pid); } catch (_) {}
        }
      }
    }

    async function startScreenShare() {
      if (!state.isHost) return;
      if (!window.isSecureContext) {
        throw new Error('Open Telewatch over HTTPS to share your screen.');
      }
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        throw new Error('Browser screen-share API unavailable. Use latest Chrome/Edge/Firefox.');
      }
      const surface = String((els.shareSurfaceSelect && els.shareSurfaceSelect.value) || 'auto');
      const audioMode = String((els.shareAudioSelect && els.shareAudioSelect.value) || 'auto');
      const videoCfg = {};
      if (surface === 'browser') {
        videoCfg.displaySurface = 'browser';
        videoCfg.selfBrowserSurface = 'exclude';
      } else if (surface === 'window') {
        videoCfg.displaySurface = 'window';
      } else if (surface === 'monitor') {
        videoCfg.displaySurface = 'monitor';
      }
      const constraints = {
        video: Object.keys(videoCfg).length ? videoCfg : true,
        audio: audioMode !== 'off'
      };
      if (audioMode === 'tab') {
        constraints.preferCurrentTab = true;
      } else if (audioMode === 'system') {
        constraints.systemAudio = 'include';
      }
      const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
      rtc.localScreenStream = stream;
      els.screenView.srcObject = stream;
      els.screenView.muted = true;
      try { await els.screenView.play(); } catch (_) {}
      els.startShareBtn.disabled = true;
      els.stopShareBtn.disabled = false;
      setSyncLabel('sharing monitor/tab');
      const track = stream.getVideoTracks()[0];
      if (track) {
        track.addEventListener('ended', () => {
          stopScreenShare().catch(() => {});
        });
      }
      const hasAudio = stream.getAudioTracks().length > 0;
      if (hasAudio) {
        addEventLine('Screen share audio detected and will be sent to viewers.');
      } else {
        addEventLine('No share audio detected. In picker enable tab/system audio.');
      }
      await broadcastOffersToViewers();
    }

    async function stopScreenShare() {
      if (rtc.localScreenStream) {
        for (const t of rtc.localScreenStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localScreenStream = null;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      if (state.isHost) {
        els.screenView.srcObject = null;
      }
      for (const pid of Array.from(rtc.peers.keys())) closePeer(pid);
      setSyncLabel('share stopped');
    }

    async function processSignal(payload) {
      const toId = String(payload.toParticipantId || '');
      if (!toId || toId !== state.participantId) return;
      const fromId = String(payload.fromParticipantId || '');
      const kind = String(payload.signalType || '').toLowerCase();
      if (!fromId || !kind) return;
      const pc = ensurePeer(fromId);
      if (state.isHost) syncHostTrackSenders(fromId, pc);
      if (kind === 'offer') {
        if (state.isHost) return;
        await pc.setRemoteDescription({ type: 'offer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await sendControl('signal', {
          toParticipantId: fromId,
          signalType: 'answer',
          sdp: String(answer.sdp || '')
        });
      } else if (kind === 'answer') {
        await pc.setRemoteDescription({ type: 'answer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
      } else if (kind === 'ice') {
        const candidate = String(payload.candidate || '');
        if (!candidate) return;
        const iceObj = { candidate, sdpMid: '0', sdpMLineIndex: 0 };
        if (pc.remoteDescription) {
          try { await pc.addIceCandidate(iceObj); } catch (_) {}
        } else {
          upsertIceQueue(fromId, iceObj);
        }
      }
    }

    async function createRoom() {
      const chosenCode = normalizeRoomCode(els.roomInput.value);
      const payload = {
        roomCode: chosenCode || undefined,
        displayName: els.displayName.value.trim() || 'Host',
        title: els.titleInput.value.trim(),
        mediaUrl: els.mediaInput.value.trim()
      };
      const data = await apiRequest('POST', '/api/watch/create', payload);
      state.roomCode = data.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = true;
      state.sinceEventId = 0;
      els.roomInput.value = state.roomCode;
      onSessionStart();
      addEventLine('Room created: ' + state.roomCode);
    }

    async function joinRoom() {
      const payload = {
        roomCode: normalizeRoomCode(els.roomInput.value),
        displayName: els.displayName.value.trim() || ''
      };
      const data = await apiRequest('POST', '/api/watch/join', payload);
      state.roomCode = payload.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = !!data.isHost;
      state.sinceEventId = 0;
      onSessionStart();
      applyRoomState(data.room || null, true);
      addEventLine('Joined room: ' + state.roomCode);
    }

    async function deleteRoomByCode(codeOverride) {
      const code = normalizeRoomCode(codeOverride || els.adminDeleteCodeInput.value || els.roomInput.value || state.roomCode);
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!code) {
        setStatus(false, 'Enter a room code first.');
        return;
      }
      const ok = window.confirm(`Delete room code ${code}?`);
      if (!ok) return;
      const data = await apiRequest('POST', '/api/watch/delete', {
        roomCode: code,
        adminCode,
        adminToken: state.adminToken,
      });
      setStatus(false, `Room ${data.roomCode || code} deleted.`);
      addEventLine(`Room ${data.roomCode || code} deleted.`);
    }

    function renderAdminIdentity() {
      const signedIn = !!(state.adminToken && state.adminUsername);
      els.adminWhoami.textContent = signedIn ? ('Admin: ' + state.adminUsername) : 'Admin: not signed in';
      els.adminLoginPanel.classList.toggle('hidden', signedIn);
      els.adminToolsPanel.classList.toggle('hidden', !signedIn);
    }

    function saveAdminSession() {
      try {
        if (!state.adminToken || !state.adminUsername) {
          localStorage.removeItem(ADMIN_SESSION_KEY);
          return;
        }
        localStorage.setItem(ADMIN_SESSION_KEY, JSON.stringify({
          adminToken: state.adminToken,
          adminUsername: state.adminUsername
        }));
      } catch (_) {}
    }

    function clearAdminSession() {
      state.adminToken = '';
      state.adminUsername = '';
      try { localStorage.removeItem(ADMIN_SESSION_KEY); } catch (_) {}
      renderAdminIdentity();
    }

    async function adminLogin() {
      const username = String(els.adminUserInput.value || '').trim().toLowerCase();
      const password = String(els.adminPassInput.value || '').trim();
      if (!username || !password) {
        throw new Error('Enter admin username and password.');
      }
      const data = await apiRequest('POST', '/api/watch/admin/login', { username, password });
      state.adminToken = String(data.adminToken || '');
      state.adminUsername = String(data.username || username);
      saveAdminSession();
      renderAdminIdentity();
      await refreshAdminList();
      setStatus(true, 'Admin signed in.');
    }

    async function addAdminUser() {
      const newUsername = String(els.newAdminUserInput.value || '').trim().toLowerCase();
      const newPassword = String(els.newAdminPassInput.value || '').trim();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!adminCode) throw new Error('Admin code required.');
      if (!newUsername || !newPassword) throw new Error('Enter new admin username and password.');
      await apiRequest('POST', '/api/watch/admin/add', {
        adminToken: state.adminToken,
        adminCode,
        newUsername,
        newPassword
      });
      els.newAdminPassInput.value = '';
      await refreshAdminList();
      setStatus(true, 'Admin user added: ' + newUsername);
      addEventLine('Admin added: ' + newUsername);
    }

    async function refreshAdminList() {
      if (!state.adminToken) return;
      const data = await apiRequest('POST', '/api/watch/admin/list', { adminToken: state.adminToken });
      const admins = Array.isArray(data.admins) ? data.admins : [];
      els.adminListSelect.innerHTML = '';
      for (const row of admins) {
        const opt = document.createElement('option');
        opt.value = row.username;
        opt.textContent = row.isOwner ? `${row.username} (owner)` : row.username;
        els.adminListSelect.appendChild(opt);
      }
      if (!admins.length) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No admins found';
        els.adminListSelect.appendChild(opt);
      }
    }

    async function removeSelectedAdmin() {
      const username = String((els.adminListSelect && els.adminListSelect.value) || '').trim().toLowerCase();
      const adminCode = String(els.adminKeyInput.value || '').trim();
      if (!state.adminToken) throw new Error('Sign in as admin first.');
      if (!username) throw new Error('Select an admin to remove.');
      if (!adminCode) throw new Error('Admin code required.');
      const ok = window.confirm(`Remove admin ${username}?`);
      if (!ok) return;
      await apiRequest('POST', '/api/watch/admin/remove', { adminToken: state.adminToken, adminCode, username });
      await refreshAdminList();
      setStatus(true, `Admin removed: ${username}`);
      addEventLine(`Admin removed: ${username}`);
    }

    async function adminLogout() {
      const token = String(state.adminToken || '').trim();
      if (!token) return;
      try {
        await apiRequest('POST', '/api/watch/admin/logout', { adminToken: token });
      } catch (_) {}
      clearAdminSession();
      setStatus(false, 'Admin signed out.');
    }

    function updateBadges() {
      els.roomBadge.textContent = 'Room: ' + (state.roomCode || 'none');
      els.roleBadge.textContent = 'Role: ' + (state.isHost ? 'host' : 'viewer');
    }

    function onSessionStart() {
      updateBadges();
      els.createBtn.disabled = true;
      els.joinBtn.disabled = true;
      els.setMediaBtn.disabled = !state.isHost;
      els.playBtn.disabled = !state.isHost;
      els.pauseBtn.disabled = !state.isHost;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      els.deleteRoomBtn.disabled = !state.isHost;
      els.chatBtn.disabled = false;
      if (state.pollTimer) clearInterval(state.pollTimer);
      state.pollTimer = setInterval(pollState, POLL_MS);
      saveSession();
      pollState();
    }

    function applyRoomState(room, force) {
      if (!room) return;
      state.lastRoom = room;
      els.nowTitle.textContent = room.title ? ('Now Playing: ' + room.title) : 'Now Playing';
      if (!state.isHost) {
        els.titleInput.value = room.title || '';
        els.mediaInput.value = room.mediaUrl || '';
      }

      const p = els.player;
      const mediaUrl = (room.mediaUrl || '').trim();
      if (mediaUrl && p.src !== mediaUrl) {
        state.suppressOutbound = true;
        p.src = mediaUrl;
        p.load();
        state.suppressOutbound = false;
      }

      const drift = Math.abs((Number(p.currentTime) || 0) - (Number(room.playbackSec) || 0));
      if (force || drift > 1.5) {
        try {
          state.suppressOutbound = true;
          p.currentTime = Number(room.playbackSec) || 0;
          state.suppressOutbound = false;
          setSyncLabel('aligned');
        } catch (_) {
          state.suppressOutbound = false;
        }
      }

      if (!state.isHost) {
        if (room.isPlaying && p.paused) {
          state.suppressOutbound = true;
          p.play().catch(() => {});
          state.suppressOutbound = false;
        }
        if (!room.isPlaying && !p.paused) {
          state.suppressOutbound = true;
          p.pause();
          state.suppressOutbound = false;
        }
      }
    }

    async function setupMedia() {
      if (!state.isHost) return;
      await sendControl('set_media', {
        mediaUrl: els.mediaInput.value.trim(),
        title: els.titleInput.value.trim()
      });
      setSyncLabel('media updated');
    }

    async function sendChat() {
      const message = els.chatInput.value.trim();
      if (!message) return;
      await sendControl('chat', { message });
      els.chatInput.value = '';
    }

    async function copyInviteLink() {
      if (!state.roomCode) return;
      const url = window.location.origin + '/telewatch/?room=' + encodeURIComponent(state.roomCode);
      try {
        await navigator.clipboard.writeText(url);
        setSyncLabel('invite copied');
      } catch (_) {
        setSyncLabel(url);
      }
    }

    async function pollState() {
      if (!state.roomCode || !state.participantToken) return;
      try {
        const data = await apiRequest('GET', '/api/watch/state', null, {
          roomCode: state.roomCode,
          participantToken: state.participantToken,
          sinceEventId: state.sinceEventId
        });
        state.participantId = data.selfParticipantId || state.participantId;
        state.participants = Array.isArray(data.participants) ? data.participants : [];
        setStatus(true, 'Connected · active viewers: ' + (data.activeCount || 0));
        applyRoomState(data.room || null, false);
        if (state.isHost && rtc.localScreenStream) {
          await broadcastOffersToViewers();
        }
        for (const ev of (data.events || [])) {
          state.sinceEventId = Math.max(state.sinceEventId, Number(ev.id) || 0);
          const actor = ev.actor || 'user';
          if (ev.type === 'signal') {
            await processSignal(ev.payload || {});
            continue;
          }
          if (ev.type === 'chat') {
            addChatLine(actor, String(ev.payload?.message || ''));
            continue;
          }
          addEventLine(actor + ' · ' + ev.type.replace('_', ' '));
        }
      } catch (err) {
        setStatus(false, 'Reconnect pending: ' + (err?.message || 'network_error'));
        setSyncLabel('retrying');
      }
    }

    els.createBtn.addEventListener('click', async () => {
      try {
        await createRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_capacity_reached')) {
          setStatus(false, 'Room limit reached (35 max). Delete an existing room first.');
          return;
        }
        if (msg.includes('room_code_taken') || msg.includes('409')) {
          setStatus(false, 'Room code already taken. Use a new code or click Join Room.');
          addEventLine('Room code already exists. Try Join Room for that code.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.joinBtn.addEventListener('click', async () => {
      try {
        await joinRoom();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('room_full')) {
          setStatus(false, 'Room is full (25 people max).');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.adminDeleteBtn.addEventListener('click', async () => {
      try {
        await deleteRoomByCode();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_auth_required') || msg.includes('admin_auth_invalid')) {
          setStatus(false, 'Admin sign-in required for delete.');
          return;
        }
        if (msg.includes('admin_code_required')) {
          setStatus(false, 'Admin code required.');
          return;
        }
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.adminLoginBtn.addEventListener('click', async () => {
      try {
        await adminLogin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_login_invalid')) {
          setStatus(false, 'Admin login failed. Check username/password.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.refreshAdminsBtn.addEventListener('click', async () => {
      try {
        await refreshAdminList();
        setStatus(true, 'Admin list refreshed.');
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.addAdminBtn.addEventListener('click', async () => {
      try {
        await addAdminUser();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        if (msg.includes('admin_auth_required') || msg.includes('admin_auth_invalid')) {
          setStatus(false, 'Sign in as admin before adding admins.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.removeAdminBtn.addEventListener('click', async () => {
      try {
        await removeSelectedAdmin();
      } catch (err) {
        const msg = String(err && err.message ? err.message : err);
        if (msg.includes('owner_required')) {
          setStatus(false, 'Only the owner can remove admins.');
          return;
        }
        if (msg.includes('cannot_remove_owner')) {
          setStatus(false, 'Owner account cannot be removed.');
          return;
        }
        if (msg.includes('admin_auth_invalid')) {
          clearAdminSession();
          setStatus(false, 'Admin session expired. Sign in again.');
          return;
        }
        if (msg.includes('admin_code_invalid')) {
          setStatus(false, 'Admin code is invalid.');
          return;
        }
        setStatus(false, msg);
      }
    });
    els.adminLogoutBtn.addEventListener('click', async () => {
      await adminLogout();
    });
    for (const btn of els.tabButtons) {
      btn.addEventListener('click', () => switchTab(btn.getAttribute('data-tab-btn') || 'session'));
    }
    els.setMediaBtn.addEventListener('click', async () => {
      try { await setupMedia(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.chatBtn.addEventListener('click', async () => {
      try { await sendChat(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.copyLinkBtn.addEventListener('click', copyInviteLink);
    els.startShareBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await startScreenShare();
      } catch (err) {
        setStatus(false, screenShareHelpMessage(err));
      }
    });
    els.stopShareBtn.addEventListener('click', async () => {
      try { await stopScreenShare(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.deleteRoomBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      const ok = window.confirm(`Delete room ${state.roomCode}? This removes the active watch session.`);
      if (!ok) return;
      try {
        await sendControl('delete_room', {});
        if (state.pollTimer) clearInterval(state.pollTimer);
        await stopScreenShare();
        state.roomCode = '';
        state.participantToken = '';
        state.participantId = '';
        state.participants = [];
        state.isHost = false;
        state.sinceEventId = 0;
        els.roomInput.value = '';
        els.createBtn.disabled = false;
        els.joinBtn.disabled = false;
        els.setMediaBtn.disabled = true;
        els.playBtn.disabled = true;
        els.pauseBtn.disabled = true;
        els.startShareBtn.disabled = true;
        els.stopShareBtn.disabled = true;
        els.deleteRoomBtn.disabled = true;
        els.chatBtn.disabled = true;
        updateBadges();
        clearSession();
        setSyncLabel('room deleted');
        setStatus(false, 'Room deleted.');
        addEventLine('Room deleted by host.');
      } catch (err) {
        setStatus(false, String(err && err.message ? err.message : err));
      }
    });
    els.playBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 });
        await els.player.play().catch(() => {});
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.pauseBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        els.player.pause();
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.resyncBtn.addEventListener('click', () => applyRoomState(state.lastRoom, true));

    els.player.addEventListener('play', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('pause', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('seeked', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      const now = Date.now();
      if (now - state.lastSeekSentAt < 450) return;
      state.lastSeekSentAt = now;
      try { await sendControl('seek', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });

    (function init() {
      switchTab('session');
      const roomFromQuery = normalizeRoomCode(qp('room') || '');
      if (roomFromQuery) els.roomInput.value = roomFromQuery;
      els.roomInput.addEventListener('input', () => {
        els.roomInput.value = normalizeRoomCode(els.roomInput.value);
      });
      try {
        const savedAdminKey = localStorage.getItem('telewatch_admin_key') || '';
        if (savedAdminKey) els.adminKeyInput.value = savedAdminKey;
      } catch (_) {}
      els.adminKeyInput.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_admin_key', els.adminKeyInput.value); } catch (_) {}
      });
      if (!els.adminUserInput.value.trim()) {
        els.adminUserInput.value = 'Trimbledustn@gmail.com';
      }
      try {
        const rawAdmin = localStorage.getItem(ADMIN_SESSION_KEY) || '';
        if (rawAdmin) {
          const a = JSON.parse(rawAdmin);
          state.adminToken = String(a.adminToken || '').trim();
          state.adminUsername = String(a.adminUsername || '').trim().toLowerCase();
          if (state.adminUsername) els.adminUserInput.value = state.adminUsername;
        }
      } catch (_) {}
      renderAdminIdentity();
      if (state.adminToken) {
        refreshAdminList().catch(() => {
          clearAdminSession();
        });
      }
      try {
        const savedName = localStorage.getItem('telewatch_name') || '';
        if (savedName) els.displayName.value = savedName;
      } catch (_) {}
      els.displayName.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_name', els.displayName.value.trim()); } catch (_) {}
      });
      try {
        const raw = localStorage.getItem(SESSION_KEY) || '';
        if (raw) {
          const s = JSON.parse(raw);
          const room = normalizeRoomCode(s.roomCode || '');
          const token = String(s.participantToken || '').trim();
          if (room && token) {
            state.roomCode = room;
            state.participantToken = token;
            state.participantId = String(s.participantId || '').trim();
            state.isHost = !!s.isHost;
            state.sinceEventId = 0;
            els.roomInput.value = room;
            onSessionStart();
            if (state.isHost) {
              setStatus(false, 'Session restored. Re-click Share Monitor / Tab after refresh.');
            } else {
              setStatus(false, 'Session restored. Reconnecting stream...');
            }
            return;
          }
        }
      } catch (_) {}
      updateBadges();
      if (roomFromQuery) setStatus(false, 'Enter name and click Join Room');
    })();
  </script>
</body>
</html>
