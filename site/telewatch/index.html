<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frenzy Telewatch | Synced Watch Rooms</title>
  <style>
    :root {
      --bg: #08111c;
      --panel: #122235;
      --panel2: #0d1a2b;
      --line: #2b4b70;
      --accent: #43d6ff;
      --accent2: #1fa0d4;
      --text: #e6f2ff;
      --muted: #99b8d7;
      --good: #7cffbf;
      --warn: #ffd56f;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--text);
      font-family: "Segoe UI", Tahoma, Arial, sans-serif;
      background:
        radial-gradient(circle at 10% 10%, rgba(67, 214, 255, 0.2), transparent 40%),
        radial-gradient(circle at 90% 0%, rgba(124, 255, 191, 0.15), transparent 28%),
        linear-gradient(160deg, #08111c, #0a1625 40%, #08101b 100%);
      min-height: 100vh;
    }
    .wrap { width: min(1150px, calc(100% - 24px)); margin: 18px auto 28px; }
    .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(10, 20, 32, 0.82);
      padding: 10px 12px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #0d2438;
      border: 1px solid #2f587f;
      color: #b8dcff;
      font-weight: 700;
      font-size: 13px;
    }
    .grid { margin-top: 12px; display: grid; grid-template-columns: 370px 1fr; gap: 12px; }
    .card {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 12px;
    }
    h1, h2, h3 { margin: 0 0 10px; }
    h1 { font-size: 22px; }
    h2 { font-size: 17px; }
    h3 { font-size: 14px; color: #b4cdea; letter-spacing: 0.02em; }
    .muted { color: var(--muted); }
    .stack { display: grid; gap: 8px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    label { font-size: 12px; color: #a9c8e7; font-weight: 700; text-transform: uppercase; letter-spacing: 0.04em; }
    input, button, textarea {
      width: 100%;
      border-radius: 9px;
      border: 1px solid #305274;
      background: #0a1829;
      color: var(--text);
      padding: 10px;
      font: inherit;
    }
    textarea { min-height: 70px; resize: vertical; }
    button {
      width: auto;
      background: linear-gradient(180deg, var(--accent), var(--accent2));
      border: 0;
      color: #00131f;
      font-weight: 800;
      cursor: pointer;
      padding: 10px 14px;
    }
    button.secondary {
      background: #0f2740;
      border: 1px solid #2f587f;
      color: #c7e5ff;
    }
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    video {
      width: 100%;
      max-height: 420px;
      border-radius: 10px;
      border: 1px solid #2a496d;
      background: #050b13;
    }
    .status-online { color: var(--good); }
    .status-warn { color: var(--warn); }
    .events {
      max-height: 220px;
      overflow: auto;
      background: #081423;
      border: 1px solid #284766;
      border-radius: 8px;
      padding: 8px;
      font-size: 13px;
      line-height: 1.45;
    }
    .events div { padding: 3px 0; border-bottom: 1px dashed rgba(70, 108, 140, 0.4); }
    .events div:last-child { border-bottom: 0; }
    .footer { margin-top: 12px; color: #88a8c8; font-size: 13px; }
    a { color: #70d8ff; }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <h1>Frenzy Telewatch</h1>
      <div class="row">
        <span id="roomBadge" class="badge">Room: none</span>
        <span id="roleBadge" class="badge">Role: viewer</span>
        <span id="syncBadge" class="badge">Sync: idle</span>
      </div>
    </div>

    <div class="grid">
      <section class="card stack">
        <h2>Session</h2>
        <div>
          <label for="displayName">Display Name</label>
          <input id="displayName" placeholder="e.g. Ghost" />
        </div>
        <div>
          <label for="roomInput">Room Code</label>
          <input id="roomInput" placeholder="e.g. K7V9P2" />
        </div>
        <div class="row">
          <button id="createBtn">Create Room</button>
          <button id="joinBtn" class="secondary">Join Room</button>
        </div>
        <div class="muted" id="joinHint">Share your room code in Discord voice chat. Everyone runs their own stream account.</div>

        <h3>Host Controls</h3>
        <div>
          <label for="titleInput">Title</label>
          <input id="titleInput" placeholder="Episode / movie title" />
        </div>
        <div>
          <label for="mediaInput">Media URL (Optional direct file)</label>
          <input id="mediaInput" placeholder="https://.../video.mp4" />
        </div>
        <div class="row">
          <button id="setMediaBtn" class="secondary">Set Media</button>
          <button id="copyLinkBtn" class="secondary">Copy Invite Link</button>
        </div>
        <div class="row">
          <button id="startShareBtn" class="secondary">Share Monitor / Tab</button>
          <button id="stopShareBtn" class="secondary" disabled>Stop Share</button>
        </div>

        <h3>Room Chat</h3>
        <textarea id="chatInput" placeholder="Send timestamp notes, e.g. pause at 12:34"></textarea>
        <button id="chatBtn" class="secondary">Send Note</button>
      </section>

      <section class="card stack">
        <h2 id="nowTitle">Now Playing</h2>
        <div id="connState" class="status-warn">Not connected</div>
        <video id="player" controls playsinline></video>
        <video id="screenView" controls autoplay playsinline muted></video>
        <div class="row">
          <button id="playBtn" class="secondary">Play</button>
          <button id="pauseBtn" class="secondary">Pause</button>
          <button id="resyncBtn" class="secondary">Force Re-sync</button>
        </div>
        <h3>Events</h3>
        <div id="events" class="events"></div>
      </section>
    </div>

    <div class="footer">
      This sync layer coordinates playback timing only. It does not rebroadcast protected streams.
      <a href="/">Back to FrenzyNets</a>
    </div>
  </div>

  <script>
    const API_PREFIXES = ['https://api.frenzynets.com/api/telewatch', '/api/telewatch'];
    const POLL_MS = 1300;
    const RTC_CFG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const els = {
      displayName: document.getElementById('displayName'),
      roomInput: document.getElementById('roomInput'),
      titleInput: document.getElementById('titleInput'),
      mediaInput: document.getElementById('mediaInput'),
      createBtn: document.getElementById('createBtn'),
      joinBtn: document.getElementById('joinBtn'),
      setMediaBtn: document.getElementById('setMediaBtn'),
      copyLinkBtn: document.getElementById('copyLinkBtn'),
      startShareBtn: document.getElementById('startShareBtn'),
      stopShareBtn: document.getElementById('stopShareBtn'),
      chatInput: document.getElementById('chatInput'),
      chatBtn: document.getElementById('chatBtn'),
      playBtn: document.getElementById('playBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      resyncBtn: document.getElementById('resyncBtn'),
      roomBadge: document.getElementById('roomBadge'),
      roleBadge: document.getElementById('roleBadge'),
      syncBadge: document.getElementById('syncBadge'),
      connState: document.getElementById('connState'),
      nowTitle: document.getElementById('nowTitle'),
      events: document.getElementById('events'),
      player: document.getElementById('player'),
      screenView: document.getElementById('screenView')
    };

    const state = {
      roomCode: '',
      participantToken: '',
      participantId: '',
      participants: [],
      isHost: false,
      sinceEventId: 0,
      pollTimer: null,
      suppressOutbound: false,
      lastSeekSentAt: 0,
      lastRoom: null
    };

    const rtc = {
      localScreenStream: null,
      peers: new Map(),
      pendingCandidates: new Map(),
      offeredTo: new Set()
    };

    function qp(name) {
      const u = new URL(window.location.href);
      return u.searchParams.get(name) || '';
    }

    function setStatus(ok, text) {
      els.connState.className = ok ? 'status-online' : 'status-warn';
      els.connState.textContent = text;
    }

    function setSyncLabel(text) {
      els.syncBadge.textContent = 'Sync: ' + text;
    }

    function normalizeRoomCode(raw) {
      return String(raw || '').trim().toUpperCase().replace(/[^A-Z0-9_-]/g, '').slice(0, 24);
    }

    function addEventLine(text) {
      const d = document.createElement('div');
      d.textContent = text;
      els.events.prepend(d);
      while (els.events.children.length > 120) {
        els.events.removeChild(els.events.lastChild);
      }
    }

    async function apiRequest(method, path, body, queryParams) {
      let lastError = null;
      for (const prefix of API_PREFIXES) {
        try {
          const url = new URL(prefix + path, window.location.origin);
          if (queryParams) {
            Object.entries(queryParams).forEach(([k, v]) => {
              if (v !== undefined && v !== null && v !== '') {
                url.searchParams.set(k, String(v));
              }
            });
          }
          const res = await fetch(url.toString(), {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: body ? JSON.stringify(body) : undefined,
            cache: 'no-store'
          });
          const text = await res.text();
          let data = {};
          try { data = text ? JSON.parse(text) : {}; } catch (_) {}
          if (!res.ok) throw new Error(data.error || ('HTTP ' + res.status));
          return data;
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('request_failed');
    }

    async function sendControl(action, extra) {
      if (!state.roomCode || !state.participantToken) return;
      const body = Object.assign({
        roomCode: state.roomCode,
        participantToken: state.participantToken,
        action
      }, extra || {});
      await apiRequest('POST', '/api/watch/control', body);
    }

    function upsertIceQueue(participantId, candidate) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      list.push(candidate);
      rtc.pendingCandidates.set(participantId, list);
    }

    async function flushIceQueue(participantId, pc) {
      const list = rtc.pendingCandidates.get(participantId) || [];
      rtc.pendingCandidates.delete(participantId);
      for (const c of list) {
        try { await pc.addIceCandidate(c); } catch (_) {}
      }
    }

    function closePeer(participantId) {
      const row = rtc.peers.get(participantId);
      if (!row) return;
      try { row.pc.close(); } catch (_) {}
      rtc.peers.delete(participantId);
      rtc.pendingCandidates.delete(participantId);
      rtc.offeredTo.delete(participantId);
    }

    function ensurePeer(participantId) {
      const existing = rtc.peers.get(participantId);
      if (existing) return existing.pc;
      const pc = new RTCPeerConnection(RTC_CFG);
      pc.onicecandidate = (ev) => {
        if (!ev.candidate) return;
        sendControl('signal', {
          toParticipantId: participantId,
          signalType: 'ice',
          candidate: String(ev.candidate.candidate || '')
        }).catch(() => {});
      };
      pc.onconnectionstatechange = () => {
        if (['failed', 'closed', 'disconnected'].includes(pc.connectionState)) closePeer(participantId);
      };
      pc.ontrack = (ev) => {
        if (state.isHost) return;
        if (ev.streams && ev.streams[0]) {
          els.screenView.srcObject = ev.streams[0];
          els.screenView.muted = false;
          setSyncLabel('screen live');
        }
      };
      rtc.peers.set(participantId, { pc });
      return pc;
    }

    function getHostParticipantId() {
      const row = (state.participants || []).find((p) => p && p.isHost);
      return row ? String(row.participantId || '') : '';
    }

    function syncHostTrackSenders(participantId, pc) {
      if (!state.isHost || !rtc.localScreenStream) return;
      const track = rtc.localScreenStream.getVideoTracks()[0];
      if (!track) return;
      const existing = pc.getSenders().find((s) => s.track && s.track.kind === 'video');
      if (existing) existing.replaceTrack(track).catch(() => {});
      else pc.addTrack(track, rtc.localScreenStream);
    }

    async function createOfferFor(participantId) {
      if (!state.isHost || !rtc.localScreenStream || !participantId) return;
      const pc = ensurePeer(participantId);
      syncHostTrackSenders(participantId, pc);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendControl('signal', {
        toParticipantId: participantId,
        signalType: 'offer',
        sdp: String(offer.sdp || '')
      });
      rtc.offeredTo.add(participantId);
    }

    async function broadcastOffersToViewers() {
      if (!state.isHost || !rtc.localScreenStream) return;
      const viewerIds = (state.participants || [])
        .filter((p) => p && !p.isSelf && !p.isHost)
        .map((p) => String(p.participantId || ''))
        .filter(Boolean);
      const keep = new Set(viewerIds);
      for (const pid of Array.from(rtc.peers.keys())) {
        if (!keep.has(pid)) closePeer(pid);
      }
      for (const pid of viewerIds) {
        if (!rtc.offeredTo.has(pid)) {
          try { await createOfferFor(pid); } catch (_) {}
        }
      }
    }

    async function startScreenShare() {
      if (!state.isHost) return;
      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      rtc.localScreenStream = stream;
      els.screenView.srcObject = stream;
      els.screenView.muted = true;
      els.startShareBtn.disabled = true;
      els.stopShareBtn.disabled = false;
      setSyncLabel('sharing monitor/tab');
      const track = stream.getVideoTracks()[0];
      if (track) {
        track.addEventListener('ended', () => {
          stopScreenShare().catch(() => {});
        });
      }
      await broadcastOffersToViewers();
    }

    async function stopScreenShare() {
      if (rtc.localScreenStream) {
        for (const t of rtc.localScreenStream.getTracks()) {
          try { t.stop(); } catch (_) {}
        }
      }
      rtc.localScreenStream = null;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      if (state.isHost) {
        els.screenView.srcObject = null;
      }
      for (const pid of Array.from(rtc.peers.keys())) closePeer(pid);
      setSyncLabel('share stopped');
    }

    async function processSignal(payload) {
      const toId = String(payload.toParticipantId || '');
      if (!toId || toId !== state.participantId) return;
      const fromId = String(payload.fromParticipantId || '');
      const kind = String(payload.signalType || '').toLowerCase();
      if (!fromId || !kind) return;
      const pc = ensurePeer(fromId);
      if (state.isHost) syncHostTrackSenders(fromId, pc);
      if (kind === 'offer') {
        if (state.isHost) return;
        await pc.setRemoteDescription({ type: 'offer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await sendControl('signal', {
          toParticipantId: fromId,
          signalType: 'answer',
          sdp: String(answer.sdp || '')
        });
      } else if (kind === 'answer') {
        await pc.setRemoteDescription({ type: 'answer', sdp: String(payload.sdp || '') });
        await flushIceQueue(fromId, pc);
      } else if (kind === 'ice') {
        const candidate = String(payload.candidate || '');
        if (!candidate) return;
        const iceObj = { candidate, sdpMid: '0', sdpMLineIndex: 0 };
        if (pc.remoteDescription) {
          try { await pc.addIceCandidate(iceObj); } catch (_) {}
        } else {
          upsertIceQueue(fromId, iceObj);
        }
      }
    }

    async function createRoom() {
      const chosenCode = normalizeRoomCode(els.roomInput.value);
      const payload = {
        roomCode: chosenCode || undefined,
        displayName: els.displayName.value.trim() || 'Host',
        title: els.titleInput.value.trim(),
        mediaUrl: els.mediaInput.value.trim()
      };
      const data = await apiRequest('POST', '/api/watch/create', payload);
      state.roomCode = data.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = true;
      state.sinceEventId = 0;
      els.roomInput.value = state.roomCode;
      onSessionStart();
      addEventLine('Room created: ' + state.roomCode);
    }

    async function joinRoom() {
      const payload = {
        roomCode: normalizeRoomCode(els.roomInput.value),
        displayName: els.displayName.value.trim() || ''
      };
      const data = await apiRequest('POST', '/api/watch/join', payload);
      state.roomCode = payload.roomCode;
      state.participantToken = data.participantToken;
      state.participantId = data.participantId || '';
      state.isHost = !!data.isHost;
      state.sinceEventId = 0;
      onSessionStart();
      applyRoomState(data.room || null, true);
      addEventLine('Joined room: ' + state.roomCode);
    }

    function updateBadges() {
      els.roomBadge.textContent = 'Room: ' + (state.roomCode || 'none');
      els.roleBadge.textContent = 'Role: ' + (state.isHost ? 'host' : 'viewer');
    }

    function onSessionStart() {
      updateBadges();
      els.createBtn.disabled = true;
      els.joinBtn.disabled = true;
      els.setMediaBtn.disabled = !state.isHost;
      els.playBtn.disabled = !state.isHost;
      els.pauseBtn.disabled = !state.isHost;
      els.startShareBtn.disabled = !state.isHost;
      els.stopShareBtn.disabled = true;
      els.chatBtn.disabled = false;
      if (state.pollTimer) clearInterval(state.pollTimer);
      state.pollTimer = setInterval(pollState, POLL_MS);
      pollState();
    }

    function applyRoomState(room, force) {
      if (!room) return;
      state.lastRoom = room;
      els.nowTitle.textContent = room.title ? ('Now Playing: ' + room.title) : 'Now Playing';
      if (!state.isHost) {
        els.titleInput.value = room.title || '';
        els.mediaInput.value = room.mediaUrl || '';
      }

      const p = els.player;
      const mediaUrl = (room.mediaUrl || '').trim();
      if (mediaUrl && p.src !== mediaUrl) {
        state.suppressOutbound = true;
        p.src = mediaUrl;
        p.load();
        state.suppressOutbound = false;
      }

      const drift = Math.abs((Number(p.currentTime) || 0) - (Number(room.playbackSec) || 0));
      if (force || drift > 1.5) {
        try {
          state.suppressOutbound = true;
          p.currentTime = Number(room.playbackSec) || 0;
          state.suppressOutbound = false;
          setSyncLabel('aligned');
        } catch (_) {
          state.suppressOutbound = false;
        }
      }

      if (!state.isHost) {
        if (room.isPlaying && p.paused) {
          state.suppressOutbound = true;
          p.play().catch(() => {});
          state.suppressOutbound = false;
        }
        if (!room.isPlaying && !p.paused) {
          state.suppressOutbound = true;
          p.pause();
          state.suppressOutbound = false;
        }
      }
    }

    async function setupMedia() {
      if (!state.isHost) return;
      await sendControl('set_media', {
        mediaUrl: els.mediaInput.value.trim(),
        title: els.titleInput.value.trim()
      });
      setSyncLabel('media updated');
    }

    async function sendChat() {
      const message = els.chatInput.value.trim();
      if (!message) return;
      await sendControl('chat', { message });
      els.chatInput.value = '';
    }

    async function copyInviteLink() {
      if (!state.roomCode) return;
      const url = window.location.origin + '/telewatch/?room=' + encodeURIComponent(state.roomCode);
      try {
        await navigator.clipboard.writeText(url);
        setSyncLabel('invite copied');
      } catch (_) {
        setSyncLabel(url);
      }
    }

    async function pollState() {
      if (!state.roomCode || !state.participantToken) return;
      try {
        const data = await apiRequest('GET', '/api/watch/state', null, {
          roomCode: state.roomCode,
          participantToken: state.participantToken,
          sinceEventId: state.sinceEventId
        });
        state.participantId = data.selfParticipantId || state.participantId;
        state.participants = Array.isArray(data.participants) ? data.participants : [];
        setStatus(true, 'Connected · active viewers: ' + (data.activeCount || 0));
        applyRoomState(data.room || null, false);
        if (state.isHost && rtc.localScreenStream) {
          await broadcastOffersToViewers();
        }
        for (const ev of (data.events || [])) {
          state.sinceEventId = Math.max(state.sinceEventId, Number(ev.id) || 0);
          const actor = ev.actor || 'user';
          if (ev.type === 'signal') {
            await processSignal(ev.payload || {});
            continue;
          }
          if (ev.type === 'chat') addEventLine(actor + ': ' + String(ev.payload?.message || ''));
          else addEventLine(actor + ' · ' + ev.type.replace('_', ' '));
        }
      } catch (err) {
        setStatus(false, 'Reconnect pending: ' + (err?.message || 'network_error'));
        setSyncLabel('retrying');
      }
    }

    els.createBtn.addEventListener('click', async () => {
      try { await createRoom(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.joinBtn.addEventListener('click', async () => {
      try { await joinRoom(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.setMediaBtn.addEventListener('click', async () => {
      try { await setupMedia(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.chatBtn.addEventListener('click', async () => {
      try { await sendChat(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.copyLinkBtn.addEventListener('click', copyInviteLink);
    els.startShareBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try { await startScreenShare(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.stopShareBtn.addEventListener('click', async () => {
      try { await stopScreenShare(); } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.playBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 });
        await els.player.play().catch(() => {});
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.pauseBtn.addEventListener('click', async () => {
      if (!state.isHost) return;
      try {
        await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 });
        els.player.pause();
      } catch (err) { setStatus(false, String(err.message || err)); }
    });
    els.resyncBtn.addEventListener('click', () => applyRoomState(state.lastRoom, true));

    els.player.addEventListener('play', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('play', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('pause', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      try { await sendControl('pause', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });
    els.player.addEventListener('seeked', async () => {
      if (!state.isHost || state.suppressOutbound) return;
      const now = Date.now();
      if (now - state.lastSeekSentAt < 450) return;
      state.lastSeekSentAt = now;
      try { await sendControl('seek', { playbackSec: Number(els.player.currentTime) || 0 }); } catch (_) {}
    });

    (function init() {
      const roomFromQuery = normalizeRoomCode(qp('room') || '');
      if (roomFromQuery) els.roomInput.value = roomFromQuery;
      els.roomInput.addEventListener('input', () => {
        els.roomInput.value = normalizeRoomCode(els.roomInput.value);
      });
      try {
        const savedName = localStorage.getItem('telewatch_name') || '';
        if (savedName) els.displayName.value = savedName;
      } catch (_) {}
      els.displayName.addEventListener('input', () => {
        try { localStorage.setItem('telewatch_name', els.displayName.value.trim()); } catch (_) {}
      });
      updateBadges();
      if (roomFromQuery) setStatus(false, 'Enter name and click Join Room');
    })();
  </script>
</body>
</html>
