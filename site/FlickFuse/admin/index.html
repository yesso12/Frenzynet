<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>FlickFuse Admin | FrenzyNets</title>
  <link rel="icon" type="image/svg+xml" href="/assets/frenzynet-logo.svg" />
  <style>
    :root {
      --bg: #f3f6fb;
      --panel: #ffffff;
      --panel-soft: #f8fbff;
      --line: #d8e2ef;
      --text: #172333;
      --muted: #617289;
      --accent: #ff6a2a;
      --accent2: #e24f15;
      --danger: #c23138;
      --shadow: 0 12px 30px rgba(10, 20, 35, 0.07);
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at 12% 8%, #ffffff, var(--bg)); color: var(--text); font-family: "Segoe UI", Inter, Arial, sans-serif; }
    .wrap { width: min(1160px, calc(100% - 20px)); margin: 18px auto; display: grid; gap: 12px; }
    .card { background: var(--panel); border: 1px solid var(--line); border-radius: 14px; padding: 14px; box-shadow: var(--shadow); }
    .quick-steps {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
    }
    .step-pill {
      border: 1px solid #cfd9e8;
      border-radius: 10px;
      background: #f8fbff;
      padding: 10px;
      font-size: 12px;
      font-weight: 700;
      color: #31465f;
      text-align: center;
    }
    .tool-section {
      margin-top: 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: linear-gradient(180deg, var(--panel-soft), #fff);
      padding: 12px;
    }
    details.tool-section summary {
      cursor: pointer;
      font-weight: 800;
      color: #2b3f57;
      list-style: none;
    }
    details.tool-section summary::-webkit-details-marker { display: none; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 150px; }
    label { display: block; margin: 0 0 4px; font-size: 11px; color: var(--muted); font-weight: 700; text-transform: uppercase; letter-spacing: .06em; }
    input, select, button { width: 100%; border-radius: 9px; border: 1px solid #d1dae5; padding: 10px; font: inherit; }
    button { background: linear-gradient(180deg, var(--accent), var(--accent2)); color: #fff; border: 0; font-weight: 800; cursor: pointer; }
    button.secondary { background: #fff; border: 1px solid #d1dae5; color: #2f3f52; }
    button.danger { background: linear-gradient(180deg, #e5484d, var(--danger)); }
    .muted { color: var(--muted); font-size: 13px; }
    .status { font-weight: 700; }
    .hidden { display: none; }
    a { color: #2263d1; }
    .stream-frame {
      width: 100%;
      min-height: 560px;
      border: 1px solid #ced9e8;
      border-radius: 12px;
      background: #0d1422;
    }
    .pill {
      display: inline-block;
      border: 1px solid #cfdbeb;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      color: #3e556f;
      background: #f6f9ff;
      font-weight: 700;
    }
    .tv-console {
      background: linear-gradient(160deg, #1a2841, #203452);
      border-color: #3b5478;
      color: #eaf2ff;
    }
    .tv-console h3 { color: #eaf2ff; }
    .tv-console .muted { color: #a8bbd7; }
    .tv-console .pill {
      border-color: #5a7398;
      background: #2a3f62;
      color: #dcebff;
    }
    .tv-console input,
    .tv-console select {
      background: #1f3252;
      border-color: #4d678f;
      color: #ecf3ff;
    }
    .tv-console label { color: #9fb5d6; }
    .tv-console button.secondary {
      background: #2a3f62;
      border-color: #5c77a0;
      color: #dcebff;
    }
    .tv-console .stream-frame {
      border-color: #33547f;
      background: #070e1b;
      min-height: 640px;
    }
    .tv-console button.big {
      min-height: 46px;
      font-size: 15px;
      letter-spacing: .02em;
    }
    .easy-bar {
      display: grid;
      gap: 8px;
      margin-bottom: 10px;
      border: 1px solid #506d96;
      border-radius: 10px;
      padding: 10px;
      background: linear-gradient(160deg, #233a5d, #2a466f);
    }
    .easy-bar .muted { color: #c2d5f0; }
    .guide-panel {
      border: 1px solid #5d77a0;
      border-radius: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.06);
      margin-bottom: 10px;
      display: grid;
      gap: 6px;
    }
    .guide-title {
      font-size: 13px;
      font-weight: 800;
      color: #eaf2ff;
      text-transform: uppercase;
      letter-spacing: .05em;
    }
    .guide-step {
      font-size: 13px;
      border: 1px solid #5f7ca8;
      border-radius: 999px;
      padding: 6px 10px;
      color: #d8e7ff;
      background: rgba(255, 255, 255, 0.06);
      width: fit-content;
    }
    .guide-step.done {
      border-color: #7fd4a8;
      background: rgba(53, 122, 92, 0.45);
      color: #ecfff6;
    }
    .health-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 10px 0 0;
    }
    .health-badge {
      border: 1px solid #d1dae5;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      font-weight: 700;
      background: #fff;
      color: #334960;
    }
    .health-badge.ok {
      border-color: #8ad2ab;
      background: #edf9f2;
      color: #196947;
    }
    .health-badge.bad {
      border-color: #ed9ea3;
      background: #fff0f1;
      color: #9f2631;
    }
    .sticky-checklist {
      position: sticky;
      top: 12px;
      z-index: 3;
      border: 1px solid #4f6990;
      border-radius: 10px;
      padding: 10px;
      background: #1f3453;
      margin-bottom: 10px;
      color: #eaf2ff;
    }
    .sticky-checklist .item {
      font-size: 12px;
      border: 1px solid #6886b2;
      border-radius: 999px;
      padding: 5px 9px;
      margin: 6px 0 0;
      display: inline-block;
      background: rgba(255,255,255,.07);
    }
    .sticky-checklist .item.done {
      border-color: #8ad2ab;
      background: rgba(38, 115, 78, .55);
    }
    @media (max-width: 760px) {
      .wrap { width: calc(100% - 14px); margin: 10px auto; }
      .row > * { min-width: 100%; flex-basis: 100%; }
      .stream-frame { min-height: 420px; }
      button { padding: 11px; }
      .quick-steps { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1 style="margin:0 0 8px">FlickFuse Admin Console</h1>
      <div class="muted">Clean admin workspace for live events, room controls, and moderation.</div>
      <div class="quick-steps">
        <div class="step-pill">1. Sign In</div>
        <div class="step-pill">2. Enter Admin Code</div>
        <div class="step-pill">3. Use Quick Main Event Controls</div>
      </div>
      <div id="status" class="status" style="margin-top:8px">Not signed in</div>
      <div class="muted"><a href="/FlickFuse/">Back to FlickFuse</a></div>
    </div>

    <div class="card" id="loginCard">
      <h2 style="margin:0 0 8px">Sign In</h2>
      <div class="row">
        <div>
          <label for="username">Username</label>
          <input id="username" type="email" placeholder="Trimbledustn@gmail.com" />
        </div>
        <div>
          <label for="password">Password</label>
          <input id="password" type="password" placeholder="Password" />
        </div>
      </div>
      <div style="margin-top:8px"><button id="loginBtn">Sign In</button></div>
    </div>

    <div class="card hidden" id="toolsCard">
      <h2 style="margin:0 0 8px">Admin Tools</h2>
      <div class="row">
        <div>
          <label for="adminCode">Admin Code</label>
          <input id="adminCode" type="password" placeholder="1978Luke$$" />
        </div>
        <div style="align-self:end"><button id="logoutBtn" class="secondary">Sign Out</button></div>
      </div>

      <div class="muted" style="margin-top:8px">Main Event workspace is isolated below for fast big-night operation.</div>
      <div class="health-row">
        <span id="apiHealthBadge" class="health-badge">API: checking...</span>
        <span id="authHealthBadge" class="health-badge">Auth: checking...</span>
        <button id="runPreflightBtn" class="secondary" style="width:auto">Run Preflight</button>
      </div>

      <div class="tool-section">
      <h3 style="margin:0 0 8px">Main Event Control</h3>
      <div class="row">
        <div>
          <label for="mainEventRoomCode">Main Event Room Code</label>
          <input id="mainEventRoomCode" placeholder="WATCH01 or custom room" />
        </div>
        <div>
          <label for="mainEventLockdown">Main Event Mode</label>
          <select id="mainEventLockdown">
            <option value="0">Off</option>
            <option value="1">Lockdown On (route viewers to main room)</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="mainEventCountdown">Countdown (UTC)</label>
          <input id="mainEventCountdown" type="datetime-local" />
        </div>
        <div style="align-self:end">
          <button id="nextSaturdayBtn" class="secondary">Set Next Saturday</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="loadMainEventBtn" class="secondary">Load Main Event Settings</button>
        <button id="saveMainEventBtn">Save Main Event Settings</button>
      </div>
      </div>

      <div class="tool-section tv-console">
      <div class="row" style="align-items:center">
        <h3 style="margin:0">Main Event TV Console</h3>
        <div style="text-align:right"><span class="pill">Big Night Mode</span></div>
      </div>
      <div class="sticky-checklist">
        <div style="font-weight:800; font-size:12px; text-transform:uppercase; letter-spacing:.05em;">Live Checklist</div>
        <span id="checklist1" class="item">Admin code entered</span>
        <span id="checklist2" class="item">Main event room set</span>
        <span id="checklist3" class="item">Host controls attached</span>
        <span id="checklist4" class="item">Stream console loaded</span>
        <span id="checklist5" class="item">Live started</span>
      </div>
      <div class="guide-panel">
        <div class="guide-title">Big Night Quick Guide</div>
        <div id="guideStep1" class="guide-step">1. Click Quick Start Main Event</div>
        <div id="guideStep2" class="guide-step">2. In Streaming Console, start your screen share</div>
        <div id="guideStep3" class="guide-step">3. Click Go Live</div>
        <div id="guideStep4" class="guide-step">4. Share the Main Event link</div>
        <div class="muted">If timing changes: update countdown in Main Event Control, then save.</div>
      </div>
      <div class="easy-bar">
        <div class="row">
          <button id="quickStartMainEventBtn" class="big">Quick Start Main Event (Recommended)</button>
          <button id="quickStopMainEventBtn" class="danger big">Quick Stop</button>
          <button id="rollbackMainEventBtn" class="secondary big">Rollback To Normal</button>
        </div>
        <div id="quickMainEventState" class="muted">Ready. Click Quick Start to auto-configure main event.</div>
      </div>
      <div class="muted" style="margin:6px 0 8px">Fast workflow: Prep, Create Event, Load Stream Console, then Go Live.</div>
      <div class="row" style="margin-bottom:8px">
        <button id="mainEventPrepBtn" class="secondary big">1) Prep Console</button>
        <button id="createMainEventBtn" class="big">2) Create + Enable</button>
        <button id="mainEventGoLiveBtn" class="big">3) Go Live</button>
      </div>
      <div class="row">
        <div>
          <label for="mainEventHostName">Host Display Name</label>
          <input id="mainEventHostName" placeholder="DFrenzy" />
        </div>
        <div>
          <label for="mainEventTitle">Main Event Title</label>
          <input id="mainEventTitle" placeholder="Friday Main Event" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="mainEventMode">Transport Mode</label>
          <select id="mainEventMode">
            <option value="broadcast">Broadcast (Main Event)</option>
            <option value="sfu">SFU</option>
            <option value="webrtc">WebRTC</option>
          </select>
        </div>
        <div>
          <label for="mainEventTemplate">Template</label>
          <select id="mainEventTemplate">
            <option value="big_movie">Big Movie Night</option>
            <option value="anime_night">Anime Night</option>
            <option value="sports_watch">Sports Watch</option>
          </select>
        </div>
        <div>
          <label for="mainEventRooms">Existing Active Rooms</label>
          <select id="mainEventRooms"></select>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="applyTemplateBtn" class="secondary">Apply Template</button>
        <button id="refreshRoomsBtn" class="secondary">Refresh Rooms</button>
      </div>
      <div class="muted" style="margin-top:4px">For huge nights, keep Transport Mode on Broadcast.</div>
      <div class="row" style="margin-top:8px">
        <button id="enableMainEventBtn">Enable Lockdown</button>
        <button id="disableMainEventBtn" class="secondary">Disable Lockdown</button>
        <button id="stopMainEventBtn" class="danger">Stop + Delete Event Room</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="openMainEventBtn" class="secondary">Open Event Room</button>
        <button id="copyMainEventJoinBtn" class="secondary">Copy Public Join Link</button>
      </div>
      <div id="mainEventInfo" class="muted" style="margin-top:6px">No main event room selected.</div>
      <div id="mainEventHostInfo" class="muted" style="margin-top:4px">Host controls: not attached</div>
      </div>

      <div class="tool-section tv-console">
      <h3 style="margin:0 0 8px">Main Event Studio</h3>
      <div class="row">
        <div>
          <label for="studioTitle">Movie / Episode Title</label>
          <input id="studioTitle" placeholder="Movie Night Title" />
        </div>
        <div>
          <label for="studioMediaUrl">Media URL</label>
          <input id="studioMediaUrl" placeholder="https://.../video.mp4" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="studioAttachHostBtn" class="secondary">Attach Host Controls</button>
        <button id="studioSetMediaBtn">Set Movie</button>
        <button id="studioSetTitleBtn" class="secondary">Set Title Only</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="backupCohostSelect">Backup Co-host</label>
          <select id="backupCohostSelect"></select>
        </div>
        <div style="align-self:end">
          <button id="assignBackupBtn" class="secondary">Assign Backup Co-host</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="studioSeekSec">Seek To (seconds)</label>
          <input id="studioSeekSec" type="number" min="0" step="1" placeholder="0" />
        </div>
        <div>
          <label for="studioTheme">Room Theme</label>
          <select id="studioTheme">
            <option value="clean">Clean</option>
            <option value="anime">Anime</option>
            <option value="blossom">Blossom</option>
            <option value="city">City</option>
            <option value="neon">Neon</option>
          </select>
        </div>
        <div>
          <label for="studioAccessMode">Access Mode</label>
          <select id="studioAccessMode">
            <option value="public">Public</option>
            <option value="invite">Invite Only</option>
            <option value="closed">Closed</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="studioPlayBtn">Play</button>
        <button id="studioPauseBtn" class="secondary">Pause</button>
        <button id="studioSeekBtn" class="secondary">Seek</button>
        <button id="studioThemeBtn" class="secondary">Apply Theme</button>
        <button id="studioAccessBtn" class="secondary">Apply Access</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="studioMessage">Room Message</label>
          <input id="studioMessage" placeholder="Main Event is starting now." />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="studioMessageBtn" class="secondary">Send Room Message</button>
      </div>
      </div>

      <div class="tool-section tv-console">
      <h3 style="margin:0 0 8px">Streaming Console</h3>
      <div class="row">
        <div>
          <label for="studioStreamUrl">Embedded Stream URL</label>
          <input id="studioStreamUrl" readonly />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="studioLoadStreamBtn">Load Stream Console</button>
        <button id="studioPopoutStreamBtn" class="secondary">Open In New Tab</button>
        <button id="studioRefreshStreamBtn" class="secondary">Refresh Console</button>
      </div>
      <div style="margin-top:8px"><span class="pill">Use this panel to run the actual share/stream workflow live.</span></div>
      <div class="muted" style="margin-top:6px">When the stream preview looks right, come back and click Go Live.</div>
      <iframe id="studioStreamFrame" class="stream-frame" loading="lazy" referrerpolicy="strict-origin-when-cross-origin"></iframe>
      </div>

      <div class="tool-section tv-console">
      <h3 style="margin:0 0 8px">Advanced Event Ops</h3>
      <div class="row">
        <button id="macroIntermissionBtn" class="secondary">Intermission Macro</button>
        <button id="macroResumeBtn" class="secondary">Resume Macro</button>
        <button id="panicModeBtn" class="danger">Panic Mode (Close Joins)</button>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="delayedStartMinutes">Delayed Start (minutes)</label>
          <input id="delayedStartMinutes" type="number" min="1" max="120" value="5" />
        </div>
        <div style="align-self:end">
          <button id="scheduleGoLiveBtn">Schedule Go Live</button>
        </div>
        <div style="align-self:end">
          <button id="cancelGoLiveBtn" class="secondary">Cancel Scheduled Live</button>
        </div>
      </div>
      <div id="delayedStartStatus" class="muted" style="margin-top:6px">No delayed start scheduled.</div>

      <div class="row" style="margin-top:10px">
        <div>
          <label for="qualityAutoToggle">Auto Quality Switch</label>
          <select id="qualityAutoToggle">
            <option value="off">Off</option>
            <option value="on">On</option>
          </select>
        </div>
        <div>
          <label for="qualityHighThreshold">Viewer Threshold (SFU)</label>
          <input id="qualityHighThreshold" type="number" min="20" max="2000" value="80" />
        </div>
        <div style="align-self:end">
          <button id="applyQualityModeBtn" class="secondary">Apply Mode Now</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label for="autoRecoveryToggle">Host Auto-Recovery</label>
          <select id="autoRecoveryToggle">
            <option value="on">On (Recommended)</option>
            <option value="off">Off</option>
          </select>
        </div>
        <div style="align-self:end">
          <button id="promoteBackupNowBtn" class="secondary">Promote Backup Now</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="muteAllBtn" class="secondary">Mute All Mics</button>
        <button id="lockRoomBtn" class="secondary">Lock Room</button>
        <button id="clearChatBtn" class="secondary">Clear Chat (Host Notice)</button>
      </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label for="inviteTtlAdmin">Invite TTL (minutes)</label>
          <input id="inviteTtlAdmin" type="number" min="5" max="10080" value="180" />
        </div>
        <div>
          <label for="inviteUsesAdmin">Invite Max Uses</label>
          <input id="inviteUsesAdmin" type="number" min="0" max="500" value="50" />
        </div>
        <div style="align-self:end">
          <button id="createInviteBtn" class="secondary">Create Invite</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div>
          <label for="inviteListSelect">Invite Tokens</label>
          <select id="inviteListSelect"></select>
        </div>
        <div style="align-self:end">
          <button id="refreshInvitesBtn" class="secondary">Refresh Invites</button>
        </div>
        <div style="align-self:end">
          <button id="revokeInviteBtn" class="danger">Revoke Selected Invite</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="deviceTestBtn" class="secondary">Run Device Test</button>
        <button id="incidentRecoverBtn" class="secondary">Incident Recovery</button>
      </div>
      <div id="deviceTestStatus" class="muted" style="margin-top:6px">Device test not run.</div>
      <div id="incidentStatus" class="muted" style="margin-top:4px">No active incident detected.</div>
      <div class="row" style="margin-top:10px">
        <button id="routerDiagBtn" class="secondary">Router Lock Diagnostics</button>
      </div>
      <pre id="routerDiagStatus" style="margin:6px 0 0; white-space:pre-wrap; background:#132541; color:#d7e9ff; border:1px solid #4b6893; border-radius:10px; padding:8px;">No diagnostics run yet.</pre>

      <div style="margin-top:10px">
        <label>Live Metrics</label>
        <div id="metricsSummary" class="muted">Viewers: -- | Join rate: --/min | Mode: --</div>
        <pre id="metricsGraph" style="margin:6px 0 0; white-space:pre-wrap; background:#132541; color:#d7e9ff; border:1px solid #4b6893; border-radius:10px; padding:8px;">No metrics yet.</pre>
      </div>
      </div>

      <details class="tool-section">
      <summary>Other Admin Tools (optional)</summary>
      <div class="row" style="margin-top:10px">
        <div>
          <label for="roomCodeDelete">Room Code</label>
          <input id="roomCodeDelete" placeholder="DADDYR" />
        </div>
        <div style="align-self:end"><button id="deleteRoomBtn" class="danger">Delete Room</button></div>
      </div>
      <div style="height:8px"></div>
      <div class="row">
        <div>
          <label for="newAdminUser">Add/Update Username</label>
          <input id="newAdminUser" type="email" placeholder="newadmin@email.com" />
        </div>
        <div>
          <label for="newAdminPass">Add/Update Password</label>
          <input id="newAdminPass" type="password" placeholder="At least 8 characters" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="addAdminBtn" class="secondary">Add / Update Admin</button>
        <button id="refreshBtn" class="secondary">Refresh List</button>
      </div>
      <div style="margin-top:8px">
        <label for="adminList">Admins</label>
        <select id="adminList"></select>
      </div>
      <div style="margin-top:8px"><button id="removeAdminBtn" class="danger">Remove Selected Admin</button></div>
      </details>
    </div>
  </div>

  <script>
    const API_PREFIXES = [
      'https://api.frenzynets.com/api/telewatch'
    ];
    const KEY = 'telewatch_admin_session';
    const ADMIN_CODE_KEY = 'telewatch_admin_code';
    const els = {
      status: document.getElementById('status'),
      loginCard: document.getElementById('loginCard'),
      toolsCard: document.getElementById('toolsCard'),
      username: document.getElementById('username'),
      password: document.getElementById('password'),
      adminCode: document.getElementById('adminCode'),
      roomCodeDelete: document.getElementById('roomCodeDelete'),
      mainEventRoomCode: document.getElementById('mainEventRoomCode'),
      mainEventLockdown: document.getElementById('mainEventLockdown'),
      mainEventCountdown: document.getElementById('mainEventCountdown'),
      mainEventHostName: document.getElementById('mainEventHostName'),
      mainEventTitle: document.getElementById('mainEventTitle'),
      mainEventMode: document.getElementById('mainEventMode'),
      mainEventTemplate: document.getElementById('mainEventTemplate'),
      applyTemplateBtn: document.getElementById('applyTemplateBtn'),
      mainEventRooms: document.getElementById('mainEventRooms'),
      refreshRoomsBtn: document.getElementById('refreshRoomsBtn'),
      mainEventPrepBtn: document.getElementById('mainEventPrepBtn'),
      quickStartMainEventBtn: document.getElementById('quickStartMainEventBtn'),
      quickStopMainEventBtn: document.getElementById('quickStopMainEventBtn'),
      rollbackMainEventBtn: document.getElementById('rollbackMainEventBtn'),
      quickMainEventState: document.getElementById('quickMainEventState'),
      runPreflightBtn: document.getElementById('runPreflightBtn'),
      apiHealthBadge: document.getElementById('apiHealthBadge'),
      authHealthBadge: document.getElementById('authHealthBadge'),
      checklist1: document.getElementById('checklist1'),
      checklist2: document.getElementById('checklist2'),
      checklist3: document.getElementById('checklist3'),
      checklist4: document.getElementById('checklist4'),
      checklist5: document.getElementById('checklist5'),
      guideStep1: document.getElementById('guideStep1'),
      guideStep2: document.getElementById('guideStep2'),
      guideStep3: document.getElementById('guideStep3'),
      guideStep4: document.getElementById('guideStep4'),
      createMainEventBtn: document.getElementById('createMainEventBtn'),
      mainEventGoLiveBtn: document.getElementById('mainEventGoLiveBtn'),
      enableMainEventBtn: document.getElementById('enableMainEventBtn'),
      disableMainEventBtn: document.getElementById('disableMainEventBtn'),
      stopMainEventBtn: document.getElementById('stopMainEventBtn'),
      openMainEventBtn: document.getElementById('openMainEventBtn'),
      copyMainEventJoinBtn: document.getElementById('copyMainEventJoinBtn'),
      mainEventInfo: document.getElementById('mainEventInfo'),
      mainEventHostInfo: document.getElementById('mainEventHostInfo'),
      studioTitle: document.getElementById('studioTitle'),
      studioMediaUrl: document.getElementById('studioMediaUrl'),
      studioSeekSec: document.getElementById('studioSeekSec'),
      studioTheme: document.getElementById('studioTheme'),
      studioAccessMode: document.getElementById('studioAccessMode'),
      studioMessage: document.getElementById('studioMessage'),
      studioAttachHostBtn: document.getElementById('studioAttachHostBtn'),
      backupCohostSelect: document.getElementById('backupCohostSelect'),
      assignBackupBtn: document.getElementById('assignBackupBtn'),
      studioSetMediaBtn: document.getElementById('studioSetMediaBtn'),
      studioSetTitleBtn: document.getElementById('studioSetTitleBtn'),
      studioPlayBtn: document.getElementById('studioPlayBtn'),
      studioPauseBtn: document.getElementById('studioPauseBtn'),
      studioSeekBtn: document.getElementById('studioSeekBtn'),
      studioThemeBtn: document.getElementById('studioThemeBtn'),
      studioAccessBtn: document.getElementById('studioAccessBtn'),
      studioMessageBtn: document.getElementById('studioMessageBtn'),
      studioStreamUrl: document.getElementById('studioStreamUrl'),
      studioStreamFrame: document.getElementById('studioStreamFrame'),
      studioLoadStreamBtn: document.getElementById('studioLoadStreamBtn'),
      studioPopoutStreamBtn: document.getElementById('studioPopoutStreamBtn'),
      studioRefreshStreamBtn: document.getElementById('studioRefreshStreamBtn'),
      macroIntermissionBtn: document.getElementById('macroIntermissionBtn'),
      macroResumeBtn: document.getElementById('macroResumeBtn'),
      panicModeBtn: document.getElementById('panicModeBtn'),
      delayedStartMinutes: document.getElementById('delayedStartMinutes'),
      scheduleGoLiveBtn: document.getElementById('scheduleGoLiveBtn'),
      cancelGoLiveBtn: document.getElementById('cancelGoLiveBtn'),
      delayedStartStatus: document.getElementById('delayedStartStatus'),
      qualityAutoToggle: document.getElementById('qualityAutoToggle'),
      qualityHighThreshold: document.getElementById('qualityHighThreshold'),
      applyQualityModeBtn: document.getElementById('applyQualityModeBtn'),
      autoRecoveryToggle: document.getElementById('autoRecoveryToggle'),
      promoteBackupNowBtn: document.getElementById('promoteBackupNowBtn'),
      muteAllBtn: document.getElementById('muteAllBtn'),
      lockRoomBtn: document.getElementById('lockRoomBtn'),
      clearChatBtn: document.getElementById('clearChatBtn'),
      inviteTtlAdmin: document.getElementById('inviteTtlAdmin'),
      inviteUsesAdmin: document.getElementById('inviteUsesAdmin'),
      createInviteBtn: document.getElementById('createInviteBtn'),
      inviteListSelect: document.getElementById('inviteListSelect'),
      refreshInvitesBtn: document.getElementById('refreshInvitesBtn'),
      revokeInviteBtn: document.getElementById('revokeInviteBtn'),
      deviceTestBtn: document.getElementById('deviceTestBtn'),
      incidentRecoverBtn: document.getElementById('incidentRecoverBtn'),
      deviceTestStatus: document.getElementById('deviceTestStatus'),
      incidentStatus: document.getElementById('incidentStatus'),
      routerDiagBtn: document.getElementById('routerDiagBtn'),
      routerDiagStatus: document.getElementById('routerDiagStatus'),
      metricsSummary: document.getElementById('metricsSummary'),
      metricsGraph: document.getElementById('metricsGraph'),
      newAdminUser: document.getElementById('newAdminUser'),
      newAdminPass: document.getElementById('newAdminPass'),
      adminList: document.getElementById('adminList'),
      loginBtn: document.getElementById('loginBtn'),
      logoutBtn: document.getElementById('logoutBtn'),
      deleteRoomBtn: document.getElementById('deleteRoomBtn'),
      loadMainEventBtn: document.getElementById('loadMainEventBtn'),
      nextSaturdayBtn: document.getElementById('nextSaturdayBtn'),
      saveMainEventBtn: document.getElementById('saveMainEventBtn'),
      addAdminBtn: document.getElementById('addAdminBtn'),
      refreshBtn: document.getElementById('refreshBtn'),
      removeAdminBtn: document.getElementById('removeAdminBtn'),
    };
    const state = {
      token: '',
      username: '',
      mainHostToken: '',
      mainHostRoomCode: '',
      liveStarted: false,
      adminCodeFailCount: 0,
      adminCodeLockUntil: 0,
      delayedGoLiveTimer: null,
      delayedGoLiveAt: 0,
      metricsHistory: [],
      prevViewerCount: 0,
      prevViewerTs: 0,
    };

    async function api(path, body, method = 'POST') {
      if (state.adminCodeLockUntil && Date.now() < state.adminCodeLockUntil) {
        throw new Error('admin_code_temporarily_locked');
      }
      let lastErr = null;
      for (const prefix of API_PREFIXES) {
        try {
          const target = prefix + path;
          const opts = { method, cache: 'no-store', headers: {} };
          if (method !== 'GET') {
            opts.headers['Content-Type'] = 'application/json';
            opts.body = JSON.stringify(body || {});
          }
          const res = await fetch(target, opts);
          const txt = await res.text();
          let data = {};
          try { data = txt ? JSON.parse(txt) : {}; } catch (_) {}
          if (!res.ok) {
            const code = String(data.error || ('HTTP ' + res.status));
            if (code === 'admin_code_invalid') {
              state.adminCodeFailCount += 1;
              if (state.adminCodeFailCount >= 5) {
                state.adminCodeLockUntil = Date.now() + 30000;
              }
            } else {
              state.adminCodeFailCount = 0;
              state.adminCodeLockUntil = 0;
            }
            throw new Error(code);
          }
          state.adminCodeFailCount = 0;
          state.adminCodeLockUntil = 0;
          return data;
        } catch (err) {
          lastErr = err;
        }
      }
      throw lastErr || new Error('request_failed');
    }

    async function apiGet(path, query) {
      const q = new URLSearchParams();
      Object.entries(query || {}).forEach(([k, v]) => {
        if (v === null || typeof v === 'undefined' || v === '') return;
        q.set(k, String(v));
      });
      const url = q.toString() ? `${path}?${q.toString()}` : path;
      return api(url, null, 'GET');
    }

    function setStatus(msg) { els.status.textContent = msg; }
    function readAdminCode() {
      return String(els.adminCode.value || '').trim();
    }
    function persistAdminCode() {
      try {
        const code = readAdminCode();
        if (!code) {
          localStorage.removeItem(ADMIN_CODE_KEY);
          return;
        }
        localStorage.setItem(ADMIN_CODE_KEY, code);
      } catch (_) {}
    }
    function loadAdminCode() {
      try {
        const code = String(localStorage.getItem(ADMIN_CODE_KEY) || '').trim();
        if (code && !els.adminCode.value) els.adminCode.value = code;
      } catch (_) {}
    }
    function ensureAdminCode() {
      const code = readAdminCode();
      if (code) return code;
      setStatus('Admin code is required for this action.');
      els.adminCode.focus();
      setChecklist();
      throw new Error('admin_code_required');
    }
    function describeApiError(err) {
      const msg = String(err && err.message ? err.message : err);
      if (msg === 'admin_auth_invalid' || msg === 'admin_auth_required') return 'Session expired. Sign in again.';
      if (msg === 'admin_code_required' || msg === 'admin_code_invalid') return 'Enter the correct admin code.';
      if (msg === 'admin_code_temporarily_locked') return 'Too many bad admin-code attempts. Wait 30 seconds.';
      if (msg === 'room_code_taken') return 'That room code already exists. Choose another room code.';
      if (msg === 'host_router_limit') return 'This network already has an active hosted room. End it first.';
      if (msg === 'room_capacity_reached') return 'Max room capacity reached on server.';
      if (msg === 'main_event_room_locked') return 'Main Event room is locked to another code.';
      if (msg === 'backup_participant_required') return 'Pick a backup co-host first.';
      if (msg === 'inviteToken_required') return 'Select an invite token first.';
      return msg;
    }
    function cleanCode(v) {
      return String(v || '').trim().toUpperCase().replace(/[^A-Z0-9_-]/g, '').slice(0, 24);
    }
    function mainEventJoinUrl(code) {
      const c = cleanCode(code);
      return c ? `https://frenzynets.com/FlickFuse/?room=${encodeURIComponent(c)}` : 'https://frenzynets.com/FlickFuse/?mainEvent=1';
    }
    function mainEventStudioUrl(code) {
      const c = cleanCode(code);
      return c ? `https://frenzynets.com/FlickFuse/?room=${encodeURIComponent(c)}&admin=1` : 'https://frenzynets.com/FlickFuse/?admin=1';
    }
    function setQuickState(msg) {
      if (els.quickMainEventState) els.quickMainEventState.textContent = msg;
    }
    function setGuideProgress(stepNum) {
      const nodes = [els.guideStep1, els.guideStep2, els.guideStep3, els.guideStep4];
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (!node) continue;
        node.classList.toggle('done', i < stepNum);
      }
    }
    function setChecklist() {
      const hasCode = !!readAdminCode();
      const hasRoom = !!selectedMainRoomCode();
      const hasHost = !!(state.mainHostToken && cleanCode(state.mainHostRoomCode));
      const hasStream = !!String(els.studioStreamFrame && els.studioStreamFrame.src || '').trim();
      const live = !!state.liveStarted;
      if (els.checklist1) els.checklist1.classList.toggle('done', hasCode);
      if (els.checklist2) els.checklist2.classList.toggle('done', hasRoom);
      if (els.checklist3) els.checklist3.classList.toggle('done', hasHost);
      if (els.checklist4) els.checklist4.classList.toggle('done', hasStream);
      if (els.checklist5) els.checklist5.classList.toggle('done', live);
    }
    function toLocalInputValue(iso) {
      const d = new Date(String(iso || '').trim());
      if (!Number.isFinite(d.getTime())) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }
    function localInputToIso(v) {
      const s = String(v || '').trim();
      if (!s) return '';
      const d = new Date(s);
      if (!Number.isFinite(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }
    function nextSaturdayLocalInput() {
      const now = new Date();
      const target = new Date(now.getTime());
      const days = (6 - target.getDay() + 7) % 7;
      target.setDate(target.getDate() + days);
      target.setHours(20, 0, 0, 0);
      if (target.getTime() <= now.getTime()) target.setDate(target.getDate() + 7);
      return toLocalInputValue(target.toISOString());
    }
    function render() {
      const signed = !!(state.token && state.username);
      els.loginCard.classList.toggle('hidden', signed);
      els.toolsCard.classList.toggle('hidden', !signed);
      setStatus(signed ? ('Signed in as ' + state.username) : 'Not signed in');
      const hostReady = !!(state.mainHostToken && cleanCode(state.mainHostRoomCode));
      els.mainEventHostInfo.textContent = hostReady
        ? `Host controls attached to ${cleanCode(state.mainHostRoomCode)}`
        : 'Host controls: not attached';
      setChecklist();
    }
    function save() {
      try {
        if (!state.token) return localStorage.removeItem(KEY);
        localStorage.setItem(KEY, JSON.stringify({
          adminToken: state.token,
          adminUsername: state.username,
          mainHostToken: state.mainHostToken,
          mainHostRoomCode: state.mainHostRoomCode
        }));
        persistAdminCode();
      } catch (_) {}
    }
    function load() {
      try {
        const raw = localStorage.getItem(KEY) || '';
        if (!raw) return;
        const s = JSON.parse(raw);
        state.token = String(s.adminToken || '').trim();
        state.username = String(s.adminUsername || '').trim().toLowerCase();
        state.mainHostToken = String(s.mainHostToken || '').trim();
        state.mainHostRoomCode = cleanCode(s.mainHostRoomCode || '');
      } catch (_) {}
    }

    function selectedMainRoomCode() {
      return cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value || state.mainHostRoomCode);
    }

    async function sendMainControl(action, extra) {
      const roomCode = selectedMainRoomCode();
      const participantToken = String(state.mainHostToken || '').trim();
      if (!roomCode) throw new Error('main_event_room_required');
      if (!participantToken) throw new Error('host_controls_not_attached');
      try {
        return await api('/api/watch/control', Object.assign({
          roomCode,
          participantToken,
          action
        }, extra || {}));
      } catch (err) {
        const code = String(err && err.message ? err.message : err);
        const recoverEnabled = String(els.autoRecoveryToggle && els.autoRecoveryToggle.value || 'on') === 'on';
        if (recoverEnabled && code === 'invalid_participant') {
          const rejoin = await api('/api/watch/join', {
            roomCode,
            displayName: String(els.mainEventHostName.value || '').trim() || 'MainHost'
          });
          if (!rejoin || !rejoin.isHost) throw err;
          state.mainHostToken = String(rejoin.participantToken || '').trim();
          state.mainHostRoomCode = roomCode;
          save();
          render();
          return api('/api/watch/control', Object.assign({
            roomCode,
            participantToken: state.mainHostToken,
            action
          }, extra || {}));
        }
        throw err;
      }
    }

    async function refreshAdmins() {
      const data = await api('/api/watch/admin/list', { adminToken: state.token });
      const rows = Array.isArray(data.admins) ? data.admins : [];
      els.adminList.innerHTML = '';
      for (const r of rows) {
        const o = document.createElement('option');
        o.value = r.username;
        o.textContent = r.isOwner ? `${r.username} (owner)` : r.username;
        els.adminList.appendChild(o);
      }
      if (!rows.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No admins found';
        els.adminList.appendChild(o);
      }
    }

    async function refreshAdminRooms() {
      const data = await api('/api/watch/admin/rooms', { adminToken: state.token });
      const rows = Array.isArray(data.rooms) ? data.rooms : [];
      els.mainEventRooms.innerHTML = '';
      for (const r of rows) {
        const code = cleanCode(r.roomCode || '');
        if (!code) continue;
        const o = document.createElement('option');
        o.value = code;
        const host = String(r.hostName || '').trim() || 'No host';
        const count = Number(r.activeCount || 0);
        o.textContent = `${code} · ${host} · ${count} live`;
        els.mainEventRooms.appendChild(o);
      }
      if (!els.mainEventRooms.options.length) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'No active rooms';
        els.mainEventRooms.appendChild(o);
      }
      const selected = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
      els.mainEventInfo.textContent = selected ? `Main Event Link: ${mainEventJoinUrl(selected)}` : 'No main event room selected.';
      els.studioStreamUrl.value = mainEventStudioUrl(selected);
      setChecklist();
      await refreshBackupCandidates();
    }

    async function loadMainEventSettings() {
      const data = await api('/api/watch/admin/settings', { adminToken: state.token, action: 'get' });
      const s = data && data.settings ? data.settings : {};
      els.mainEventRoomCode.value = String(s.mainEventRoomCode || '').toUpperCase();
      els.mainEventLockdown.value = s.mainEventLockdown ? '1' : '0';
      els.mainEventCountdown.value = toLocalInputValue(s.mainEventCountdownIso || '');
      const c = cleanCode(s.mainEventRoomCode || '');
      els.mainEventInfo.textContent = c ? `Main Event Link: ${mainEventJoinUrl(c)}` : 'No main event room selected.';
      els.studioStreamUrl.value = mainEventStudioUrl(c);
      setChecklist();
    }

    async function refreshHealthBadges() {
      try {
        const r = await fetch('https://api.frenzynets.com/api/telewatch/public-settings', { cache: 'no-store' });
        const ok = !!r.ok;
        els.apiHealthBadge.textContent = ok ? 'API: online' : `API: error (${r.status})`;
        els.apiHealthBadge.classList.toggle('ok', ok);
        els.apiHealthBadge.classList.toggle('bad', !ok);
      } catch (_) {
        els.apiHealthBadge.textContent = 'API: offline';
        els.apiHealthBadge.classList.remove('ok');
        els.apiHealthBadge.classList.add('bad');
      }
      try {
        if (!state.token) throw new Error('no_token');
        await api('/api/watch/admin/list', { adminToken: state.token });
        els.authHealthBadge.textContent = 'Auth: valid';
        els.authHealthBadge.classList.add('ok');
        els.authHealthBadge.classList.remove('bad');
      } catch (_) {
        els.authHealthBadge.textContent = 'Auth: sign in required';
        els.authHealthBadge.classList.remove('ok');
        els.authHealthBadge.classList.add('bad');
      }
    }

    function applyTemplate() {
      const t = String(els.mainEventTemplate.value || 'big_movie').trim();
      if (t === 'anime_night') {
        els.mainEventTitle.value = els.mainEventTitle.value || 'Anime Marathon';
        els.studioTheme.value = 'anime';
        els.mainEventMode.value = 'broadcast';
        els.studioAccessMode.value = 'public';
        return;
      }
      if (t === 'sports_watch') {
        els.mainEventTitle.value = els.mainEventTitle.value || 'Sports Main Event';
        els.studioTheme.value = 'city';
        els.mainEventMode.value = 'broadcast';
        els.studioAccessMode.value = 'public';
        return;
      }
      els.mainEventTitle.value = els.mainEventTitle.value || 'Big Movie Night';
      els.studioTheme.value = 'clean';
      els.mainEventMode.value = 'broadcast';
      els.studioAccessMode.value = 'public';
    }

    async function refreshBackupCandidates() {
      if (!els.backupCohostSelect) return;
      els.backupCohostSelect.innerHTML = '';
      try {
        const roomCode = selectedMainRoomCode();
        const token = String(state.mainHostToken || '').trim();
        if (!roomCode || !token) throw new Error('host_controls_not_attached');
        const data = await apiGet('/api/watch/state', { roomCode, participantToken: token, sinceEventId: 0 });
        const participants = Array.isArray(data.participants) ? data.participants : [];
        const rows = participants.filter((p) => !p.isHost);
        for (const p of rows) {
          const id = String(p.participantId || '').trim().toLowerCase();
          if (!id) continue;
          const o = document.createElement('option');
          o.value = id;
          o.textContent = `${String(p.displayName || 'Guest')} (${id})`;
          els.backupCohostSelect.appendChild(o);
        }
        if (!els.backupCohostSelect.options.length) {
          const o = document.createElement('option');
          o.value = '';
          o.textContent = 'No backup candidates';
          els.backupCohostSelect.appendChild(o);
        }
      } catch (_) {
        const o = document.createElement('option');
        o.value = '';
        o.textContent = 'Attach host controls first';
        els.backupCohostSelect.appendChild(o);
      }
    }

    async function runPreflight() {
      const checks = [];
      const adminCodeOk = !!readAdminCode();
      checks.push(adminCodeOk ? 'Admin code: OK' : 'Admin code: MISSING');
      const roomCode = selectedMainRoomCode();
      checks.push(roomCode ? `Room: ${roomCode}` : 'Room: NOT SET');
      const hostOk = !!(state.mainHostToken && cleanCode(state.mainHostRoomCode));
      checks.push(hostOk ? 'Host controls: ATTACHED' : 'Host controls: NOT ATTACHED');
      const streamLoaded = !!String(els.studioStreamFrame && els.studioStreamFrame.src || '').trim();
      checks.push(streamLoaded ? 'Stream console: LOADED' : 'Stream console: NOT LOADED');
      await refreshHealthBadges();
      const apiOk = els.apiHealthBadge.classList.contains('ok');
      const authOk = els.authHealthBadge.classList.contains('ok');
      checks.push(apiOk ? 'API health: OK' : 'API health: FAIL');
      checks.push(authOk ? 'Auth health: OK' : 'Auth health: FAIL');
      setStatus(`Preflight -> ${checks.join(' | ')}`);
      setChecklist();
    }

    function renderMetricsGraph() {
      const rows = state.metricsHistory.slice(-24);
      if (!rows.length) {
        els.metricsGraph.textContent = 'No metrics yet.';
        return;
      }
      const max = Math.max(1, ...rows);
      const bars = rows.map((v) => {
        const n = Math.max(1, Math.round((v / max) * 12));
        return '▇'.repeat(n);
      });
      els.metricsGraph.textContent = bars.join('\n');
    }

    async function refreshLiveMetrics() {
      try {
        const roomCode = selectedMainRoomCode();
        const token = String(state.mainHostToken || '').trim();
        if (!roomCode || !token) return;
        const data = await apiGet('/api/watch/state', { roomCode, participantToken: token, sinceEventId: 0 });
        const viewers = Array.isArray(data.participants) ? data.participants.length : 0;
        const now = Date.now();
        let joinRate = 0;
        if (state.prevViewerTs > 0) {
          const mins = Math.max(0.016, (now - state.prevViewerTs) / 60000);
          joinRate = (viewers - state.prevViewerCount) / mins;
        }
        state.prevViewerCount = viewers;
        state.prevViewerTs = now;
        state.metricsHistory.push(viewers);
        if (state.metricsHistory.length > 120) state.metricsHistory.shift();
        const mode = String(data.room && data.room.mediaMode || 'unknown');
        els.metricsSummary.textContent = `Viewers: ${viewers} | Join rate: ${joinRate.toFixed(1)}/min | Mode: ${mode}`;
        renderMetricsGraph();

        const autoMode = String(els.qualityAutoToggle && els.qualityAutoToggle.value || 'off');
        if (autoMode === 'on') {
          const threshold = Math.max(20, Number(els.qualityHighThreshold.value || 80));
          const targetMode = viewers >= threshold ? 'broadcast' : 'sfu';
          if (targetMode !== mode) {
            await sendMainControl('set_media_mode', { mediaMode: targetMode });
            setStatus(`Auto quality switched to ${targetMode}.`);
          }
        }
      } catch (_) {}
    }

    async function refreshInvites() {
      try {
        const data = await sendMainControl('list_invites', {});
        const rows = Array.isArray(data && data.actionPayload && data.actionPayload.invites)
          ? data.actionPayload.invites
          : [];
        els.inviteListSelect.innerHTML = '';
        for (const row of rows) {
          const token = String(row.inviteToken || '').trim();
          if (!token) continue;
          const o = document.createElement('option');
          o.value = token;
          o.textContent = `${token} · uses ${Number(row.usedCount || 0)}/${Number(row.maxUses || 0) || '∞'}`;
          els.inviteListSelect.appendChild(o);
        }
        if (!els.inviteListSelect.options.length) {
          const o = document.createElement('option');
          o.value = '';
          o.textContent = 'No invites';
          els.inviteListSelect.appendChild(o);
        }
      } catch (e) {
        setStatus('Invite refresh failed: ' + describeApiError(e));
      }
    }

    async function refreshRouterDiagnostics() {
      const roomCode = selectedMainRoomCode();
      const data = await api('/api/watch/admin/host-router/status', {
        adminToken: state.token,
        roomCode
      });
      const rows = Array.isArray(data.lockRooms) ? data.lockRooms : [];
      const lines = [];
      lines.push(`Requested IP: ${String(data.requestedIp || 'unknown')}`);
      lines.push(`Lock Active: ${rows.length > 0 ? 'YES' : 'NO'}`);
      if (rows.length > 0) {
        lines.push('Rooms holding host-router lock:');
        for (const r of rows) {
          lines.push(`- ${String(r.roomCode || '')} | host=${String(r.hostName || 'Host')} | active=${Number(r.activeCount || 0)} | seen=${String(r.hostLastSeenAt || '')}`);
        }
      }
      const roomInfo = data && data.roomInfo ? data.roomInfo : null;
      if (roomInfo && roomInfo.roomCode) {
        lines.push('');
        lines.push(`Selected Room: ${String(roomInfo.roomCode || '')}`);
        lines.push(`- hostIp=${String(roomInfo.hostIp || '')} | host=${String(roomInfo.hostName || 'Host')} | active=${Number(roomInfo.activeCount || 0)} | seen=${String(roomInfo.hostLastSeenAt || '')}`);
      }
      if (els.routerDiagStatus) {
        els.routerDiagStatus.textContent = lines.join('\n');
      }
      return data;
    }

    els.loginBtn.addEventListener('click', async () => {
      try {
        const data = await api('/api/watch/admin/login', {
          username: String(els.username.value || '').trim().toLowerCase(),
          password: String(els.password.value || '').trim()
        });
        state.token = String(data.adminToken || '');
        state.username = String(data.username || '').toLowerCase();
        save();
        render();
        await refreshAdmins();
        await refreshAdminRooms();
        await loadMainEventSettings();
        await refreshHealthBadges();
        await refreshInvites();
        await refreshLiveMetrics();
      } catch (e) {
        setStatus('Login failed: ' + describeApiError(e));
      }
    });

    els.logoutBtn.addEventListener('click', async () => {
      try { await api('/api/watch/admin/logout', { adminToken: state.token }); } catch (_) {}
      state.token = '';
      state.username = '';
      state.mainHostToken = '';
      state.mainHostRoomCode = '';
      state.liveStarted = false;
      save();
      render();
      refreshHealthBadges().catch(() => {});
    });

    els.deleteRoomBtn.addEventListener('click', async () => {
      try {
        if (!window.confirm('Delete this room now? This cannot be undone.')) return;
        const adminCode = ensureAdminCode();
        await api('/api/watch/delete', {
          roomCode: String(els.roomCodeDelete.value || '').trim().toUpperCase(),
          adminToken: state.token,
          adminCode
        });
        setStatus('Room deleted.');
      } catch (e) {
        setStatus('Delete failed: ' + describeApiError(e));
      }
    });

    els.loadMainEventBtn.addEventListener('click', async () => {
      try {
        await loadMainEventSettings();
        await refreshAdminRooms();
        setStatus('Main event settings loaded.');
      } catch (e) {
        setStatus('Load failed: ' + (e.message || e));
      }
    });

    els.nextSaturdayBtn.addEventListener('click', () => {
      els.mainEventCountdown.value = nextSaturdayLocalInput();
      setStatus('Countdown set to next Saturday (local time).');
    });

    els.saveMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        const payload = {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventRoomCode: String(els.mainEventRoomCode.value || '').trim().toUpperCase(),
          mainEventLockdown: els.mainEventLockdown.value === '1',
          mainEventCountdownIso: localInputToIso(els.mainEventCountdown.value)
        };
        await api('/api/watch/admin/settings', payload);
        await loadMainEventSettings();
        await refreshAdminRooms();
        setStatus('Main event settings saved.');
      } catch (e) {
        setStatus('Save failed: ' + describeApiError(e));
      }
    });

    els.mainEventRooms.addEventListener('change', () => {
      const code = cleanCode(els.mainEventRooms.value);
      if (code) {
        els.mainEventRoomCode.value = code;
        els.mainEventInfo.textContent = `Main Event Link: ${mainEventJoinUrl(code)}`;
        els.studioStreamUrl.value = mainEventStudioUrl(code);
      }
      setChecklist();
      refreshInvites().catch(() => {});
    });

    els.mainEventRoomCode.addEventListener('input', () => {
      const code = cleanCode(els.mainEventRoomCode.value);
      els.mainEventRoomCode.value = code;
      els.mainEventInfo.textContent = code ? `Main Event Link: ${mainEventJoinUrl(code)}` : 'No main event room selected.';
      els.studioStreamUrl.value = mainEventStudioUrl(code);
      setChecklist();
      refreshInvites().catch(() => {});
    });

    els.refreshRoomsBtn.addEventListener('click', async () => {
      try {
        await refreshAdminRooms();
        setStatus('Rooms refreshed.');
      } catch (e) {
        setStatus('Room refresh failed: ' + (e.message || e));
      }
    });

    els.applyTemplateBtn.addEventListener('click', () => {
      applyTemplate();
      setStatus('Template applied.');
    });

    els.runPreflightBtn.addEventListener('click', async () => {
      try {
        await runPreflight();
      } catch (e) {
        setStatus('Preflight failed: ' + describeApiError(e));
      }
    });

    els.macroIntermissionBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('pause', {});
        await sendMainControl('chat', { message: 'Intermission started. We resume shortly.' });
        setStatus('Intermission macro executed.');
      } catch (e) {
        setStatus('Intermission failed: ' + describeApiError(e));
      }
    });

    els.macroResumeBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('chat', { message: 'Resuming now. Enjoy.' });
        await sendMainControl('play', {});
        setStatus('Resume macro executed.');
      } catch (e) {
        setStatus('Resume failed: ' + describeApiError(e));
      }
    });

    els.panicModeBtn.addEventListener('click', async () => {
      try {
        if (!window.confirm('Panic Mode will close new joins immediately. Continue?')) return;
        await sendMainControl('set_access_mode', { accessMode: 'closed' });
        await sendMainControl('chat', { message: 'Panic mode enabled: new joins are closed.' });
        setStatus('Panic mode enabled.');
      } catch (e) {
        setStatus('Panic mode failed: ' + describeApiError(e));
      }
    });

    els.mainEventPrepBtn.addEventListener('click', async () => {
      try {
        if (!els.mainEventCountdown.value) {
          els.mainEventCountdown.value = nextSaturdayLocalInput();
        }
        els.mainEventMode.value = 'broadcast';
        els.studioAccessMode.value = 'public';
        els.studioTheme.value = 'clean';
        await refreshAdminRooms();
        await loadMainEventSettings();
        setStatus('Console prepped for big night.');
      } catch (e) {
        setStatus('Prep failed: ' + (e.message || e));
      }
    });

    els.quickStartMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        setQuickState('Starting: preparing console defaults...');
        if (!els.mainEventCountdown.value) {
          els.mainEventCountdown.value = nextSaturdayLocalInput();
        }
        if (!String(els.mainEventMode.value || '').trim()) els.mainEventMode.value = 'broadcast';
        if (!String(els.studioAccessMode.value || '').trim()) els.studioAccessMode.value = 'public';
        if (!String(els.studioTheme.value || '').trim()) els.studioTheme.value = 'clean';

        let code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
        if (!code) {
          setQuickState('Creating main event room...');
          const created = await api('/api/watch/create', {
            adminToken: state.token,
            roomCode: '',
            displayName: String(els.mainEventHostName.value || '').trim() || 'MainHost',
            title: String(els.mainEventTitle.value || '').trim() || 'Main Event',
            accessMode: 'public',
            mediaMode: String(els.mainEventMode.value || 'broadcast').trim().toLowerCase()
          });
          code = cleanCode(created.roomCode || '');
          state.mainHostToken = String(created.participantToken || '').trim();
          state.mainHostRoomCode = code;
        }
        if (!code) throw new Error('main_event_room_required');
        els.mainEventRoomCode.value = code;

        setQuickState('Applying lockdown + countdown settings...');
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventRoomCode: code,
          mainEventLockdown: true,
          mainEventCountdownIso: localInputToIso(els.mainEventCountdown.value)
        });
        els.mainEventLockdown.value = '1';

        if (!String(state.mainHostToken || '').trim() || cleanCode(state.mainHostRoomCode) !== code) {
          setQuickState('Attaching host controls...');
          const joined = await api('/api/watch/join', {
            roomCode: code,
            displayName: String(els.mainEventHostName.value || '').trim() || 'MainHost'
          });
          if (joined && joined.isHost) {
            state.mainHostToken = String(joined.participantToken || '').trim();
            state.mainHostRoomCode = code;
          }
        }

        if (String(els.studioTitle.value || '').trim() || String(els.studioMediaUrl.value || '').trim()) {
          setQuickState('Setting movie details...');
          await sendMainControl('set_media', {
            title: String(els.studioTitle.value || els.mainEventTitle.value || '').trim(),
            mediaUrl: String(els.studioMediaUrl.value || '').trim()
          });
        }
        await sendMainControl('set_access_mode', { accessMode: String(els.studioAccessMode.value || 'public').trim() });
        await sendMainControl('set_theme', { themeKey: String(els.studioTheme.value || 'clean').trim() });

        const url = mainEventStudioUrl(code);
        els.studioStreamUrl.value = url;
        els.studioStreamFrame.src = url;
        state.liveStarted = false;
        save();
        render();
        await refreshAdminRooms();
        await loadMainEventSettings();
        setGuideProgress(1);
        setQuickState(`Ready: room ${code} configured. Use Go Live when stream is ready.`);
        setStatus(`Main Event quick setup complete for ${code}.`);
      } catch (e) {
        setQuickState('Quick Start failed. Check admin code / room state.');
        setStatus('Quick Start failed: ' + describeApiError(e));
      }
    });

    els.quickStopMainEventBtn.addEventListener('click', async () => {
      try {
        if (!window.confirm('Quick Stop will end the event, disable lockdown, and delete the room. Continue?')) return;
        const adminCode = ensureAdminCode();
        const code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value || state.mainHostRoomCode);
        if (!code) throw new Error('main_event_room_required');
        await api('/api/watch/delete', {
          roomCode: code,
          adminToken: state.token,
          adminCode
        });
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventLockdown: false,
          mainEventRoomCode: ''
        });
        state.mainHostToken = '';
        state.mainHostRoomCode = '';
        state.liveStarted = false;
        els.mainEventRoomCode.value = '';
        els.mainEventLockdown.value = '0';
        els.studioStreamFrame.src = '';
        els.studioStreamUrl.value = mainEventStudioUrl('');
        save();
        render();
        await refreshAdminRooms();
        await loadMainEventSettings();
        setGuideProgress(0);
        setQuickState('Stopped. Main Event is fully disabled.');
        setStatus(`Main Event stopped and room ${code} deleted.`);
      } catch (e) {
        setQuickState('Quick Stop failed.');
        setStatus('Quick Stop failed: ' + describeApiError(e));
      }
    });

    els.scheduleGoLiveBtn.addEventListener('click', async () => {
      try {
        const mins = Math.max(1, Math.min(120, Number(els.delayedStartMinutes.value || 5)));
        if (state.delayedGoLiveTimer) clearTimeout(state.delayedGoLiveTimer);
        state.delayedGoLiveAt = Date.now() + (mins * 60000);
        els.delayedStartStatus.textContent = `Go Live scheduled in ${mins} minute(s).`;
        state.delayedGoLiveTimer = setTimeout(async () => {
          try {
            await sendMainControl('play', {});
            await sendMainControl('chat', { message: 'Main Event is now LIVE. Enjoy the show.' });
            state.liveStarted = true;
            setChecklist();
            els.delayedStartStatus.textContent = 'Delayed Go Live executed.';
            setStatus('Scheduled Go Live executed.');
          } catch (e) {
            els.delayedStartStatus.textContent = 'Scheduled Go Live failed.';
            setStatus('Scheduled Go Live failed: ' + describeApiError(e));
          }
        }, mins * 60000);
      } catch (e) {
        setStatus('Schedule failed: ' + describeApiError(e));
      }
    });

    els.cancelGoLiveBtn.addEventListener('click', () => {
      if (state.delayedGoLiveTimer) {
        clearTimeout(state.delayedGoLiveTimer);
        state.delayedGoLiveTimer = null;
      }
      state.delayedGoLiveAt = 0;
      els.delayedStartStatus.textContent = 'No delayed start scheduled.';
      setStatus('Scheduled Go Live canceled.');
    });

    els.applyQualityModeBtn.addEventListener('click', async () => {
      try {
        const roomCode = selectedMainRoomCode();
        const token = String(state.mainHostToken || '').trim();
        if (!roomCode || !token) throw new Error('host_controls_not_attached');
        const data = await apiGet('/api/watch/state', { roomCode, participantToken: token, sinceEventId: 0 });
        const viewers = Array.isArray(data.participants) ? data.participants.length : 0;
        const threshold = Math.max(20, Number(els.qualityHighThreshold.value || 80));
        const target = viewers >= threshold ? 'broadcast' : 'sfu';
        await sendMainControl('set_media_mode', { mediaMode: target });
        setStatus(`Quality mode applied: ${target} (${viewers} viewers).`);
      } catch (e) {
        setStatus('Apply quality mode failed: ' + describeApiError(e));
      }
    });

    els.promoteBackupNowBtn.addEventListener('click', async () => {
      try {
        const pid = String(els.backupCohostSelect.value || '').trim().toLowerCase();
        if (!pid) throw new Error('backup_participant_required');
        await sendMainControl('set_cohost', { toParticipantId: pid, enabled: true });
        await sendMainControl('chat', { message: 'Backup co-host has been promoted for failover readiness.' });
        setStatus('Backup promoted.');
      } catch (e) {
        setStatus('Promote backup failed: ' + describeApiError(e));
      }
    });

    els.muteAllBtn.addEventListener('click', async () => {
      try {
        const roomCode = selectedMainRoomCode();
        const token = String(state.mainHostToken || '').trim();
        if (!roomCode || !token) throw new Error('host_controls_not_attached');
        const data = await apiGet('/api/watch/state', { roomCode, participantToken: token, sinceEventId: 0 });
        const participants = Array.isArray(data.participants) ? data.participants : [];
        for (const p of participants) {
          const id = String(p.participantId || '').trim().toLowerCase();
          if (!id || p.isHost) continue;
          await sendMainControl('mute_user', { toParticipantId: id, muted: true });
        }
        setStatus('All participant mics muted.');
      } catch (e) {
        setStatus('Mute all failed: ' + describeApiError(e));
      }
    });

    els.lockRoomBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('set_access_mode', { accessMode: 'closed' });
        setStatus('Room locked (closed to new joins).');
      } catch (e) {
        setStatus('Lock room failed: ' + describeApiError(e));
      }
    });

    els.clearChatBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('chat', { message: '[Host] Chat reset notice: continue with fresh messages.' });
        setStatus('Chat reset notice sent.');
      } catch (e) {
        setStatus('Clear chat notice failed: ' + describeApiError(e));
      }
    });

    els.createInviteBtn.addEventListener('click', async () => {
      try {
        const ttlMinutes = Math.max(5, Math.min(10080, Number(els.inviteTtlAdmin.value || 180)));
        const maxUses = Math.max(0, Math.min(500, Number(els.inviteUsesAdmin.value || 50)));
        await sendMainControl('create_invite', { ttlMinutes, maxUses });
        await refreshInvites();
        setStatus('Invite created.');
      } catch (e) {
        setStatus('Create invite failed: ' + describeApiError(e));
      }
    });

    els.refreshInvitesBtn.addEventListener('click', async () => {
      await refreshInvites();
      setStatus('Invites refreshed.');
    });

    els.revokeInviteBtn.addEventListener('click', async () => {
      try {
        const inviteToken = String(els.inviteListSelect.value || '').trim();
        if (!inviteToken) throw new Error('inviteToken_required');
        await sendMainControl('revoke_invite', { inviteToken });
        await refreshInvites();
        setStatus('Invite revoked.');
      } catch (e) {
        setStatus('Revoke invite failed: ' + describeApiError(e));
      }
    });

    els.deviceTestBtn.addEventListener('click', async () => {
      const result = [];
      try {
        if (!navigator.mediaDevices) throw new Error('media_devices_unavailable');
        const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
        result.push('Mic OK');
        mic.getTracks().forEach((t) => t.stop());
      } catch (_) {
        result.push('Mic FAIL');
      }
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) throw new Error('display_unavailable');
        const disp = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        result.push('Screen OK');
        disp.getTracks().forEach((t) => t.stop());
      } catch (_) {
        result.push('Screen FAIL');
      }
      els.deviceTestStatus.textContent = `Device test: ${result.join(' | ')}`;
    });

    els.incidentRecoverBtn.addEventListener('click', async () => {
      try {
        await runPreflight();
        if (!els.authHealthBadge.classList.contains('ok')) {
          els.incidentStatus.textContent = 'Recovery: sign in again to restore admin auth.';
          return;
        }
        if (!els.apiHealthBadge.classList.contains('ok')) {
          els.incidentStatus.textContent = 'Recovery: API appears down. Keep page open and retry preflight.';
          return;
        }
        els.incidentStatus.textContent = 'No major incident found. System looks healthy.';
      } catch (e) {
        els.incidentStatus.textContent = `Recovery check failed: ${describeApiError(e)}`;
      }
    });

    els.routerDiagBtn.addEventListener('click', async () => {
      try {
        await refreshRouterDiagnostics();
        setStatus('Router diagnostics loaded.');
      } catch (e) {
        if (els.routerDiagStatus) els.routerDiagStatus.textContent = `Diagnostics failed: ${describeApiError(e)}`;
        setStatus('Router diagnostics failed: ' + describeApiError(e));
      }
    });

    els.createMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        const roomCode = cleanCode(els.mainEventRoomCode.value);
        const created = await api('/api/watch/create', {
          adminToken: state.token,
          roomCode,
          displayName: String(els.mainEventHostName.value || '').trim() || 'MainHost',
          title: String(els.mainEventTitle.value || '').trim() || 'Main Event',
          accessMode: 'public',
          mediaMode: String(els.mainEventMode.value || 'broadcast').trim().toLowerCase()
        });
        const code = cleanCode(created.roomCode || roomCode);
        state.mainHostToken = String(created.participantToken || '').trim();
        state.mainHostRoomCode = code;
        state.liveStarted = false;
        els.mainEventRoomCode.value = code;
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventRoomCode: code,
          mainEventLockdown: true,
          mainEventCountdownIso: localInputToIso(els.mainEventCountdown.value)
        });
        els.mainEventLockdown.value = '1';
        await refreshAdminRooms();
        await loadMainEventSettings();
        save();
        render();
        setStatus(`Main Event started in room ${code}.`);
      } catch (e) {
        setStatus('Create Main Event failed: ' + describeApiError(e));
      }
    });

    els.mainEventGoLiveBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('play', {});
        await sendMainControl('chat', { message: 'Main Event is now LIVE. Enjoy the show.' });
        state.liveStarted = true;
        setChecklist();
        setGuideProgress(3);
        setStatus('Main Event is LIVE.');
      } catch (e) {
        setStatus('Go Live failed: ' + (e.message || e));
      }
    });

    els.enableMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        const code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
        if (!code) throw new Error('main_event_room_required');
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventRoomCode: code,
          mainEventLockdown: true,
          mainEventCountdownIso: localInputToIso(els.mainEventCountdown.value)
        });
        els.mainEventLockdown.value = '1';
        await loadMainEventSettings();
        setStatus(`Main Event lockdown enabled for ${code}.`);
      } catch (e) {
        setStatus('Enable failed: ' + describeApiError(e));
      }
    });

    els.disableMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventLockdown: false
        });
        els.mainEventLockdown.value = '0';
        await loadMainEventSettings();
        setStatus('Main Event lockdown disabled.');
      } catch (e) {
        setStatus('Disable failed: ' + describeApiError(e));
      }
    });

    els.studioAttachHostBtn.addEventListener('click', async () => {
      try {
        const roomCode = selectedMainRoomCode();
        if (!roomCode) throw new Error('main_event_room_required');
        const joined = await api('/api/watch/join', {
          roomCode,
          displayName: String(els.mainEventHostName.value || '').trim() || 'MainHost'
        });
        if (!joined.isHost) throw new Error('host_already_active_in_room');
        state.mainHostToken = String(joined.participantToken || '').trim();
        state.mainHostRoomCode = roomCode;
        save();
        render();
        await refreshBackupCandidates();
        setStatus(`Host controls attached to ${roomCode}.`);
      } catch (e) {
        setStatus('Attach failed: ' + (e.message || e));
      }
    });

    els.assignBackupBtn.addEventListener('click', async () => {
      try {
        const pid = String(els.backupCohostSelect.value || '').trim().toLowerCase();
        if (!pid) throw new Error('backup_participant_required');
        await sendMainControl('set_cohost', { toParticipantId: pid, enabled: true });
        setStatus('Backup co-host assigned.');
      } catch (e) {
        setStatus('Assign backup failed: ' + describeApiError(e));
      }
    });

    els.studioSetMediaBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('set_media', {
          title: String(els.studioTitle.value || '').trim(),
          mediaUrl: String(els.studioMediaUrl.value || '').trim()
        });
        setStatus('Movie/media set for Main Event room.');
      } catch (e) {
        setStatus('Set movie failed: ' + (e.message || e));
      }
    });

    els.studioSetTitleBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('set_title', { title: String(els.studioTitle.value || '').trim() });
        setStatus('Main Event title updated.');
      } catch (e) {
        setStatus('Set title failed: ' + (e.message || e));
      }
    });

    els.studioPlayBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('play', {});
        setStatus('Playback set to play.');
      } catch (e) {
        setStatus('Play failed: ' + (e.message || e));
      }
    });

    els.studioPauseBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('pause', {});
        setStatus('Playback paused.');
      } catch (e) {
        setStatus('Pause failed: ' + (e.message || e));
      }
    });

    els.studioSeekBtn.addEventListener('click', async () => {
      try {
        const sec = Number(String(els.studioSeekSec.value || '').trim());
        if (!Number.isFinite(sec) || sec < 0) throw new Error('seek_seconds_invalid');
        await sendMainControl('seek', { playbackSec: sec });
        setStatus(`Seeked to ${Math.floor(sec)}s.`);
      } catch (e) {
        setStatus('Seek failed: ' + (e.message || e));
      }
    });

    els.studioThemeBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('set_theme', { themeKey: String(els.studioTheme.value || 'clean').trim() });
        setStatus('Theme updated.');
      } catch (e) {
        setStatus('Set theme failed: ' + (e.message || e));
      }
    });

    els.studioAccessBtn.addEventListener('click', async () => {
      try {
        await sendMainControl('set_access_mode', { accessMode: String(els.studioAccessMode.value || 'public').trim() });
        setStatus('Access mode updated.');
      } catch (e) {
        setStatus('Set access failed: ' + (e.message || e));
      }
    });

    els.studioMessageBtn.addEventListener('click', async () => {
      try {
        const message = String(els.studioMessage.value || '').trim();
        if (!message) throw new Error('message_required');
        await sendMainControl('chat', { message });
        els.studioMessage.value = '';
        setStatus('Room message sent.');
      } catch (e) {
        setStatus('Message send failed: ' + (e.message || e));
      }
    });

    els.stopMainEventBtn.addEventListener('click', async () => {
      try {
        if (!window.confirm('Stop + Delete this Main Event room now?')) return;
        const adminCode = ensureAdminCode();
        const code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
        if (!code) throw new Error('main_event_room_required');
        await api('/api/watch/delete', {
          roomCode: code,
          adminToken: state.token,
          adminCode
        });
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventLockdown: false,
          mainEventRoomCode: ''
        });
        els.mainEventRoomCode.value = '';
        els.mainEventLockdown.value = '0';
        state.mainHostToken = '';
        state.mainHostRoomCode = '';
        state.liveStarted = false;
        await refreshAdminRooms();
        await loadMainEventSettings();
        save();
        render();
        setStatus(`Main Event stopped and room ${code} removed.`);
      } catch (e) {
        setStatus('Stop failed: ' + describeApiError(e));
      }
    });

    els.openMainEventBtn.addEventListener('click', () => {
      const code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
      setGuideProgress(4);
      window.open(mainEventJoinUrl(code), '_blank', 'noopener');
    });

    els.copyMainEventJoinBtn.addEventListener('click', async () => {
      try {
        const code = cleanCode(els.mainEventRoomCode.value || els.mainEventRooms.value);
        await navigator.clipboard.writeText(mainEventJoinUrl(code));
        setGuideProgress(4);
        setStatus('Main Event public link copied.');
      } catch (_) {
        setStatus('Copy failed. Browser blocked clipboard.');
      }
    });

    els.rollbackMainEventBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        await api('/api/watch/admin/settings', {
          adminToken: state.token,
          adminCode,
          action: 'set',
          mainEventLockdown: false,
          mainEventRoomCode: ''
        });
        els.mainEventLockdown.value = '0';
        els.mainEventRoomCode.value = '';
        state.liveStarted = false;
        setGuideProgress(0);
        setChecklist();
        await refreshAdminRooms();
        await loadMainEventSettings();
        setStatus('Rollback complete. Normal room hosting is open again.');
      } catch (e) {
        setStatus('Rollback failed: ' + describeApiError(e));
      }
    });

    els.studioLoadStreamBtn.addEventListener('click', () => {
      const code = selectedMainRoomCode();
      const url = mainEventStudioUrl(code);
      els.studioStreamUrl.value = url;
      els.studioStreamFrame.src = url;
      setChecklist();
      setGuideProgress(2);
      setStatus(`Stream console loaded for ${cleanCode(code) || 'admin mode'}.`);
    });

    els.studioPopoutStreamBtn.addEventListener('click', () => {
      const code = selectedMainRoomCode();
      const url = mainEventStudioUrl(code);
      els.studioStreamUrl.value = url;
      window.open(url, '_blank', 'noopener');
    });

    els.studioRefreshStreamBtn.addEventListener('click', () => {
      const current = String(els.studioStreamFrame.src || '').trim();
      if (!current) {
        const code = selectedMainRoomCode();
        const url = mainEventStudioUrl(code);
        els.studioStreamUrl.value = url;
        els.studioStreamFrame.src = url;
        return;
      }
      els.studioStreamFrame.src = current;
      setChecklist();
      setStatus('Stream console refreshed.');
    });

    els.addAdminBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        await api('/api/watch/admin/add', {
          adminToken: state.token,
          adminCode,
          newUsername: String(els.newAdminUser.value || '').trim().toLowerCase(),
          newPassword: String(els.newAdminPass.value || '').trim()
        });
        els.newAdminPass.value = '';
        await refreshAdmins();
        setStatus('Admin saved.');
      } catch (e) {
        setStatus('Add/update failed: ' + describeApiError(e));
      }
    });

    els.refreshBtn.addEventListener('click', async () => {
      try {
        await refreshAdmins();
        await refreshAdminRooms();
        setStatus('Admin list + rooms refreshed.');
      } catch (e) {
        setStatus('Refresh failed: ' + (e.message || e));
      }
    });

    els.removeAdminBtn.addEventListener('click', async () => {
      try {
        const adminCode = ensureAdminCode();
        const username = String(els.adminList.value || '').trim().toLowerCase();
        await api('/api/watch/admin/remove', {
          adminToken: state.token,
          adminCode,
          username
        });
        await refreshAdmins();
        setStatus('Admin removed: ' + username);
      } catch (e) {
        setStatus('Remove failed: ' + describeApiError(e));
      }
    });

    load();
    loadAdminCode();
    els.adminCode.addEventListener('input', () => { persistAdminCode(); setChecklist(); });
    els.username.value = state.username || 'Trimbledustn@gmail.com';
    els.mainEventHostName.value = 'DFrenzy';
    els.mainEventCountdown.value = nextSaturdayLocalInput();
    els.studioStreamUrl.value = mainEventStudioUrl('');
    render();
    refreshHealthBadges().catch(() => {});
    setInterval(() => { refreshHealthBadges().catch(() => {}); }, 20000);
    setInterval(() => { refreshLiveMetrics().catch(() => {}); }, 8000);
    setInterval(() => {
      if (!state.delayedGoLiveAt) return;
      const left = state.delayedGoLiveAt - Date.now();
      if (left <= 0) {
        state.delayedGoLiveAt = 0;
        if (!state.delayedGoLiveTimer) els.delayedStartStatus.textContent = 'No delayed start scheduled.';
        return;
      }
      const sec = Math.ceil(left / 1000);
      els.delayedStartStatus.textContent = `Go Live scheduled in ${sec}s.`;
    }, 1000);
    if (state.token) {
      refreshAdmins().catch(() => {});
      refreshAdminRooms().catch(() => {});
      loadMainEventSettings().catch(() => {});
      refreshInvites().catch(() => {});
      refreshLiveMetrics().catch(() => {});
    }
  </script>
</body>
</html>
